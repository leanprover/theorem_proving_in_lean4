window.docContents[207].resolve({"/Induction-and-Recursion/#dependent-pattern-matching":{"contents":"All the examples of pattern matching we considered in the section on\npattern matching can easily be written using casesOn\nand recOn. However, this is often not the case with indexed\ninductive families such as Vect α n, since case splits impose\nconstraints on the values of the indices. Without the equation\ncompiler, we would need a lot of boilerplate code to define very\nsimple functions such as map\n, zip\n, and unzip\n using\nrecursors. To understand the difficulty, consider what it would take\nto define a function tail\n which takes a vector\nv : Vect α (n + 1) and deletes the first element.A first thought might be to use the Vect.casesOn function:But what value should we return in the nil case? Something funny\nis going on: if v\n has type Vect α (n + 1)\n, it can't be\nnil, but it is not clear how to tell that to Vect.casesOn.\n\nOne solution is to define an auxiliary function:\n\n\n\nIn the nil case, m is instantiated to 0, and\nNat.noConfusion makes use of the fact that 0 = n + 1 cannot\noccur.  Otherwise, v is of the form cons a as, and we can simply\nreturn as, after casting it from a vector of length m to a\nvector of length n.\n\nThe difficulty in defining tail is to maintain the relationships between the indices.\nThe hypothesis m = n + 1 in tailAux is used to communicate the relationship\nbetween n and the index associated with the minor premise.\nMoreover, the 0 = n + 1 case is unreachable, and the canonical way to discard such\na case is to use Nat.noConfusion.\n\nThe tail function is, however, easy to define using recursive\nequations, and the equation compiler generates all the boilerplate\ncode automatically for us. Here are a number of similar examples:\n\nNote that we can omit recursive equations for “unreachable” cases such\nas head nil. The automatically generated definitions for indexed\nfamilies are far from straightforward. For example:\n\n\n\nThe zipWith function is even more tedious to define by hand than the\ntail function. We encourage you to try it, using Vect.recOn,\nVect.casesOn and Vect.noConfusion.\n\n","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","header":"8.8. Dependent Pattern Matching","id":"/Induction-and-Recursion/#dependent-pattern-matching"}});