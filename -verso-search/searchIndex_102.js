window.docContents[102].resolve({"/Tactics/#basic-tactics":{"id":"/Tactics/#basic-tactics","header":"5.2. Basic Tactics","context":"Theorem Proving in Lean 4\u0009Tactics","contents":"In addition to apply and exact, another useful tactic is\nintro, which introduces a hypothesis. What follows is an example\nof an identity from propositional logic that we proved in a previous\nchapter, now proved using tactics.\n\nThe intro command can more generally be used to introduce a variable of any type:\n\n\n\nYou can use it to introduce several variables:\n\n\n\nAs the apply tactic is a command for constructing function\napplications interactively, the intro tactic is a command for\nconstructing function abstractions interactively (i.e., terms of the\nform fun x => e\n).  As with lambda abstraction notation, the\nintro tactic allows us to use an implicit match.\n\n\n\nYou can also provide multiple alternatives like in the match expression.\n\n\n\nThe intros tactic can be used without any arguments, in which\ncase, it chooses names and introduces as many variables as it can. You\nwill see an example of this in a moment.The assumption tactic looks through the assumptions in context of\nthe current goal, and if there is one matching the conclusion, it\napplies it.It will unify metavariables in the conclusion if necessary:The following example uses the intros command to introduce the three variables and two hypotheses automatically:\n\nNote that names automatically generated by Lean are inaccessible by default. The motivation is to\nensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.\nHowever, you can use the combinator unhygienic to disable this restriction.\n\nYou can also use the rename_i tactic to rename the most recent inaccessible names in your context.\nIn the following example, the tactic rename_i h1 _ h2 renames two of the last three hypotheses in\nyour context.\n\nThe rfl tactic solves goals that are reflexive relations applied to definitionally equal arguments.\nEquality is reflexive:\n\nThe repeat combinator can be used to apply a tactic several times:\n\nAnother tactic that is sometimes useful is the revert tactic,\nwhich is, in a sense, an inverse to intro:After revert x, the proof state is:After intro y, it is:\n\nMoving a hypothesis into the goal yields an implication:\n\n\n\nAfter revert h, the proof state is:\n\n\n\nAfter intro h‚ÇÅ, it is:\n\n\n\nBut revert is even more clever, in that it will revert not only an\nelement of the context but also all the subsequent elements of the\ncontext that depend on it. For example, reverting x in the example\nabove brings h along with it:After revert x, the goal is:\n\nYou can also revert multiple elements of the context at once:\n\n\n\nAfter revert x y, the goal is:\n\n\n\nYou can only revert an element of the local context, that is, a\nlocal variable or hypothesis. But you can replace an arbitrary\nexpression in the goal by a fresh variable using the generalize\ntactic:In particular, after generalize, the goal is\n\nThe mnemonic in the notation above is that you are generalizing the\ngoal by setting 3 to an arbitrary variable x. Be careful: not\nevery generalization preserves the validity of the goal. Here,\ngeneralize replaces a goal that could be proved using\nrfl with one that is not provable:\n\n\n\nIn this example, the sorry tactic is the analogue of the sorry\n\nproof term. It closes the current goal, producing the usual warning\nthat sorry\n has been used. To preserve the validity of the previous\ngoal, the generalize tactic allows us to record the fact that\n3 has been replaced by x. All you need to do is to provide a\nlabel, and generalize uses it to store the assignment in the local\ncontext:\n\n\n\nFollowing generalize h : 3 = x, h is a proof that 3 = x:\n\n\n\nHere the rewriting tactic rw uses h to replace\nx by 3 again. The rw tactic will be discussed below.\n\n"}});