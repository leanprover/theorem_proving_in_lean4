window.docContents[39].resolve({"/Inductive-Types/#tactics-for-inductive-types":{"contents":"Given the fundamental importance of inductive types in Lean, it should\nnot be surprising that there are a number of tactics designed to work\nwith them effectively. We describe some of them here.\n\nThe cases tactic works on elements of an inductively defined type,\nand does what the name suggests: it decomposes the element according\nto each of the possible constructors. In its most basic form, it is\napplied to an element x\n in the local context. It then reduces the\ngoal to cases in which x\n is replaced by each of the constructions.\n\n\n\nIn the first branch, the proof state is:\n\n\n\nIn the second branch, it is:\n\n\n\nThere are extra bells and whistles. For one thing, cases allows\nyou to choose the names for each alternative using a\nwith clause. In the next example, for example, we choose the name\nm for the argument to succ, so that the second case refers to\nsucc m. More importantly, the cases tactic will detect any items\nin the local context that depend on the target variable. It reverts\nthese elements, does the split, and reintroduces them. In the example\nbelow, notice that the hypothesis h : n ≠ 0 becomes h : 0 ≠ 0\nin the first branch, and h : m + 1 ≠ 0 in the second.\n\nNotice that cases can be used to produce data as well as prove propositions.\n\n\n\nOnce again, cases will revert, split, and then reintroduce dependencies in the context.\n\n\n\nHere is an example of multiple constructors with arguments.\n\n\n\nThe alternatives for each constructor don't need to be solved\nin the order the constructors were declared.\n\n\n\nThe syntax of the with is convenient for writing structured proofs.\nLean also provides a complementary case tactic, which allows you to focus on goal\nassign variable names.\n\nThe case tactic is clever, in that it will match the constructor to the appropriate goal. For example, we can fill the goals above in the opposite order:\n\n\n\nYou can also use cases with an arbitrary expression. Assuming that\nexpression occurs in the goal, the cases tactic will generalize over\nthe expression, introduce the resulting universally quantified\nvariable, and case on that.\n\n\n\nThink of this as saying “split on cases as to whether m + 3 * k is\nzero or the successor of some number.” The result is functionally\nequivalent to the following:\n\n\n\nNotice that the expression m + 3 * k is erased by generalize; all\nthat matters is whether it is of the form 0 or n✝ + 1. This\nform of cases will not revert any hypotheses that also mention\nthe expression in the equation (in this case, m + 3 * k). If such a\nterm appears in a hypothesis and you want to generalize over that as\nwell, you need to revert it explicitly.\n\nIf the expression you case on does not appear in the goal, the\ncases tactic uses have to put the type of the expression into\nthe context. Here is an example:\n\n\n\nThe theorem Nat.lt_or_ge m n says m < n ∨ m ≥ n, and it is\nnatural to think of the proof above as splitting on these two\ncases. In the first branch, we have the hypothesis hlt : m < n, and\nin the second we have the hypothesis hge : m ≥ n. The proof above\nis functionally equivalent to the following:\n\n\n\nAfter the first two lines, we have h : m < n ∨ m ≥ n as a\nhypothesis, and we simply do cases on that.\n\nHere is another example, where we use the decidability of equality on\nthe natural numbers to split on the cases m = n and m ≠ n.\n\nRemember that if you open Classical, you can use the law of the\nexcluded middle for any proposition at all. But using type class\ninference (see Type Classes), Lean can actually\nfind the relevant decision procedure, which means that you can use the\ncase split in a computable function.\n\nJust as the cases tactic can be used to carry out proof by cases,\nthe induction tactic can be used to carry out proofs by\ninduction. The syntax is similar to that of cases, except that the\nargument can only be a term in the local context. Here is an example:\n\nAs with cases, we can use the case tactic instead of with.\n\nHere are some additional examples:\n\n\n\n\n\nThe induction tactic also supports user-defined induction principles with\nmultiple targets (aka major premises). This example uses Nat.mod.inductionOn, which has the following signature:\n\n\n\n\n\nYou can use the match notation in tactics too:\n\n\n\nAs a convenience, pattern-matching has been integrated into tactics such as intro and funext.\n\nWe close this section with one last tactic that is designed to\nfacilitate working with inductive types, namely, the injection\ntactic. By design, the elements of an inductive type are freely\ngenerated, which is to say, the constructors are injective and have\ndisjoint ranges. The injection tactic is designed to make use of\nthis fact:\n\nThe first instance of the tactic adds h' : m + 1 = n + 1 to the\ncontext, and the second adds h'' : m = n.\n\nThe injection tactic also detects contradictions that arise when different constructors\nare set equal to one another, and uses them to close the goal.\n\n\n\nAs the second example shows, the contradiction tactic also detects contradictions of this form.\n\n","context":"Theorem Proving in Lean 4\u0009Inductive Types","header":"7.6. Tactics for Inductive Types","id":"/Inductive-Types/#tactics-for-inductive-types"},"/Tactics/#rewriting":{"contents":"The rw tactic and the simp tactic\nwere introduced briefly in Calculational Proofs. In this\nsection and the next, we discuss them in greater detail.\n\nThe rw tactic provides a basic mechanism for applying\nsubstitutions to goals and hypotheses, providing a convenient and\nefficient way of working with equality. The most basic form of the\ntactic is rw [t], where t is a term whose type asserts an\nequality. For example, t can be a hypothesis h : x = y in the\ncontext; it can be a general lemma, like\nadd_comm : ∀ x y, x + y = y + x\n, in which the rewrite tactic tries to find suitable\ninstantiations of x\n and y\n; or it can be any compound term\nasserting a concrete or general equation. In the following example, we\nuse this basic form to rewrite the goal using a hypothesis.\n\n\n\nIn the example above, the first use of rw replaces k with\n0 in the goal f k = 0. Then, the second one replaces f 0\nwith 0. The tactic automatically closes any goal of the form\nt = t\n. Here is an example of rewriting using a compound expression:\n\n\n\nHere, h hq establishes the equation x = y.\n\nMultiple rewrites can be combined using the notation rw [t_1, ..., t_n],\nwhich is just shorthand for rw[t_1]; ...;rw [t_n]. The previous example can be written as follows:\n\n\n\nBy default, rw uses an equation in the forward direction, matching\nthe left-hand side with an expression, and replacing it with the\nright-hand side. The notation ←t can be used to instruct the\ntactic to use the equality t in the reverse direction.\n\n\n\nIn this example, the term ←h₁ instructs the rewriter to replace\nb with a. In the editors, you can type the backwards arrow as\n. You can also use the ASCII equivalent, <-.\n\nSometimes the left-hand side of an identity can match more than one\nsubterm in the pattern, in which case the rw tactic chooses the\nfirst match it finds when traversing the term. If that is not the one\nyou want, you can use additional arguments to specify the appropriate\nsubterm.\n\n\n\n\n\nIn the first example above, the first step rewrites a + b + c to\na + (b + c). The next step applies commutativity to the term\nb + c; without specifying the argument, the tactic would instead rewrite\na + (b + c) to (b + c) + a. Finally, the last step applies\nassociativity in the reverse direction, rewriting a + (c + b) to\na + c + b. The next two examples instead apply associativity to\nmove the parenthesis to the right on both sides, and then switch b\nand c. Notice that the last example specifies that the rewrite\nshould take place on the right-hand side by specifying the second\nargument to Nat.add_comm.\n\nBy default, the rw tactic affects only the goal. The notation\nrw [t] at h applies the rewrite\n\n\n\nThe first step, rw [Nat.add_zero] at h, rewrites the hypothesis a + 0 = 0 to a = 0.\nThen the new hypothesis a = 0 is used to rewrite the goal to f 0 = f 0.\n\nThe rw tactic is not restricted to propositions.\nIn the following example, we use rw [h] at t to rewrite the hypothesis t : Tuple α n to t : Tuple α 0.\n\n","context":"Theorem Proving in Lean 4\u0009Tactics","header":"5.6. Rewriting","id":"/Tactics/#rewriting"}});