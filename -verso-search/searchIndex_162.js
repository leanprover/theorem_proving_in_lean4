window.docContents[162].resolve({"/Induction-and-Recursion/#functional-induction":{"id":"/Induction-and-Recursion/#functional-induction","header":"8.6. Functional Induction","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","contents":"Lean generates bespoke induction principles for recursive functions. These induction principles follow the recursive structure of the function's definition, rather than the structure of the datatype. Proofs about functions typically follow the recursive structure of the function itself, so these induction principles allow statements about the function to be proved more conveniently.\n\nFor example, using the functional induction principle for ack to prove that the result is always greater than 0 requires one case for each arm of the pattern match in ack:\n\nIn , the goal is:\n\n\n\nThe y + 1 in the goal corresponds to the value returned in the first case of ack.\n\nIn , the goal is:\n\n\n\nThe ack x 1 in the goal corresponds to the value of ack applied to the pattern variables x + 1 and 0 returned in the second case of ack.\nThis term is automatically simplified to the right-hand side.\nHappily, the inductive hypothesis ih : ack x 1 > 0 corresponds to the recursive call, which is exactly the answer returned in this case.\n\nIn , the goal is:\n\n\n\nThe ack x (ack (x + 1) y) in the goal corresponds to the value returned in the third case of ack, when ack applied to x + 1 and y + 1 has been reduced.\nThe inductive hypotheses ih1 : ack (x + 1) y > 0 and ih2 : ack x (ack (x + 1) y) > 0 correspond to the recursive calls, with ih1 matching the nested recursive call.\nOnce again, the induction hypothesis is suitable.\n\nUsing fun_induction ack results in goals and induction hypotheses that match the recursive structure of ack. As a result, the proof can be a single line:\n\n\n\nThere is also a fun_cases tactic which is analogous to the cases tactic.\nIt generates a case for each branch in a function's control flow.\nBoth it and fun_induction additionally provide assumptions that rule out the paths that were not taken.This function f represents a five-way Boolean disjunction:To prove that it is disjunction, the last case requires knowledge that none of the arguments are true.\nThis knowledge is provided by the tactic:\n\nEach case includes an assumption that rules out the prior cases:\n\n\n\nThe simp_all tactic, which simplifies all the assumptions and the goal together, can dispatch all cases:\n\n"}});