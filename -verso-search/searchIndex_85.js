window.docContents[85].resolve({"/Quantifiers-and-Equality/#equality":{"contents":"Let us now turn to one of the most fundamental relations defined in\nLean's library, namely, the equality relation. In the chapter on inductive types,\nwe will explain how equality is defined from the primitives of Lean's logical framework.\nIn the meanwhile, here we explain how to use it.\n\nOf course, a fundamental property of equality is that it is an equivalence relation:\n\n\n\nWe can make the output easier to read by telling Lean not to insert\nthe implicit arguments (which are displayed here as metavariables).\n\n\n\nThe inscription .{u} tells Lean to instantiate the constants at the universe u.\n\nThus, for example, we can specialize the example from the previous section to the equality relation:\n\n\n\nWe can also use the projection notation:\n\n\n\nReflexivity is more powerful than it looks. Recall that terms in the\nCalculus of Constructions have a computational interpretation, and\nthat the logical framework treats terms with a common reduct as the\nsame. As a result, some nontrivial identities can be proved by\nreflexivity:\n\n\n\nThis feature of the framework is so important that the library defines a notation rfl\n for Eq.refl _\n:\n\n\n\nEquality is much more than an equivalence relation, however. It has\nthe important property that every assertion respects the equivalence,\nin the sense that we can substitute equal expressions without changing\nthe truth value. That is, given h1 : a = b and h2 : p a, we\ncan construct a proof for p b\n using substitution:\nEq.subst h1 h2\n.\n\n\n\nThe triangle in the second presentation is a macro built on top of\nEq.subst\n and Eq.symm\n, and you can enter it by typing .\n\nThe rule Eq.subst\n is used to define the following auxiliary rules,\nwhich carry out more explicit substitutions. They are designed to deal\nwith applicative terms, that is, terms of form s t\n. Specifically,\ncongrArg\n can be used to replace the argument, congrFun\n can be\nused to replace the term that is being applied, and congr\n can be\nused to replace both at once.\n\n\n\nLean's library contains a large number of common identities, such as these:\n\n\n\nNote that Nat.mul_add\n and Nat.add_mul\n are alternative names\nfor Nat.left_distrib\n and Nat.right_distrib\n, respectively.  The\nproperties above are stated for the natural numbers (type Nat\n).\n\nHere is an example of a calculation in the natural numbers that uses\nsubstitution combined with associativity and distributivity.\n\n\n\nNotice that the second implicit parameter to Eq.subst\n, which\nprovides the context in which the substitution is to occur, has type\nα → Prop\n.  Inferring this predicate therefore requires an instance\nof higher-order unification. In full generality, the problem of\ndetermining whether a higher-order unifier exists is undecidable, and\nLean can at best provide imperfect and approximate solutions to the\nproblem. As a result, Eq.subst\n doesn't always do what you want it\nto.  The macro h ▸ e uses more effective heuristics for computing\nthis implicit parameter, and often succeeds in situations where\napplying Eq.subst\n fails.\n\nBecause equational reasoning is so common and important, Lean provides\na number of mechanisms to carry it out more effectively. The next\nsection offers syntax that allow you to write calculational proofs in\na more natural and perspicuous way. But, more importantly, equational\nreasoning is supported by a term rewriter, a simplifier, and other\nkinds of automation. The term rewriter and simplifier are described\nbriefly in the next section, and then in greater detail in the next\nchapter.\n\n","context":"Theorem Proving in Lean 4\u0009Quantifiers and Equality","header":"4.2. Equality","id":"/Quantifiers-and-Equality/#equality"}});