window.docContents[0].resolve({"/Dependent-Type-Theory/#what-makes-dependent-type-theory-dependent":{"id":"/Dependent-Type-Theory/#what-makes-dependent-type-theory-dependent","header":"2.8. What makes dependent type theory dependent?","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","contents":"The short explanation is that types can depend on parameters. You\nhave already seen a nice example of this: the type List α\n depends\non the argument α\n, and this dependence is what distinguishes\nList Nat\n and List Bool\n. For another example, consider the\ntype Vector α n\n, the type of vectors of elements of α\n of\nlength n\n.  This type depends on two parameters: the type of the\nelements in the vector (α : Type) and the length of the vector\nn : Nat.\n\nSuppose you wish to write a function cons which inserts a new\nelement at the head of a list. What type should cons have? Such a\nfunction is polymorphic: you expect the cons function for\nNat\n, Bool\n, or an arbitrary type α to behave the same way.\nSo it makes sense to take the type to be the first argument to\ncons, so that for any type, α\n, cons α\n is the insertion\nfunction for lists of type α\n. In other words, for every α\n,\ncons α\n is the function that takes an element a : α and a list\nas : List α, and returns a new list, so you have cons α a as : List α\n.It is clear that cons α\n should have type α → List α → List α\n.\nBut what type should cons have?  A first guess might be\nType → α → List α → List α\n, but, on reflection, this does not make\nsense: the α in this expression does not refer to anything,\nwhereas it should refer to the argument of type Type\n.  In other\nwords, assuming α : Type is the first argument to the function,\nthe type of the next two elements are α\n and List α\n. These\ntypes vary depending on the first argument, α.\n\nThis is an instance of a dependent function type, or dependent\narrow type. Given α : Type and β : α → Type, think of β\n\nas a family of types over α\n, that is, a type β a\n for each\na : α. In that case, the type (a : α) → β a\n denotes the type\nof functions f\n with the property that, for each a : α, f a\n\nis an element of β a\n. In other words, the type of the value\nreturned by f\n depends on its input.\n\nNotice that (a : α) → β\n makes sense for any expression β : Type.\nWhen the value of β\n depends on a (as does, for\nexample, the expression β a in the previous paragraph),\n(a : α) → β denotes a dependent function type. When β\n doesn't\ndepend on a, (a : α) → β is no different from the type\nα → β\n.  Indeed, in dependent type theory (and in Lean), α → β\n\nis just notation for (a : α) → β\n when β\n does not depend on a.\n\nReturning to the example of lists, you can use the command #check to\ninspect the type of the following List\n functions.  The @ symbol\nand the difference between the round and curly braces will be\nexplained momentarily.\n\n\n\nJust as dependent function types (a : α) → β a\n generalize the\nnotion of a function type α → β by allowing β to depend on\nα\n, dependent Cartesian product types (a : α) × β a\n generalize\nthe Cartesian product α × β in the same way. Dependent products\nare also called sigma types, and you can also write them as\nΣ a : α, β a\n. You can use ⟨a, b⟩\n or Sigma.mk a b\n to create a\ndependent pair.  The ⟨ and ⟩ characters may be typed with\n and  or  and , respectively.\n\n\n\nThe functions f and g above denote the same function.\n\n"}});