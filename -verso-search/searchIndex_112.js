window.docContents[112].resolve({"/Inductive-Types/#mutual-and-nested-inductive-types":{"contents":"We now consider two generalizations of inductive types that are often\nuseful, which Lean supports by “compiling” them down to the more\nprimitive kinds of inductive types described above. In other words,\nLean parses the more general definitions, defines auxiliary inductive\ntypes based on them, and then uses the auxiliary types to define the\nones we really want. Lean's equation compiler, described in the next\nchapter, is needed to make use of these types\neffectively. Nonetheless, it makes sense to describe the declarations\nhere, because they are straightforward variations on ordinary\ninductive definitions.\n\nFirst, Lean supports mutually defined inductive types. The idea is\nthat we can define two (or more) inductive types at the same time,\nwhere each one refers to the other(s).\n\n\n\nIn this example, two types are defined simultaneously: a natural\nnumber n is Even if it is 0\n or one more than an Odd\nnumber, and Odd if it is one more than an Even number.\nIn the exercises below, you are asked to spell out the details.\n\nA mutual inductive definition can also be used to define the notation\nof a finite tree with nodes labelled by elements of α:\n\nWith this definition, one can construct an element of Tree α by\ngiving an element of α together with a list of subtrees, possibly\nempty. The list of subtrees is represented by the type TreeList α,\nwhich is defined to be either the empty list, nil, or the\ncons of a tree and an element of TreeList α.\n\nThis definition is inconvenient to work with, however. It would be\nmuch nicer if the list of subtrees were given by the type\nList (Tree α), especially since Lean's library contains a number of functions\nand theorems for working with lists. One can show that the type\nTreeList α is isomorphic to List (Tree α), but translating\nresults back and forth along this isomorphism is tedious.In fact, Lean allows us to define the inductive type we really want:\n\nThis is known as a nested inductive type. It falls outside the\nstrict specification of an inductive type given in the last section\nbecause Tree does not occur strictly positively among the\narguments to mk, but, rather, nested inside the List type\nconstructor. Lean then automatically builds the\nisomorphism between TreeList α and List (Tree α) in its kernel,\nand defines the constructors for Tree in terms of the isomorphism.\n\n","context":"Theorem Proving in Lean 4\u0009Inductive Types","header":"7.9. Mutual and Nested Inductive Types","id":"/Inductive-Types/#mutual-and-nested-inductive-types"}});