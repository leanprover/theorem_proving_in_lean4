window.docContents[84].resolve({"/Type-Classes/#chaining-instances":{"id":"/Type-Classes/#chaining-instances","header":"10.1. Chaining Instances","context":"Theorem Proving in Lean 4\u0009Type Classes","contents":"If that were the extent of type class inference, it would not be all that impressive;\nit would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.\nWhat makes type class inference powerful is that one can chain instances. That is,\nan instance declaration can in turn depend on an implicit instance of a type class.\nThis causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.\n\nFor example, the following definition shows that if two types α and β are inhabited, then so is their product:\n\nWith this added to the earlier instance declarations, type class instance can infer, for example, a default element of Nat × Bool\n:\n\n\n\nSimilarly, we can inhabit type function with suitable constant functions:\n\n\n\nAs an exercise, try defining default instances for other types, such as List\n and Sum\n types.\n\nThe Lean standard library contains the definition inferInstance. It has type {α : Sort u} → [i : α] → α\n,\nand is useful for triggering the type class resolution procedure when the expected type is an instance.\n\n\n\nYou can use the command #print to inspect how simple inferInstance is.\n\n"},"/The-Conversion-Tactic-Mode/#other-tactics-inside-conversion-mode":{"id":"/The-Conversion-Tactic-Mode/#other-tactics-inside-conversion-mode","header":"11.4. Other tactics inside conversion mode","context":"Theorem Proving in Lean 4\u0009The Conversion Tactic Mode","contents":"* arg i enter the i-th nondependent explicit argument of an application.* args is an alternative name for congr.* simp applies the simplifier to the current goal. It supports the same options available in regular tactic mode.* enter [1, x, 2, y] iterate arg and intro with the given arguments.* done fail if there are unsolved goals.* trace_state display the current tactic state.* whnf put term in weak head normal form.* tactic => <tactic sequence> go back to regular tactic mode. This\n  is useful for discharging goals not supported by conv mode, and\n  applying custom congruence and extensionality lemmas.* apply <term> is syntax sugar for tactic => apply <term>.\n\n"},"/Interacting-with-Lean/#coercions":{"id":"/Interacting-with-Lean/#coercions","header":"6.8. Coercions","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","contents":"In Lean, the type of natural numbers, Nat\n, is different from the\ntype of integers, Int\n. But there is a function Int.ofNat\n that\nembeds the natural numbers in the integers, meaning that we can view\nany natural number as an integer, when needed. Lean has mechanisms to\ndetect and insert coercions of this sort. Coercions can be explicitly\nrequested using the overloaded ↑ operator.\n\n\n\n"}});