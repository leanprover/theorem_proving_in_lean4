window.docContents[126].resolve({"/Propositions-and-Proofs/#negation-and-falsity":{"id":"/Propositions-and-Proofs/#negation-and-falsity","header":"3.3.3. Negation and Falsity","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs\u0009Propositional Logic","contents":"Negation, ¬p\n, is actually defined to be p → False\n, so we\nobtain ¬p\n by deriving a contradiction from p\n. Similarly, the\nexpression hnp hp\n produces a proof of False\n from hp : p\nand hnp : ¬p. The next example uses both these rules to produce a\nproof of (p → q) → ¬q → ¬p\n. (The symbol ¬ is produced by\ntyping  or .)\n\n\n\nThe connective False\n has a single elimination rule,\nFalse.elim\n, which expresses the fact that anything follows from a\ncontradiction. This rule is sometimes called ex falso (short for ex\nfalso sequitur quodlibet), or the principle of explosion.\n\n\n\nThe arbitrary fact, q\n, that follows from falsity is an implicit\nargument in False.elim\n and is inferred automatically. This\npattern, deriving an arbitrary fact from contradictory hypotheses, is\nquite common, and is represented by absurd\n.\n\n\n\nHere, for example, is a proof of ¬p → q → (q → p) → r\n:\n\n\n\nIncidentally, just as False\n has only an elimination rule, True\n\nhas only an introduction rule, True.intro : True\n.  In other words,\nTrue\n is simply true, and has a canonical proof, True.intro\n.\n\n"}});