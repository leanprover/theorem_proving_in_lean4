window.docContents[20].resolve({"/Induction-and-Recursion/#mutual-recursion":{"id":"/Induction-and-Recursion/#mutual-recursion","header":"8.7. Mutual Recursion","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","contents":"Lean also supports mutual recursive definitions. The syntax is similar to that for mutual inductive types. Here is an example:\n\n\n\nWhat makes this a mutual definition is that even is defined recursively in terms of odd, while odd is defined recursively in terms of even. Under the hood, this is compiled as a single recursive definition. The internally defined function takes, as argument, an element of a sum type, either an input to even, or an input to odd. It then returns an output appropriate to the input. To define that function, Lean uses a suitable well-founded measure. The internals are meant to be hidden from users; the canonical way to make use of such definitions is to use simp (or unfold), as we did above.\n\nMutual recursive definitions also provide natural ways of working with mutual and nested inductive types. Recall the definition of Even and Odd as mutual inductive predicates as presented before.\n\nThe constructors, even_zero, even_succ, and odd_succ provide positive means for showing that a number is even or odd. We need to use the fact that the inductive type is generated by these constructors to know that zero is not odd, and that the latter two implications reverse. As usual, the constructors are kept in a namespace that is named after the type being defined, and the command open Even Odd allows us to access them more conveniently.\n\nFor another example, suppose we use a nested inductive type to define a set of terms inductively, so that a term is either a constant (with a name given by a string), or the result of applying a constant to a list of constants.\n\n\n\nWe can then use a mutual recursive definition to count the number of constants occurring in a term, as well as the number occurring in a list of terms.\n\n\n\nAs a final example, we define a function replaceConst a b e that replaces a constant a with b in a term e, and then prove the number of constants is the same. Note that, our proof uses mutual recursion (aka induction).\n\n"}});