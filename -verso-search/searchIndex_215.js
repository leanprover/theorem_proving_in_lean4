window.docContents[215].resolve({"/Interacting-with-Lean/#more-on-implicit-arguments":{"id":"/Interacting-with-Lean/#more-on-implicit-arguments","header":"6.6. More on Implicit Arguments","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","contents":"In Implicit Arguments,\nwe saw that if Lean displays the type\nof a term t\n as {x : α} → β x\n, then the curly brackets\nindicate that x has been marked as an implicit argument to\nt\n. This means that whenever you write t\n, a placeholder, or\n“hole,” is inserted, so that t\n is replaced by @t _\n. If you\ndon't want that to happen, you have to write @t\n instead.\n\nNotice that implicit arguments are inserted eagerly. Suppose we define\na function f : (x : Nat) → {y : Nat} → (z : Nat) → Nat.\nThen, when we write the expression f 7\n without further\narguments, it is parsed as @f 7 _\n.\n\nLean offers a weaker annotation which specifies that a placeholder should only be added\nbefore a subsequent explicit argument. It can be written with double braces, so the type of f\n would be\nf : (x : Nat) → {{y : Nat}} → (z : Nat) → Nat.\nWith this annotation, the expression f 7\n would be parsed as is, whereas f 7 3\n would be\nparsed as @f 7 _ 3\n, just as it would be with the strong annotation.\nThis annotation can also be written as ⦃y : Nat⦄, where the Unicode brackets are entered\nas  and , respectively.\n\nTo illustrate the difference, consider the following example, which\nshows that a reflexive euclidean relation is both symmetric and\ntransitive.\n\n\n\nThe results are broken down into small steps: th1 shows that a\nrelation that is reflexive and euclidean is symmetric, and th2\nshows that a relation that is symmetric and euclidean is\ntransitive. Then th3 combines the two results. But notice that we\nhave to manually disable the implicit arguments in euclr, because\notherwise too many implicit arguments are inserted. The problem goes\naway if we use weak implicit arguments:\n\n\n\nThere is a third kind of implicit argument that is denoted with square\nbrackets, [ and ]. These are used for type classes, as\nexplained in the chapter on type classes.\n\n"}});