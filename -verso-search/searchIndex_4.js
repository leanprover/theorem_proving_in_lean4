window.docContents[4].resolve({"/Induction-and-Recursion/#wildcards-and-overlapping-patterns":{"id":"/Induction-and-Recursion/#wildcards-and-overlapping-patterns","header":"8.2. Wildcards and Overlapping Patterns","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","contents":"Consider one of the examples from the last section:\n\n\n\nAn alternative presentation is:\n\n\n\nIn the second presentation, the patterns overlap; for example, the\npair of arguments 0, 0 matches all three cases. But Lean handles\nthe ambiguity by using the first applicable equation, so in this example\nthe net result is the same. In particular, the following equations hold\ndefinitionally:\n\n\n\nSince the values of m and n are not needed, we can just as well use wildcard patterns instead.\n\n\n\nYou can check that this definition of foo satisfies the same\ndefinitional identities as before.\n\nSome functional programming languages support incomplete\npatterns. In these languages, the interpreter produces an exception\nor returns an arbitrary value for incomplete cases. We can simulate\nthe arbitrary value approach using the Inhabited\n type\nclass. Roughly, an element of Inhabited α\n is a witness to the fact\nthat there is an element of α\n; in the chapter on type classes\nwe will see that Lean can be instructed that suitable\nbase types are inhabited, and can automatically infer that other\nconstructed types are inhabited. On this basis, the\nstandard library provides a default element, default\n, of\nany inhabited type.We can also use the type Option α\n to simulate incomplete patterns.\nThe idea is to return some a\n for the provided patterns, and use\nnone\n for the incomplete cases. The following example demonstrates\nboth approaches.\n\n\n\nThe equation compiler is clever. If you leave out any of the cases in\nthe following definition, the error message will let you know what has\nnot been covered.\n\n\n\nIt will also use an if ... then ... else instead of a casesOn in appropriate situations.\n\n\n\n"}});