window.docContents[24].resolve({"/Interacting-with-Lean/#auto-bound-implicit-arguments":{"contents":"In the previous section, we have shown how implicit arguments make functions more convenient to use.\nHowever, functions such as compose are still quite verbose to define. Note that the universe\npolymorphic compose is even more verbose than the one previously defined.\n\nYou can avoid the universe command by providing the universe parameters when defining compose.\n\nLean 4 supports a new feature called auto bound implicit arguments. It makes functions such as\ncompose much more convenient to write. When Lean processes the header of a declaration,\nany unbound identifier is automatically added as an implicit argument. With this feature we can write compose asNote that Lean inferred a more general type using Sort\n instead of Type.\n\nAlthough we love this feature and use it extensively when implementing Lean,\nwe realize some users may feel uncomfortable with it. Thus, you can disable it using\nthe command set_option autoImplicit false.\n\n\n\n","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","header":"6.12. Auto Bound Implicit Arguments","id":"/Interacting-with-Lean/#auto-bound-implicit-arguments"},"/Introduction/#computers-and-theorem-proving":{"contents":"Formal verification involves the use of logical and computational methods to establish claims that are expressed in\nprecise mathematical terms. These can include ordinary mathematical theorems, as well as claims that pieces of hardware\nor software, network protocols, and mechanical and hybrid systems meet their specifications. In practice, there is not a\nsharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal\nverification requires describing hardware and software systems in mathematical terms, at which point establishing claims\nas to their correctness becomes a form of theorem proving. Conversely, the proof of a mathematical theorem may require a\nlengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what\nit is supposed to do.\n\nThe gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic\nshow most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of\nfoundational systems. With this reduction, there are two ways that a computer can help establish a claim: it can help\nfind a proof in the first place, and it can help verify that a purported proof is correct.\n\nAutomated theorem proving focuses on the “finding” aspect. Resolution theorem provers, tableau theorem provers, fast\nsatisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and\nfirst-order logic. Other systems provide search procedures and decision procedures for specific languages and domains,\nsuch as linear or nonlinear expressions over the integers or the real numbers. Architectures like SMT (\"satisfiability\nmodulo theories”) combine domain-general search methods with domain-specific procedures. Computer algebra systems and\nspecialized mathematical software packages provide means of carrying out mathematical computations, establishing\nmathematical bounds, or finding mathematical objects. A calculation can be viewed as a proof as well, and these systems,\ntoo, help establish mathematical claims.\n\nAutomated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness. Such systems\ncan have bugs, and it can be difficult to ensure that the results they deliver are correct. In contrast, interactive\ntheorem proving focuses on the “verification” aspect of theorem proving, requiring that every claim is supported by a\nproof in a suitable axiomatic foundation. This sets a very high standard: every rule of inference and every step of a\ncalculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and\nrules. In fact, most such systems provide fully elaborated “proof objects” that can be communicated to other systems and\nchecked independently. Constructing such proofs typically requires much more input and interaction from users, but it\nallows you to obtain deeper and more complex proofs.\n\nThe Lean Theorem Prover aims to bridge the gap between interactive and automated theorem proving, by situating\nautomated tools and methods in a framework that supports user interaction and the construction of fully specified\naxiomatic proofs. The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify\nclaims in both domains.\n\nLean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming\nlanguage. More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as\nreasoning about the functions that the programs compute. Lean also has mechanisms to serve as its own metaprogramming\nlanguage, which means that you can implement automation and extend the functionality of Lean using Lean itself. These\naspects of Lean are described in the free online book, Functional Programming in Lean, though computational\naspects of the system will make an appearance here.\n\n","context":"Theorem Proving in Lean 4\u0009Introduction","header":"1.1. Computers and Theorem Proving","id":"/Introduction/#computers-and-theorem-proving"}});