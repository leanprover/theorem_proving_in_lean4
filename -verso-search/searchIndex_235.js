window.docContents[235].resolve({"/Interacting-with-Lean/#implicit-lambdas":{"id":"/Interacting-with-Lean/#implicit-lambdas","header":"6.13. Implicit Lambdas","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","contents":"\n\nWhen the expected type of an expression is a function that is awaiting implicit\narguments, the elaborator automatically introduces the corresponding lambdas.\nFor example, pure's type states that the first argument is an implicit type\nα, but ReaderT.pure's first agument is the reader monad's context type ρ.\nIt is automatically surrounded with a fun {α} => ..., which allows the elaborator to\ncorrectly fill in the implicit arguments in the body.\n\nUsers can disable the implicit lambda feature by using @ or writing\na lambda expression with {} or [] binder annotations.  Here are\nfew examples\n\n\n\n"},"/Induction-and-Recursion/#pattern-matching":{"id":"/Induction-and-Recursion/#pattern-matching","header":"8.1. Pattern Matching","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","contents":"The interpretation of schematic patterns is the first step of the\ncompilation process. We have seen that the casesOn recursor can\nbe used to define functions and prove theorems by cases, according to\nthe constructors involved in an inductively defined type. But\ncomplicated definitions may use several nested casesOn\napplications, and may be hard to read and understand. Pattern matching\nprovides an approach that is more convenient, and familiar to users of\nfunctional programming languages.\n\nConsider the inductively defined type of natural numbers. Every\nnatural number is either zero\n or succ x\n, and so you can define\na function from the natural numbers to an arbitrary type by specifying\na value in each of those cases:\n\n\n\nThe equations used to define these functions hold definitionally:\n\n\n\nInstead of zero and succ, we can use more familiar notation:\n\n\n\nBecause addition and the zero notation have been assigned the\n[match_pattern] attribute, they can be used in pattern matching. Lean\nsimply normalizes these expressions until the constructors zero\nand succ are exposed.\n\nPattern matching works with any inductive type, such as products and option types:\n\n\n\nHere we use it not only to define a function, but also to carry out a\nproof by cases:\n\n\n\nPattern matching can also be used to destruct inductively defined propositions:\n\n\n\nThis provides a compact way of unpacking hypotheses that make use of logical connectives.\n\nIn all these examples, pattern matching was used to carry out a single\ncase distinction. More interestingly, patterns can involve nested\nconstructors, as in the following examples.\n\n\n\nThe equation compiler first splits on cases as to whether the input is\nzero or of the form succ x.  It then does a case split on\nwhether x is of the form zero or succ x.  It determines\nthe necessary case splits from the patterns that are presented to it,\nand raises an error if the patterns fail to exhaust the cases. Once\nagain, we can use arithmetic notation, as in the version below. In\neither case, the defining equations hold definitionally.\n\n\n\nYou can write #print sub2 to see how the function was compiled to\nrecursors. (Lean will tell you that sub2 has been defined in terms\nof an internal auxiliary function, sub2.match_1\n, but you can print\nthat out too.) Lean uses these auxiliary functions to compile match expressions.\nActually, the definition above is expanded to\n\n\n\nHere are some more examples of nested pattern matching:\n\n\n\nThe equation compiler can process multiple arguments sequentially. For\nexample, it would be more natural to define the previous example as a\nfunction of two arguments:\n\n\n\nHere is another example:\n\n\n\nNote that the patterns are separated by commas.\n\nIn each of the following examples, splitting occurs on only the first\nargument, even though the others are included among the list of\npatterns.\n\n\n\nNotice also that, when the value of an argument is not needed in the\ndefinition, you can use an underscore instead. This underscore is\nknown as a wildcard pattern, or an anonymous variable. In contrast\nto usage outside the equation compiler, here the underscore does not\nindicate an implicit argument. The use of underscores for wildcards is\ncommon in functional programming languages, and so Lean adopts that\nnotation. The section on wildcards and overlapping patterns\nexpands on the notion of a wildcard, and the description of inaccessible patterns explains how\nyou can use implicit arguments in patterns as well.\n\nAs described in Inductive Types,\ninductive data types can depend on parameters. The following example defines\nthe tail function using pattern matching. The argument α : Type u\nis a parameter and occurs before the colon to indicate it does not participate in the pattern matching.\nLean also allows parameters to occur after the :, but pattern matching on them requires an explicit match.\n\nDespite the different placement of the parameter α in these two\nexamples, in both cases it is treated in the same way, in that it does\nnot participate in a case split.\n\nLean can also handle more complex forms of pattern matching, in which\narguments to dependent types pose additional constraints on the\nvarious cases. Such examples of dependent pattern matching are\nconsidered in the section on dependent pattern matching.\n\n"}});