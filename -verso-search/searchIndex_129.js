window.docContents[129].resolve({"/Dependent-Type-Theory/#function-abstraction-and-evaluation":{"contents":"Lean provides a fun (or λ) keyword to create a function\nfrom an expression as follows:\n\n\n\nThe type Nat\n can be inferred in this example:\n\n\n\nYou can evaluate a lambda function by passing the required parameters:\n\n\n\nCreating a function from another expression is a process known as\nlambda abstraction. Suppose you have the variable x : α and you can\nconstruct an expression t : β, then the expression fun (x : α) => t\n,\nor, equivalently, λ (x : α) => t\n, is an object of type α → β\n. Think of\nthis as the function from α\n to β\n which maps\nany value x to the value t.\n\nHere are some more examples\n\n\n\nLean interprets the final three examples as the same expression; in\nthe last expression, Lean infers the type of x and y from the\nexpression if not y then x + 1 else x + 2.\n\nSome mathematically common examples of operations of functions can be\ndescribed in terms of lambda abstraction:\n\n\n\nThink about what these expressions mean. The expression\nfun x : Nat => x\n denotes the identity function on Nat\n, the\nexpression fun x : Nat => true\n denotes the constant function that\nalways returns true\n, and fun x : Nat => g (f x) denotes the\ncomposition of f and g.  You can, in general, leave off the\ntype annotation and let Lean infer it for you.  So, for example, you\ncan write fun x => g (f x) instead of fun x : Nat => g (f x).\n\nYou can pass functions as parameters and by giving them names f\nand g you can then use those functions in the implementation:\n\nYou can also pass types as parameters:\n\n\n\nThe last expression, for example, denotes the function that takes\nthree types, α, β, and γ, and two functions, g : β → γ\nand f : α → β, and returns the composition of g and f.\n(Making sense of the type of this function requires an understanding\nof dependent products, which will be explained below.)\n\nThe general form of a lambda expression is fun (x : α) => t\n, where\nthe variable x is a “bound variable”: it is really a placeholder,\nwhose “scope” does not extend beyond the expression t.  For\nexample, the variable b in the expression fun (b : β) (x : α) => b\n\nhas nothing to do with the constant b\n declared earlier.  In fact,\nthe expression denotes the same function as fun (u : β) (z : α) => u\n.Formally, expressions that are the same up to a renaming of bound\nvariables are called alpha equivalent, and are considered “the\nsame.” Lean recognizes this equivalence.\n\nNotice that applying a term t : α → β to a term s : α yields\nan expression t s : β\n. Returning to the previous example and\nrenaming bound variables for clarity, notice the types of the\nfollowing expressions:\n\n\n\nAs expected, the expression (fun x : Nat =>  x) 1\n has type Nat\n.\nIn fact, more should be true: applying the expression (fun x : Nat => x)\n to\n1\n should “return” the value 1\n. And, indeed, it does:\n\n\n\nYou will see later how these terms are evaluated. For now, notice that\nthis is an important feature of dependent type theory: every term has\na computational behavior, and supports a notion of normalization. In\nprinciple, two terms that reduce to the same value are called\ndefinitionally equal. They are considered “the same” by Lean's type\nchecker, and Lean does its best to recognize and support these\nidentifications.\n\nLean is a complete programming language. It has a compiler that\ngenerates a binary executable and an interactive interpreter. You can\nuse the command #eval to execute expressions, and it is the\npreferred way of testing your functions.\n\n\n\n","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","header":"2.3. Function Abstraction and Evaluation","id":"/Dependent-Type-Theory/#function-abstraction-and-evaluation"},"/Tactics/#structuring-tactic-proofs":{"contents":"Tactics often provide an efficient way of building a proof, but long\nsequences of instructions can obscure the structure of the\nargument. In this section, we describe some means that help provide\nstructure to a tactic-style proof, making such proofs more readable\nand robust.\n\nOne thing that is nice about Lean's proof-writing syntax is that it is\npossible to mix term-style and tactic-style proofs, and pass between\nthe two freely. For example, the tactics apply and exact\nexpect arbitrary terms, which you can write using have, show,\nand so on. Conversely, when writing an arbitrary Lean term, you can\nalways invoke the tactic mode by inserting a by\nblock. The following is a somewhat toy example:\n\nThe following is a more natural example:\n\n\n\nIn fact, there is a show tactic, which is similar to the\nshow expression in a proof term. It simply declares the type of the\ngoal that is about to be solved, while remaining in tactic\nmode.\n\nThe show tactic can actually be used to rewrite a goal to something definitionally equivalent:\n\n\n\nThere is also a have tactic, which introduces a new subgoal, just as when writing proof terms:\n\n\n\nAs with proof terms, you can omit the label in the have tactic, in\nwhich case, the default label this is used:\n\nThe types in a have tactic can be omitted, so you can write\nhave hp := h.left and have hqr := h.right.  In fact, with this\nnotation, you can even omit both the type and the label, in which case\nthe new fact is introduced with the label this:\n\nLean also has a let tactic, which is similar to the have\ntactic, but is used to introduce local definitions instead of\nauxiliary facts. It is the tactic analogue of a let in a proof\nterm:\n\n\n\nAs with have, you can leave the type implicit by writing\nlet a := 3 * 2. The difference between let and have is that\nlet introduces a local definition in the context, so that the\ndefinition of the local declaration can be unfolded in the proof.\n\nWe have used . to create nested tactic blocks.  In a nested block,\nLean focuses on the first goal, and generates an error if it has not\nbeen fully solved at the end of the block. This can be helpful in\nindicating the separate proofs of multiple subgoals introduced by a\ntactic. The notation . is whitespace sensitive and relies on the indentation\nto detect whether the tactic block ends. Alternatively, you can\ndefine tactic blocks using curly braces and semicolons:\n\n\n\nIt is useful to use indentation to structure proof: every time a tactic\nleaves more than one subgoal, we separate the remaining subgoals by\nenclosing them in blocks and indenting.  Thus if the application of\ntheorem foo to a single goal produces four subgoals, one would\nexpect the proof to look like this:\n\n  apply foo\n  . <proof of first goal>\n  . <proof of second goal>\n  . <proof of third goal>\n  . <proof of final goal>\n\n\nor\n\n  apply foo\n  case <tag of first goal>  => <proof of first goal>\n  case <tag of second goal> => <proof of second goal>\n  case <tag of third goal>  => <proof of third goal>\n  case <tag of final goal>  => <proof of final goal>\n\n\nor\n\n  apply foo\n  { <proof of first goal>  }\n  { <proof of second goal> }\n  { <proof of third goal>  }\n  { <proof of final goal>  }\n\n\n","context":"Theorem Proving in Lean 4\u0009Tactics","header":"5.4. Structuring Tactic Proofs","id":"/Tactics/#structuring-tactic-proofs"},"/The-Conversion-Tactic-Mode/#structuring-conversion-tactics":{"contents":"Curly brackets and . can also be used in conv mode to structure tactics:\n\n\n\n","context":"Theorem Proving in Lean 4\u0009The Conversion Tactic Mode","header":"11.3. Structuring conversion tactics","id":"/The-Conversion-Tactic-Mode/#structuring-conversion-tactics"}});