window.docContents[147].resolve({"/Inductive-Types/#constructors-with-arguments":{"contents":"Enumerated types are a very special case of inductive types, in which\nthe constructors take no arguments at all. In general, a\n“construction” can depend on data, which is then represented in the\nconstructed argument. Consider the definitions of the product type and\nsum type in the library:Consider what is going on in these examples.\nThe product type has one constructor, Prod.mk\n,\nwhich takes two arguments. To define a function on Prod α β, we\ncan assume the input is of the form Prod.mk a b\n, and we have to\nspecify the output, in terms of a and b. We can use this to\ndefine the two projections for Prod. Remember that the standard\nlibrary defines notation α × β\n for Prod α β and (a, b)\n for\nProd.mk a b\n.The function fst takes a pair, p. The match interprets\np as a pair, Prod.mk a b. Recall also from Dependent Type Theory\nthat to give these definitions the greatest generality possible, we allow\nthe types α and β to belong to any universe.\n\nHere is another example where we use the recursor Prod.casesOn\n instead\nof match.The argument motive is used to specify the type of the object you want to\nconstruct, and it is a function because it may depend on the pair.\nThe cond function is a boolean conditional: cond b t1 t2\n\nreturns t1\n if b\n is true, and t2\n otherwise.\nThe function prod_example takes a pair consisting of a boolean,\nb, and a number, n, and returns either 2 * n or 2 * n + 1\naccording to whether b is true or false.\n\nIn contrast, the sum type has two constructors, inl\n and inr\n\n(for “insert left” and “insert right”), each of which takes one\n(explicit) argument. To define a function on Sum α β\n, we have to\nhandle two cases: either the input is of the form inl a\n, in which\ncase we have to specify an output value in terms of a, or the\ninput is of the form inr b\n, in which case we have to specify an\noutput value in terms of b.\n\nThis example is similar to the previous one, but now an input to\nsum_example is implicitly either of the form inl n\n or inr n\n.\nIn the first case, the function returns 2 * n\n, and the second\ncase, it returns 2 * n + 1\n.\n\nNotice that the product type depends on parameters α β : Type\nwhich are arguments to the constructors as well as Prod\n. Lean\ndetects when these arguments can be inferred from later arguments to a\nconstructor or the return type, and makes them implicit in that case.In Defining the Natural Numbers\nwe will see what happens when the\nconstructor of an inductive type takes arguments from the inductive\ntype itself. What characterizes the examples we consider in this\nsection is that each constructor relies only on previously specified types.Notice that a type with multiple constructors is disjunctive: an\nelement of Sum α β\n is either of the form inl a\n or of the\nform inl b\n. A constructor with multiple arguments introduces\nconjunctive information: from an element Prod.mk a b\n of\nProd α β\n we can extract a and b. An arbitrary inductive type can\ninclude both features, by having any number of constructors, each of\nwhich takes any number of arguments.\n\nAs with function definitions, Lean's inductive definition syntax will\nlet you put named arguments to the constructors before the colon:\n\n\n\nThe results of these definitions are essentially the same as the ones given earlier in this section.\n\nA type, like Prod, that has only one constructor is purely\nconjunctive: the constructor simply packs the list of arguments into a\nsingle piece of data, essentially a tuple where the type of subsequent\narguments can depend on the type of the initial argument. We can also\nthink of such a type as a “record” or a “structure”. In Lean, the\nkeyword structure can be used to define such an inductive type as\nwell as its projections, at the same time.\n\n\n\nThis example simultaneously introduces the inductive type, Prod,\nits constructor, mk, the usual eliminators (rec and\nrecOn), as well as the projections, fst and snd, as\ndefined above.\n\nIf you do not name the constructor, Lean uses mk as a default. For\nexample, the following defines a record to store a color as a triple\nof RGB values:\n\n\n\nThe definition of yellow forms the record with the three values\nshown, and the projection Color.red returns the red component.\n\nThe structure command is especially useful for defining algebraic\nstructures, and Lean provides substantial infrastructure to support\nworking with them. Here, for example, is the definition of a\nsemigroup:\n\n\n\nWe will see more examples in the chapter on structures and records.\n\nWe have already discussed the dependent product type Sigma:\n\nTwo more examples of inductive types in the library are the following:\n\n\n\nIn the semantics of dependent type theory, there is no built-in notion\nof a partial function. Every element of a function type α → β\n or a\ndependent function type (a : α) → β\n is assumed to have a value\nat every input. The Option\n type provides a way of representing partial functions. An\nelement of Option β\n is either none\n or of the form some b\n,\nfor some value b : β. Thus we can think of an element f\n of the\ntype α → Option β\n as being a partial function from α\n to β\n:\nfor every a : α, f a\n either returns none\n, indicating\nf a\n is “undefined”, or some b\n.An element of Inhabited α\n is simply a witness to the fact that\nthere is an element of α\n. Later, we will see that Inhabited\n is\nan example of a type class in Lean: Lean can be instructed that\nsuitable base types are inhabited, and can automatically infer that\nother constructed types are inhabited on that basis.As exercises, we encourage you to develop a notion of composition for\npartial functions from α\n to β\n and β\n to γ\n, and show\nthat it behaves as expected. We also encourage you to show that\nBool\n and Nat\n are inhabited, that the product of two inhabited\ntypes is inhabited, and that the type of functions to an inhabited\ntype is inhabited.\n\n","context":"Theorem Proving in Lean 4\u0009Inductive Types","header":"7.2. Constructors with Arguments","id":"/Inductive-Types/#constructors-with-arguments"},"/Quantifiers-and-Equality/#the-universal-quantifier":{"contents":"Notice that if α\n is any type, we can represent a unary predicate\np\n on α\n as an object of type α → Prop\n. In that case, given\nx : α, p x\n denotes the assertion that p\n holds of\nx\n. Similarly, an object r : α → α → Prop denotes a binary\nrelation on α\n: given x y : α, r x y\n denotes the assertion\nthat x\n is related to y\n.\n\nThe universal quantifier, ∀ x : α, p x\n is supposed to denote the\nassertion that “for every x : α, p x\n” holds. As with the\npropositional connectives, in systems of natural deduction, “forall”\nis governed by an introduction and elimination rule. Informally, the\nintroduction rule states:\n\nGiven a proof of p x\n, in a context where x : α is arbitrary, we obtain a proof ∀ x : α, p x\n.\n\nThe elimination rule states:\n\nGiven a proof ∀ x : α, p x\n and any term t : α, we obtain a proof of p t\n.\n\nAs was the case for implication, the propositions-as-types\ninterpretation now comes into play. Remember the introduction and\nelimination rules for dependent arrow types:\n\n\n\nGiven a term t\n of type β x\n, in a context where x : α is arbitrary, we have (fun x : α => t) : (x : α) → β x\n.\n\n\n\nThe elimination rule states:\n\nGiven a term s : (x : α) → β x and any term t : α, we have s t : β t\n.\n\nIn the case where p x\n has type Prop\n, if we replace\n(x : α) → β x\n with ∀ x : α, p x\n, we can read these as the correct rules\nfor building proofs involving the universal quantifier.\n\nThe Calculus of Constructions therefore identifies dependent arrow\ntypes with forall-expressions in this way. If p\n is any expression,\n∀ x : α, p\n is nothing more than alternative notation for\n(x : α) → p\n, with the idea that the former is more natural than the latter\nin cases where p\n is a proposition. Typically, the expression p\n\nwill depend on x : α. Recall that, in the case of ordinary\nfunction spaces, we could interpret α → β\n as the special case of\n(x : α) → β\n in which β\n does not depend on x. Similarly, we\ncan think of an implication p → q\n between propositions as the\nspecial case of ∀ x : p, q\n in which the expression q\n does not\ndepend on x.\n\nHere is an example of how the propositions-as-types correspondence gets put into practice.\n\n\n\nAs a notational convention, we give the universal quantifier the\nwidest scope possible, so parentheses are needed to limit the\nquantifier over x to the hypothesis in the example above. The\ncanonical way to prove ∀ y : α, p y\n is to take an arbitrary y,\nand prove p y. This is the introduction rule. Now, given that\nh has type ∀ x : α, p x ∧ q x, the expression h y has type\np y ∧ q y. This is the elimination rule. Taking the left conjunct\ngives the desired conclusion, p y.\n\nRemember that expressions which differ up to renaming of bound\nvariables are considered to be equivalent. So, for example, we could\nhave used the same variable, x\n, in both the hypothesis and\nconclusion, and instantiated it by a different variable, z\n, in the\nproof:\n\n\n\nAs another example, here is how we can express the fact that a relation, r\n, is transitive:\n\n\n\nThink about what is going on here. When we instantiate trans_r at\nthe values a b c, we end up with a proof of r a b → r b c → r a c.\nApplying this to the “hypothesis” hab : r a b, we get a proof\nof the implication r b c → r a c. Finally, applying it to the\nhypothesis hbc yields a proof of the conclusion r a c.\n\nIn situations like this, it can be tedious to supply the arguments\na b c, when they can be inferred from hab hbc. For that reason, it\nis common to make these arguments implicit:\n\n\n\nThe advantage is that we can simply write trans_r hab hbc as a\nproof of r a c. A disadvantage is that Lean does not have enough\ninformation to infer the types of the arguments in the expressions\ntrans_r and trans_r hab. The output of the first #check\ncommand is r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3, indicating\nthat the implicit arguments are unspecified in this case.\n\nHere is an example of how we can carry out elementary reasoning with an equivalence relation:\n\n\n\nTo get used to using universal quantifiers, you should try some of the\nexercises at the end of this section.\n\nIt is the typing rule for dependent arrow types, and the universal\nquantifier in particular, that distinguishes Prop\n from other\ntypes.  Suppose we have α : Sort i and β : Sort j, where the\nexpression β\n may depend on a variable x : α. Then\n(x : α) → β\n is an element of Sort (imax i j)\n, where imax i j is the\nmaximum of i and j if j is not 0, and 0 otherwise.The idea is as follows. If j is not 0, then (x : α) → β\n is\nan element of Sort (max i j)\n. In other words, the type of\ndependent functions from α\n to β\n “lives” in the universe whose\nindex is the maximum of i and j. Suppose, however, that β\n\nis of Sort 0\n, that is, an element of Prop\n. In that case,\n(x : α) → β\n is an element of Sort 0\n as well, no matter which\ntype universe α\n lives in. In other words, if β\n is a\nproposition depending on α\n, then ∀ x : α, β\n is again a\nproposition. This reflects the interpretation of Prop\n as the type\nof propositions rather than data, and it is what makes Prop\n\nimpredicative.The term “predicative” stems from foundational developments around the\nturn of the twentieth century, when logicians such as Poincaré and\nRussell blamed set-theoretic paradoxes on the “vicious circles” that\narise when we define a property by quantifying over a collection that\nincludes the very property being defined. Notice that if α\n is any\ntype, we can form the type α → Prop\n of all predicates on α\n\n(the “power type of α\n”). The impredicativity of Prop\n means that we\ncan form propositions that quantify over α → Prop\n. In particular,\nwe can define predicates on α\n by quantifying over all predicates\non α\n, which is exactly the type of circularity that was once\nconsidered problematic.\n\n","context":"Theorem Proving in Lean 4\u0009Quantifiers and Equality","header":"4.1. The Universal Quantifier","id":"/Quantifiers-and-Equality/#the-universal-quantifier"}});