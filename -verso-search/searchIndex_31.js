window.docContents[31].resolve({"/Tactics/#entering-tactic-mode":{"id":"/Tactics/#entering-tactic-mode","header":"5.1. Entering Tactic Mode","context":"Theorem Proving in Lean 4\u0009Tactics","contents":"Conceptually, stating a theorem or introducing a have statement\ncreates a goal, namely, the goal of constructing a term with the\nexpected type. For example, the following creates the goal of\nconstructing a term of type p ∧ q ∧ p, in a context with constants\np q : Prop, hp : p and hq : q:\n\nYou can write this goal as follows:\n\n\n\nIndeed, if you replace the “sorry” by an underscore in the example\nabove, Lean will report that it is exactly this goal that has been\nleft unsolved.\n\nOrdinarily, you meet such a goal by writing an explicit term. But\nwherever a term is expected, Lean allows us to insert instead a\nby <tactics> block, where <tactics> is a sequence of commands,\nseparated by semicolons or line breaks. You can prove the theorem above\nin that way:\n\n\n\nWe often put the by keyword on the preceding line, and write the\nexample above as:\n\n\n\nThe apply tactic applies an expression, viewed as denoting a\nfunction with zero or more arguments. It unifies the conclusion with\nthe expression in the current goal, and creates new goals for the\nremaining arguments, provided that no later arguments depend on\nthem. In the example above, the command apply And.intro yields two\nsubgoals:\n\n\n\nThe first goal is met with the command exact hp. The exact\ncommand is just a variant of apply which signals that the\nexpression given should fill the goal exactly. It is good form to use\nit in a tactic proof, since its failure signals that something has\ngone wrong. It is also more robust than apply, since the\nelaborator takes the expected type, given by the target of the goal,\ninto account when processing the expression that is being applied. In\nthis case, however, apply would work just as well.\n\nYou can see the resulting proof term with the #print command:\n\n\n\n\n\nYou can write a tactic script incrementally. In VS Code, you can open\na window to display messages by pressing , and\nthat window will then show you the current goal whenever the cursor is\nin a tactic block. If the proof is incomplete, the token by is\ndecorated with a red squiggly line, and the error message contains the\nremaining goals.\n\nTactic commands can take compound expressions, not just single\nidentifiers. The following is a shorter version of the preceding\nproof:\n\n\n\nUnsurprisingly, it produces exactly the same proof term:\n\n\n\nMultiple tactic applications can be written in a single line by concatenating with a semicolon.\n\n\n\nTactics that may produce multiple subgoals often tag them. For\nexample, the tactic apply And.intro tagged the first subgoal as\n, and the second as . In the case of the apply\ntactic, the tags are inferred from the parameters' names used in the\nAnd.intro declaration. You can structure your tactics using the\nnotation case <tag> => <tactics>. The following is a structured\nversion of our first tactic proof in this chapter.\n\n\n\nYou can solve the subgoal  before  using the case\nnotation:\n\nNote that Lean hides the other goals inside the case block. After case left =>,\nthe proof state is:\n\n\n\nWe say that case is “focusing” on the selected goal.  Moreover, Lean flags an error\nif the selected goal is not fully solved at the end of the case\nblock.\n\nFor simple subgoals, it may not be worth selecting a subgoal using its\ntag, but you may still want to structure the proof. Lean also provides\nthe “bullet” notation . <tactics> (or · <tactics>) for\nstructuring proofs:\n\n\n\n"}});