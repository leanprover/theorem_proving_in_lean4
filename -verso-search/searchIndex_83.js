window.docContents[83].resolve({"/Propositions-and-Proofs/#working-with-propositions-as-types":{"contents":"In the propositions-as-types paradigm, theorems involving only →\ncan be proved using lambda abstraction and application. In Lean, the\ntheorem command introduces a new theorem:\n\n\n\nCompare this proof to the expression fun x : α => fun y : β => x\n\nof type α → β → α\n, where α\n and β\n are data types.\nThis describes the function that takes arguments x and y\nof type α\n and β\n, respectively, and returns x.\nThe proof of t1\n has the same form, the only difference being that\np\n and q\n are elements of Prop\n rather than Type\n.\nIntuitively, our proof of\np → q → p\n assumes p\n and q\n are true, and uses the first\nhypothesis (trivially) to establish that the conclusion, p\n, is\ntrue.\n\nNote that the theorem command is really a version of the\ndef command: under the propositions and types\ncorrespondence, proving the theorem p → q → p\n is really the same\nas defining an element of the associated type. To the kernel type\nchecker, there is no difference between the two.\n\nThere are a few pragmatic differences between definitions and\ntheorems, however. In normal circumstances, it is never necessary to\nunfold the “definition” of a theorem; by proof irrelevance, any two\nproofs of that theorem are definitionally equal. Once the proof of a\ntheorem is complete, typically we only need to know that the proof\nexists; it doesn't matter what the proof is. In light of that fact,\nLean tags proofs as irreducible, which serves as a hint to the\nparser (more precisely, the elaborator) that there is generally no\nneed to unfold them when processing a file. In fact, Lean is generally\nable to process and check proofs in parallel, since assessing the\ncorrectness of one proof does not require knowing the details of\nanother. Additionally, section variables\nthat are referred to in the body of a definition are automatically added as\nparameters, but only the variables referred to in a theorem's type are added.\nThis is because the way in which a statement is proved should not influence\nthe statement that is being proved.\n\nAs with definitions, the #print command will show you the proof of\na theorem:\n\n\n\nNotice that the lambda abstractions hp : p and hq : q can be\nviewed as temporary assumptions in the proof of t1\n.  Lean also\nallows us to specify the type of the final term hp, explicitly,\nwith a show statement:\n\n\n\nAdding such extra information can improve the clarity of a proof and\nhelp detect errors when writing a proof. The show command does\nnothing more than annotate the type, and, internally, all the\npresentations of t1 that we have seen produce the same term.\n\nAs with ordinary definitions, we can move the lambda-abstracted\nvariables to the left of the colon:\n\n\n\nWe can use the theorem t1 just as a function application:\n\n\n\nThe axiom declaration postulates the existence of an\nelement of the given type and may compromise logical consistency. For\nexample, we can use it to postulate that the empty type False\n has an\nelement:\n\n\n\nDeclaring an “axiom” hp : p is tantamount to declaring that p\n\nis true, as witnessed by hp\n. Applying the theorem\nt1 : p → q → p to the fact hp : p that p\n is true yields the theorem\nt1 hp : q → p\n.\n\nRecall that we can also write theorem t1 as follows:\n\n\n\nThe type of t1 is now ∀ {p q : Prop}, p → q → p\n. We can read\nthis as the assertion “for every pair of propositions p\n q\n, we have\np → q → p\n.” For example, we can move all parameters to the right\nof the colon:\n\n\n\nIf p\n and q\n have been declared as variables, Lean will\ngeneralize them for us automatically:\n\n\n\nWhen we generalize t1 in such a way, we can then apply it to\ndifferent pairs of propositions, to obtain different instances of the\ngeneral theorem.\n\n\n\nOnce again, using the propositions-as-types correspondence, the\nvariable h of type r → s can be viewed as the hypothesis, or\npremise, that r → s holds.\n\nAs another example, let us consider the composition function discussed\nin the last chapter, now with propositions instead of types.\n\n\n\nAs a theorem of propositional logic, what does t2 say?\n\nNote that it is often useful to use numeric Unicode subscripts,\nentered as , , , ..., for hypotheses, as we did in\nthis example.\n\n","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs","header":"3.2. Working with Propositions as Types","id":"/Propositions-and-Proofs/#working-with-propositions-as-types"}});