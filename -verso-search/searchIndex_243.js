window.docContents[243].resolve({"/The-Conversion-Tactic-Mode/#basic-navigation-and-rewriting":{"id":"/The-Conversion-Tactic-Mode/#basic-navigation-and-rewriting","header":"11.1. Basic navigation and rewriting","context":"Theorem Proving in Lean 4\u0009The Conversion Tactic Mode","contents":"As a first example, let us prove example\n(a b c : Nat) : a * (b * c) = a * (c * b)\n(examples in this file are somewhat artificial since\nother tactics could finish them immediately). The naive\nfirst attempt is to enter tactic mode and try rw [Nat.mul_comm]. But this\ntransforms the goal into b * c * a = a * (c * b), after commuting the\nvery first multiplication appearing in the term. There are several\nways to fix this issue, and one way is to use a more precise tool:\nthe conversion mode. The following code block shows the current target\nafter each line.\n\nThe above snippet shows three navigation commands:\n\n* lhs navigates to the left-hand side of a relation (equality, in this case).\n   There is also a rhs to navigate to the right-hand side.* congr creates as many targets as there are (nondependent and explicit) arguments to the current head function\n  (here the head function is multiplication).* rfl closes target using reflexivity.\n\nOnce arrived at the relevant target, we can use rw as in normal\ntactic mode.\n\nThe second main reason to use conversion mode is to rewrite under\nbinders. Suppose we want to prove example\n(fun x : Nat => 0 + x) = (fun x => x).\nThe naive first attempt is to enter tactic mode and try\nrw [Nat.zero_add]. But this fails with a frustratingerror: tactic 'rewrite' failed, did not find instance of the pattern\n       in the target expression\n  0 + ?n\nâŠ¢ (fun x => 0 + x) = fun x => x\nThe solution is:\n\nwhere intro x is the navigation command entering inside the fun binder.\nNote that this example is somewhat artificial, one could also do:\n\n\n\nor just\n\n\n\nconv can also rewrite a hypothesis h from the local context, using conv at h.\n\n"}});