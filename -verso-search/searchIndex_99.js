window.docContents[99].resolve({"/Dependent-Type-Theory/#local-definitions":{"contents":"Lean also allows you to introduce “local” definitions using the\nlet keyword. The expression let a := t1; t2\n is\ndefinitionally equal to the result of replacing every occurrence of\na in t2 by t1.\n\n\n\nHere, twice_double x\n is definitionally equal to the term (x + x) * (x + x)\n.\n\nYou can combine multiple assignments by chaining let statements:\n\n\n\nThe ; can be omitted when a line break is used.\n\n\n\nNotice that the meaning of the expression let a := t1; t2\n is very\nsimilar to the meaning of (fun a => t2) t1\n, but the two are not\nthe same. In the first expression, you should think of every instance\nof a in t2 as a syntactic abbreviation for t1. In the\nsecond expression, a is a variable, and the expression\nfun a => t2 has to make sense independently of the value of a.\nThe let construct is a stronger means of abbreviation, and there\nare expressions of the form let a := t1; t2\n that cannot be\nexpressed as (fun a => t2) t1\n. As an exercise, try to understand\nwhy the definition of foo below type checks, but the definition of\nbar does not.\n\n","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","header":"2.5. Local Definitions","id":"/Dependent-Type-Theory/#local-definitions"}});