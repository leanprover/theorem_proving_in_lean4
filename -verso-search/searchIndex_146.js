window.docContents[146].resolve({"/Tactics/#tactic-combinators":{"id":"/Tactics/#tactic-combinators","header":"5.5. Tactic Combinators","context":"Theorem Proving in Lean 4\u0009Tactics","contents":"Tactic combinators are operations that form new tactics from old\nones. A sequencing combinator is already implicit in the by block:\n\n\n\nHere, apply Or.inl; assumption is functionally equivalent to a\nsingle tactic which first applies apply Or.inl and then applies\nassumption.\n\nIn t₁ <;> t₂, the <;> operator provides a parallel version of the sequencing operation:\nt₁ is applied to the current goal, and then t₂ is applied to all the resulting subgoals:\n\n\n\nThis is especially useful when the resulting goals can be finished off\nin a uniform way, or, at least, when it is possible to make progress\non all of them uniformly.\n\nThe first | t₁ | t₂ | ... | tₙ applies each tᵢ until one succeeds, or else fails:\n\n\n\nIn the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.\nIn the next three examples, the same compound tactic succeeds in each case:\n\n\n\nThe tactic tries to solve the left disjunct immediately by assumption;\nif that fails, it tries to focus on the right disjunct; and if that\ndoesn't work, it invokes the assumption tactic.\n\nYou will have no doubt noticed by now that tactics can fail. Indeed,\nit is the “failure” state that causes the first combinator to\nbacktrack and try the next tactic. The try combinator builds a\ntactic that always succeeds, though possibly in a trivial way:\ntry t executes t and reports success, even if t fails. It is\nequivalent to first| t |skip, where skip is a tactic that does\nnothing (and succeeds in doing so). In the next example, the second\nconstructor succeeds on the right conjunct q ∧ r (remember that\ndisjunction and conjunction associate to the right) but fails on the\nfirst. The try tactic ensures that the sequential composition\nsucceeds:\n\nBe careful: repeat (try t) will loop forever, because the inner tactic never fails.\n\nIn a proof, there are often multiple goals outstanding. Parallel\nsequencing is one way to arrange it so that a single tactic is applied\nto multiple goals, but there are other ways to do this. For example,\nall_goals t applies t to all open goals:\n\n\n\nIn this case, the any_goals tactic provides a more robust solution.\nIt is similar to all_goals, except it succeeds if its argument\nsucceeds on at least one goal:\n\n\n\nThe first tactic in the by block below repeatedly splits\nconjunctions:\n\n\n\nIn fact, we can compress the full tactic down to one line:\n\n\n\nThe combinator focus t ensures that t only effects the current\ngoal, temporarily hiding the others from the scope. So, if t\nordinarily only effects the current goal, focus (all_goals t) has\nthe same effect as t.\n\n"}});