window.docContents[250].resolve({"/Inductive-Types/#enumerated-types":{"id":"/Inductive-Types/#enumerated-types","header":"7.1. Enumerated Types","context":"Theorem Proving in Lean 4\u0009Inductive Types","contents":"The simplest kind of inductive type is a type with a finite, enumerated list of elements.\n\n\n\nThe inductive command creates a new type, Weekday. The\nconstructors all live in the Weekday namespace.\n\n\n\nYou can omit : Weekday when declaring the Weekday inductive type.\n\n\n\nThink of sunday, monday, ... , saturday as\nbeing distinct elements of Weekday, with no other distinguishing\nproperties. The elimination principle, Weekday.rec, is defined\nalong with the type Weekday and its constructors. It is also known\nas a recursor, and it is what makes the type “inductive”: it allows\nus to define a function on Weekday by assigning values\ncorresponding to each constructor. The intuition is that an inductive\ntype is exhaustively generated by the constructors, and has no\nelements beyond those they construct.\n\nWe will use the match expression to define a function from Weekday\nto the natural numbers:When using Lean's logic, the match expression is compiled using the recursor Weekday.rec generated when\nyou declare the inductive type. This ensures that the resulting term is well-defined in the type theory. For compiled code,\nmatch is compiled as in other functional programming languages.\n\n\n\nWhen declaring an inductive datatype, you can use deriving Repr to instruct\nLean to generate a function that converts Weekday objects into text.\nThis function is used by the #eval command to display Weekday objects.\nIf no Repr\n exists, #eval attempts to derive one on the spot.\n\nIt is often useful to group definitions and theorems related to a\nstructure in a namespace with the same name. For example, we can put\nthe numberOfDay function in the Weekday namespace. We are\nthen allowed to use the shorter name when we open the namespace.\n\nWe can define functions from Weekday to Weekday:\n\nHow can we prove the general theorem that next (previous d) = d\nfor any Weekday d? You can use match to provide a proof of the claim for each\nconstructor:\n\nUsing a tactic proof, we can be even more concise:\n\n\n\nTactics for Inductive Types below will introduce additional\ntactics that are specifically designed to make use of inductive types.\n\nNotice that, under the propositions-as-types correspondence, we can\nuse match to prove theorems as well as define functions.  In other\nwords, under the propositions-as-types correspondence, the proof by\ncases is a kind of definition by cases, where what is being “defined”\nis a proof instead of a piece of data.\n\nThe Bool\n type in the Lean library is an instance of\nenumerated type.\n\n\n\n(To run these examples, we put them in a namespace called Hidden,\nso that a name like Bool does not conflict with the Bool\n in\nthe standard library. This is necessary because these types are part\nof the Lean “prelude” that is automatically imported when the system\nis started.)\n\nAs an exercise, you should think about what the introduction and\nelimination rules for these types do. As a further exercise, we\nsuggest defining boolean operations and\n, or\n, not\n on the\nBool type, and verifying common identities. Note that you can define a\nbinary operation like and using match:\n\n\n\nSimilarly, most identities can be proved by introducing suitable match, and then using rfl\n.\n\n"}});