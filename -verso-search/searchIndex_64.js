window.docContents[64].resolve({"/Inductive-Types/#axiomatic-details":{"contents":"We have described inductive types and their syntax through\nexamples. This section provides additional information for those\ninterested in the axiomatic foundations.\n\nWe have seen that the constructor to an inductive type takes\nparameters—intuitively, the arguments that remain fixed\nthroughout the inductive construction—and indices, the arguments\nparameterizing the family of types that is simultaneously under\nconstruction. Each constructor should have a type, where the\nargument types are built up from previously defined types, the\nparameter and index types, and the inductive family currently being\ndefined. The requirement is that if the latter is present at all, it\noccurs only strictly positively. This means simply that any argument\nto the constructor in which it occurs is a dependent arrow type in which the\ninductive type under definition occurs only as the resulting type,\nwhere the indices are given in terms of constants and previous\narguments.\n\nSince an inductive type lives in Sort u for some u, it is\nreasonable to ask which universe levels u can be instantiated\nto. Each constructor c in the definition of a family C of\ninductive types is of the form\n\n  c : (a : α) → (b : β[a]) → C a p[a,b]\n\n\nwhere a is a sequence of data type parameters, b is the\nsequence of arguments to the constructors, and p[a, b] are the\nindices, which determine which element of the inductive family the\nconstruction inhabits. (Note that this description is somewhat\nmisleading, in that the arguments to the constructor can appear in any\norder as long as the dependencies make sense.) The constraints on the\nuniverse level of C fall into two cases, depending on whether or\nnot the inductive type is specified to land in Prop\n (that is,\nSort 0\n).\n\nLet us first consider the case where the inductive type is not\nspecified to land in Prop\n. Then the universe level u is\nconstrained to satisfy the following:\n\nFor each constructor c as above, and each βk[a] in the sequence β[a], if βk[a] : Sort v, we have u ≥ v.\n\nIn other words, the universe level u is required to be at least as\nlarge as the universe level of each type that represents an argument\nto a constructor.\n\nWhen the inductive type is specified to land in Prop\n, there are no\nconstraints on the universe levels of the constructor arguments. But\nthese universe levels do have a bearing on the elimination\nrule. Generally speaking, for an inductive type in Prop\n, the\nmotive of the elimination rule is required to be in Prop\n.\n\nThere is an exception to this last rule: we are allowed to eliminate\nfrom an inductively defined Prop\n to an arbitrary Sort when\nthere is only one constructor and each constructor argument is either\nin Prop\n or an index. The intuition is that in this case the\nelimination does not make use of any information that is not already\ngiven by the mere fact that the type of argument is inhabited. This\nspecial case is known as singleton elimination.\n\nWe have already seen singleton elimination at play in applications of\nEq.rec, the eliminator for the inductively defined equality\ntype. We can use an element h : Eq a b to cast an element\nh₂ : p a to p b even when p a and p b are arbitrary types,\nbecause the cast does not produce new data; it only reinterprets the\ndata we already have. Singleton elimination is also used with\nheterogeneous equality and well-founded recursion, which will be\ndiscussed in a the chapter on induction and recursion.\n\n","context":"Theorem Proving in Lean 4\u0009Inductive Types","header":"7.8. Axiomatic Details","id":"/Inductive-Types/#axiomatic-details"},"/Type-Classes/#coercions-using-type-classes":{"contents":"The most basic type of coercion maps elements of one type to another. For example, a coercion from Nat\n to Int\n allows us to view any element n : Nat as an element of Int\n. But some coercions depend on parameters; for example, for any type α\n, we can view any element as : List α as an element of Set α\n, namely, the set of elements occurring in the list. The corresponding coercion is defined on the “family” of types List α\n, parameterized by α\n.\n\nLean allows us to declare three kinds of coercions:\n\n* from a family of types to another family of types* from a family of types to the class of sorts* from a family of types to the class of function types\n\nThe first kind of coercion allows us to view any element of a member of the source family as an element of a corresponding member of the target family. The second kind of coercion allows us to view any element of a member of the source family as a type. The third kind of coercion allows us to view any element of the source family as a function. Let us consider each of these in turn.\n\nIn Lean, coercions are implemented on top of the type class resolution framework. We define a coercion from α\n to β\n by declaring an instance of Coe α β\n. For example, we can define a coercion from Bool\n to Prop\n as follows:\n\nThis enables us to use boolean terms in if-then-else expressions:\n\n\n\nWe can define a coercion from List α to Set α as follows:\n\nWe can use the notation ↑ to force a coercion to be introduced in a particular place. It is also helpful to make our intent clear, and work around limitations of the coercion resolution system.\n\n\n\nLean also supports dependent coercions using the type class CoeDep\n. For example, we cannot coerce arbitrary propositions to Bool\n, only the ones that implement the Decidable\n typeclass.\n\n\n\nLean will also chain (non-dependent) coercions as necessary. Actually, the type class CoeT\n is the transitive closure of Coe\n.\n\nLet us now consider the second kind of coercion. By the class of sorts, we mean the collection of universes Type u\n. A coercion of the second kind is of the form:\n\n    c : (x1 : A1) → ... → (xn : An) → F x1 ... xn → Type u\n\n\nwhere F is a family of types as above. This allows us to write s : t whenever t is of type F a₁ ... aₙ. In other words, the coercion allows us to view the elements of F a₁ ... aₙ as types. This is very useful when defining algebraic structures in which one component, the carrier of the structure, is a Type\n. For example, we can define a semigroup as follows:\n\n\n\nIn other words, a semigroup consists of a type, carrier, and a multiplication, mul, with the property that the multiplication is associative. The instance command allows us to write a * b\n instead of Semigroup.mul S a b\n whenever we have a b : S.carrier; notice that Lean can infer the argument S from the types of a and b. The function Semigroup.carrier\n maps the class Semigroup to the sort Type u:If we declare this function to be a coercion, then whenever we have a semigroup S : Semigroup, we can write a : S instead of a : S.carrier:It is the coercion that makes it possible to write (a b c : S). Note that, we define an instance of CoeSort Semigroup (Type u) instead of Coe Semigroup (Type u)\n.\n\nBy the class of function types, we mean the collection of Pi types (z : B) → C\n. The third kind of coercion has the form:    c : (x₁ : A₁) → ... → (xₙ : Aₙ) → (y : F x₁ ... xₙ) → (z : B) → C\nwhere F is again a family of types and B and C can depend on x₁, ..., xₙ, y. This makes it possible to write t s whenever t is an element of F a₁ ... aₙ. In other words, the coercion enables us to view elements of F a₁ ... aₙ as functions. Continuing the example above, we can define the notion of a morphism between semigroups S1 and S2. That is, a function from the carrier of S1 to the carrier of S2 (note the implicit coercion) that respects the multiplication. The projection Morphism.mor takes a morphism to the underlying function:As a result, it is a prime candidate for the third type of coercion.\n\n\n\nWith the coercion in place, we can write f (a * a * a) instead of f.mor (a * a * a). When the Morphism, f, is used where a function is expected, Lean inserts the coercion. Similar to CoeSort\n, we have yet another class CoeFun\n for this class of coercions. The parameter γ is used to specify the function type we are coercing to. This type may depend on the type we are coercing from.\n\n\n","context":"Theorem Proving in Lean 4\u0009Type Classes","header":"10.10. Coercions using Type Classes","id":"/Type-Classes/#coercions-using-type-classes"}});