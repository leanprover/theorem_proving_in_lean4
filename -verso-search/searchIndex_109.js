window.docContents[109].resolve({"/Inductive-Types/#defining-the-natural-numbers":{"id":"/Inductive-Types/#defining-the-natural-numbers","header":"7.4. Defining the Natural Numbers","context":"Theorem Proving in Lean 4\u0009Inductive Types","contents":"The inductively defined types we have seen so far are “flat”:\nconstructors wrap data and insert it into a type, and the\ncorresponding recursor unpacks the data and acts on it. Things get\nmuch more interesting when the constructors act on elements of the\nvery type being defined. A canonical example is the type Nat\n of\nnatural numbers:\n\n\n\nThere are two constructors. We start with zero : Nat; it takes\nno arguments, so we have it from the start. In contrast, the\nconstructor succ\n can only be applied to a previously constructed\nNat\n. Applying it to zero\n yields succ zero : Nat\n. Applying\nit again yields succ (succ zero) : Nat\n, and so on. Intuitively,\nNat\n is the “smallest” type with these constructors, meaning that\nit is exhaustively (and freely) generated by starting with zero\n\nand applying succ\n repeatedly.As before, the recursor for Nat\n is designed to define a dependent\nfunction f\n from Nat\n to any domain, that is, an element f\n\nof (n : Nat) → motive n\n for some motive : Nat → Sort u.\nIt has to handle two cases: the case where the input is zero\n, and the case where\nthe input is of the form succ n\n for some n : Nat. In the first\ncase, we simply specify a target value with the appropriate type, as\nbefore. In the second case, however, the recursor can assume that a\nvalue of f\n at n\n has already been computed. As a result, the\nnext argument to the recursor specifies a value for f (succ n)\n in\nterms of n\n and f n\n. If we check the type of the recursor,\nyou find the following:\n\n\n\nThe implicit argument, motive, is the codomain of the function being defined.\nIn type theory it is common to say motive is the motive for the elimination/recursion,\nsince it describes the kind of object we wish to construct.\nThe next two arguments specify how to compute the zero and successor cases, as described above.\nThey are also known as the minor premises.\nFinally, the t : Nat, is the input to the function. It is also known as the major premise.\n\nThe Nat.recOn is similar to Nat.rec but the major premise occurs before the minor premises.\n\n\n\nConsider, for example, the addition function add m n\n on the\nnatural numbers. Fixing m\n, we can define addition by recursion on\nn\n. In the base case, we set add m zero\n to m\n. In the\nsuccessor step, assuming the value add m n\n is already determined,\nwe define add m (succ n)\n to be succ (add m n)\n.\n\n\n\nIt is useful to put such definitions into a namespace, Nat\n. We can\nthen go on to define familiar notation in that namespace. The two\ndefining equations for addition now hold definitionally:\n\n\n\nWe will explain how the instance command works in\nthe Type Classes chapter. In the examples below, we will use\nLean's version of the natural numbers.\n\nProving a fact like 0 + n = n\n, however, requires a proof by induction.\nAs observed above, the induction principle is just a special case of the recursion principle,\nwhen the codomain motive n\n is an element of Prop\n. It represents the familiar\npattern of an inductive proof: to prove ∀ n, motive n\n, first prove motive 0\n,\nand then, for arbitrary n\n, assume ih : motive n and prove motive (n + 1)\n.\n\nNotice that, once again, when Nat.recOn is used in the context of\na proof, it is really the induction principle in disguise. The\nrw and simp tactics tend to be very effective in proofs\nlike these. In this case, each can be used to reduce the proof to:\n\n\n\nAs another example, let us prove the associativity of addition,\n∀ m n k, m + n + k = m + (n + k)\n.\n(The notation +, as we have defined it, associates to the left, so m + n + k is really (m + n) + k\n.)\nThe hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument,\nk is a good guess, and once we make that choice the proof almost writes itself:\n\n\n\nOnce again, you can reduce the proof to:\n\n\n\nSuppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:\n\n\n\nAt this point, we see that we need another supporting fact, namely, that succ (n + m) = succ n + m.\nYou can prove this by induction on m:\n\n\n\nYou can then replace the sorry in the previous proof with succ_add. Yet again, the proofs can be compressed:\n\n\n\n"}});