window.docContents[251].resolve({"/Type-Classes/#type-classes":{"id":"/Type-Classes/#type-classes","header":"10. Type Classes","context":"Theorem Proving in Lean 4","contents":"Type classes were introduced as a principled way of enabling\nad-hoc polymorphism in functional programming languages. We first observe that it\nwould be easy to implement an ad-hoc polymorphic function (such as addition) if the\nfunction simply took the type-specific implementation of addition as an argument\nand then called that implementation on the remaining arguments. For example,\nsuppose we declare a structure in Lean to hold implementations of addition.\n\n\n\nIn the above Lean code, the field add has type\nAdd.add : {α : Type} → Add α → α → α → α\n\nwhere the curly braces around the type α mean that it is an implicit argument.\nWe could implement double by:Note that you can double a natural number n\n by double { add := Nat.add } n\n.\nOf course, it would be highly cumbersome for users to manually pass the\nimplementations around in this way.\nIndeed, it would defeat most of the potential benefits of ad-hoc\npolymorphism.\n\nThe main idea behind type classes is to make arguments such as Add α implicit,\nand to use a database of user-defined instances to synthesize the desired instances\nautomatically through a process known as typeclass resolution. In Lean, by changing\nstructure to class in the example above, the type of Add.add becomes:\n\nwhere the square brackets indicate that the argument of type Add α is instance implicit,\ni.e. that it should be synthesized using typeclass resolution. This version of\nadd is the Lean analogue of the Haskell term add :: Add a => a -> a -> a.\nSimilarly, we can register instances by:\n\n\n\nThen for n : Nat and m : Nat, the term Add.add n m\n triggers typeclass resolution with\nthe goal of Add Nat\n, and typeclass resolution will synthesize the instance for Nat\n above.\nWe can now reimplement double using an instance implicit by:\n\nIn general, instances may depend on other instances in complicated ways. For example,\nyou can declare an instance stating that if α has addition, then Array α\nhas addition:\n\nNote that (· + ·) is notation for fun x y => x + y\n in Lean.\n\nThe example above demonstrates how type classes are used to overload notation.\nNow, we explore another application. We often need an arbitrary element of a given type.\nRecall that types may not have any elements in Lean.\nIt often happens that we would like a definition to return an arbitrary element in a “corner case.”\nFor example, we may like the expression head xs\n to be of type α\n when xs\n is of type List α\n.\nSimilarly, many theorems hold under the additional assumption that a type is not empty.\nFor example, if α\n is a type, ∃ x : α, x = x\n is true only if α\n is not empty.\nThe standard library defines a type class Inhabited\n to enable type class inference to infer a\n“default” element of an inhabited type.\nLet us start with the first step of the program above, declaring an appropriate class:Note Inhabited.default doesn't have any explicit arguments.An element of the class Inhabited α\n is simply an expression of the form Inhabited.mk x\n, for some element x : α.\nThe projection Inhabited.default\n will allow us to “extract” such an element of α\n from an element of Inhabited α\n.\nNow we populate the class with some instances:\n\n\n\nYou can use the command export to create the alias default\n for Inhabited.default\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"/Interacting-with-Lean/#notation":{"id":"/Interacting-with-Lean/#notation","header":"6.7. Notation","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","contents":"Identifiers in Lean can include any alphanumeric characters, including\nGreek characters (other than ∀ , Σ , and λ , which, as we have seen,\nhave a special meaning in the dependent type theory). They can also\ninclude subscripts, which can be entered by typing  followed by\nthe desired subscripted character.\n\nLean's parser is extensible, which is to say, we can define new notation.\n\nLean's syntax can be extended and customized by users at every level,\nranging from basic “mixfix” notations to custom elaborators.  In fact,\nall builtin syntax is parsed and processed using the same mechanisms\nand APIs open to users.  In this section, we will describe and explain\nthe various extension points.\n\nWhile introducing new notations is a relatively rare feature in\nprogramming languages and sometimes even frowned upon because of its\npotential to obscure code, it is an invaluable tool in formalization\nfor expressing established conventions and notations of the respective\nfield succinctly in code.  Going beyond basic notations, Lean's\nability to factor out common boilerplate code into (well-behaved)\nmacros and to embed entire custom domain specific languages (DSLs) to\ntextually encode subproblems efficiently and readably can be of great\nbenefit to both programmers and proof engineers alike.\n\n\n\n"}});