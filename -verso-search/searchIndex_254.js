window.docContents[254].resolve({"/Axioms-and-Computation/#quotients":{"id":"/Axioms-and-Computation/#quotients","header":"12.4. Quotients","context":"Theorem Proving in Lean 4\u0009Axioms and Computation","contents":"Let α\n be any type, and let r\n be an equivalence relation on\nα\n. It is mathematically common to form the “quotient” α / r\n,\nthat is, the type of elements of α\n “modulo” r\n. Set\ntheoretically, one can view α / r\n as the set of equivalence\nclasses of α\n modulo r\n. If f : α → β is any function that\nrespects the equivalence relation in the sense that for every\nx y : α, r x y\n implies f x = f y\n, then f\n “lifts” to a function\nf' : α / r → β\n defined on each equivalence class ⟦x⟧\n by\nf' ⟦x⟧ = f x\n. Lean's standard library extends the Calculus of\nConstructions with additional constants that perform exactly these\nconstructions, and installs this last equation as a definitional\nreduction rule.In its most basic form, the quotient construction does not even\nrequire r\n to be an equivalence relation. The following constants\nare built into Lean:\n\n\n\nThe first one forms a type Quot r\n given a type α\n by any binary\nrelation r\n on α\n. The second maps α\n to Quot α, so that\nif r : α → α → Prop and a : α, then Quot.mk r a\n is an\nelement of Quot r\n. The third principle, Quot.ind\n, says that\nevery element of Quot.mk r a\n is of this form.  As for\nQuot.lift\n, given a function f : α → β, if h\n is a proof\nthat f\n respects the relation r\n, then Quot.lift f h\n is the\ncorresponding function on Quot r\n. The idea is that for each\nelement a\n in α\n, the function Quot.lift f h\n maps\nQuot.mk r a\n (the r\n-class containing a\n) to f a\n, wherein h\n\nshows that this function is well defined. In fact, the computation\nprinciple is declared as a reduction rule, as the proof below makes\nclear.The four constants, Quot\n, Quot.mk\n, Quot.ind\n, and\nQuot.lift\n in and of themselves are not very strong. You can check\nthat the Quot.ind\n is satisfied if we take Quot r\n to be simply\nα\n, and take Quot.lift\n to be the identity function (ignoring\nh\n). For that reason, these four constants are not viewed as\nadditional axioms.\n\n\n\nThey are, like inductively defined types and the associated\nconstructors and recursors, viewed as part of the logical framework.\n\nWhat makes the Quot\n construction into a bona fide quotient is the\nfollowing additional axiom:\n\n\n\nThis is the axiom that asserts that any two elements of α that are\nrelated by r become identified in the quotient. If a theorem or\ndefinition makes use of Quot.sound, it will show up in the\n#print axioms command.\n\nOf course, the quotient construction is most commonly used in\nsituations when r\n is an equivalence relation. Given r\n as\nabove, if we define r'\n according to the rule r' a b\n iff\nQuot.mk r a = Quot.mk r b\n, then it's clear that r'\n is an\nequivalence relation. Indeed, r'\n is the kernel of the function\nfun a => Quot.mk r a\n.  The axiom Quot.sound\n says that r a b\n\nimplies r' a b\n. Using Quot.lift\n and Quot.ind\n, we can show\nthat r'\n is the smallest equivalence relation containing r\n, in\nthe sense that if r''\n is any equivalence relation containing\nr\n, then r' a b\n implies r'' a b\n. In particular, if r\n\nwas an equivalence relation to start with, then for all a\n and\nb\n we have r a b\n iff r' a b\n.\n\nTo support this common use case, the standard library defines the\nnotion of a setoid, which is simply a type with an associated\nequivalence relation:\n\n\n\nGiven a type α, a relation r\non α, and a proof iseqv\nthat r is an equivalence relation, we can define an\ninstance of the Setoid class.\n\n\n\nThe constants Quotient.mk\n, Quotient.ind\n, Quotient.lift\n,\nand Quotient.sound\n are nothing more than the specializations of\nthe corresponding elements of Quot\n. The fact that type class\ninference can find the setoid associated to a type α\n brings a\nnumber of benefits. First, we can use the notation a ≈ b\n (entered\nwith ) for Setoid.r a b\n, where the instance of\nSetoid\n is implicit in the notation Setoid.r\n. We can use the\ngeneric theorems Setoid.refl\n, Setoid.symm\n, Setoid.trans\n to\nreason about the relation. Specifically with quotients we can use the\ntheorem Quotient.exact\n:Together with Quotient.sound\n, this implies that the elements of\nthe quotient correspond exactly to the equivalence classes of elements\nin α\n.\n\nRecall that in the standard library, α × β\n represents the\nCartesian product of the types α\n and β\n. To illustrate the use\nof quotients, let us define the type of unordered pairs of elements\nof a type α\n as a quotient of the type α × α\n. First, we define\nthe relevant equivalence relation:\n\n\n\nThe next step is to prove that eqv is in fact an equivalence\nrelation, which is to say, it is reflexive, symmetric and\ntransitive. We can prove these three facts in a convenient and\nreadable way by using dependent pattern matching to perform\ncase-analysis and break the hypotheses into pieces that are then\nreassembled to produce the conclusion.\n\n\n\nNow that we have proved that eqv is an equivalence relation, we\ncan construct a Setoid (α × α), and use it to define the type\nUProd α of unordered pairs.\n\nNotice that we locally define the notation {a₁, a₂}\n for unordered\npairs as Quotient.mk' (a₁, a₂)\n. This is useful for illustrative\npurposes, but it is not a good idea in general, since the notation\nwill shadow other uses of curly brackets, such as for records and\nsets.We can easily prove that {a₁, a₂} = {a₂, a₁}\n using Quot.sound\n,\nsince we have (a₁, a₂) ~ (a₂, a₁)\n.\n\n\n\nTo complete the example, given a : α and u : UProd α, we\ndefine the proposition a ∈ u which should hold if a is one of\nthe elements of the unordered pair u. First, we define a similar\nproposition mem_fn a u on (ordered) pairs; then we show that\nmem_fn respects the equivalence relation eqv with the lemma\nmem_respects. This is an idiom that is used extensively in the\nLean standard library.\n\nFor convenience, the standard library also defines Quotient.lift₂\n\nfor lifting binary functions, and Quotient.ind₂ for induction on\ntwo variables.\n\nWe close this section with some hints as to why the quotient\nconstruction implies function extensionality. It is not hard to show\nthat extensional equality on the (x : α) → β x\n is an equivalence\nrelation, and so we can consider the type extfun α β\n of functions\n“up to equivalence.” Of course, application respects that equivalence\nin the sense that if f₁\n is equivalent to f₂\n, then f₁ a\n is\nequal to f₂ a\n. Thus application gives rise to a function\nextfun_app : extfun α β → (x : α) → β x\n. But for every f\n,\nextfun_app (.mk _ f)\n is definitionally equal to fun x => f x\n, which is\nin turn definitionally equal to f\n. So, when f₁\n and f₂\n are\nextensionally equal, we have the following chain of equalities:As a result, f₁ is equal to f₂.\n\n"}});