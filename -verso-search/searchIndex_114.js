window.docContents[114].resolve({"/Axioms-and-Computation/#historical-and-philosophical-context":{"contents":"For most of its history, mathematics was essentially computational:\ngeometry dealt with constructions of geometric objects, algebra was\nconcerned with algorithmic solutions to systems of equations, and\nanalysis provided means to compute the future behavior of systems\nevolving over time. From the proof of a theorem to the effect that\n“for every x\n, there is a y\n such that ...”, it was generally\nstraightforward to extract an algorithm to compute such a y\n given\nx\n.\n\nIn the nineteenth century, however, increases in the complexity of\nmathematical arguments pushed mathematicians to develop new styles of\nreasoning that suppress algorithmic information and invoke\ndescriptions of mathematical objects that abstract away the details of\nhow those objects are represented. The goal was to obtain a powerful\n“conceptual” understanding without getting bogged down in\ncomputational details, but this had the effect of admitting\nmathematical theorems that are simply false on a direct\ncomputational reading.\n\nThere is still fairly uniform agreement today that computation is\nimportant to mathematics. But there are different views as to how best\nto address computational concerns. From a constructive point of\nview, it is a mistake to separate mathematics from its computational\nroots; every meaningful mathematical theorem should have a direct\ncomputational interpretation. From a classical point of view, it is\nmore fruitful to maintain a separation of concerns: we can use one\nlanguage and body of methods to write computer programs, while\nmaintaining the freedom to use nonconstructive theories and methods\nto reason about them. Lean is designed to support both of these\napproaches. Core parts of the library are developed constructively,\nbut the system also provides support for carrying out classical\nmathematical reasoning.\n\nComputationally, the purest part of dependent type theory avoids the\nuse of Prop\n entirely. Inductive types and dependent function types\ncan be viewed as data types, and terms of these types can be\n“evaluated” by applying reduction rules until no more rules can be\napplied. In principle, any closed term (that is, term with no free\nvariables) of type Nat\n should evaluate to a numeral, succ (… (succ zero)…)\n.\n\nIntroducing a proof-irrelevant Prop\n and marking theorems\nirreducible represents a first step towards separation of\nconcerns. The intention is that elements of a type p : Prop should\nplay no role in computation, and so the particular construction of a\nterm prf : p is “irrelevant” in that sense. One can still define\ncomputational objects that incorporate elements of type Prop\n; the\npoint is that these elements can help us reason about the effects of\nthe computation, but can be ignored when we extract “code” from the\nterm. Elements of type Prop\n are not entirely innocuous,\nhowever. They include equations s = t : α\n for any type α\n, and\nsuch equations can be used as casts, to type check terms. Below, we\nwill see examples of how such casts can block computation in the\nsystem. However, computation is still possible under an evaluation\nscheme that erases propositional content, ignores intermediate typing\nconstraints, and reduces terms until they reach a normal form. This is\nprecisely what Lean's virtual machine does.Having adopted a proof-irrelevant Prop\n, one might consider it\nlegitimate to use, for example, the law of the excluded middle,\np ∨ ¬p\n, where p\n is any proposition. Of course, this, too, can block\ncomputation according to the rules of CIC, but it does not prevent the generation\nof executable code, as described above. It is only the choice\nprinciples discussed in the section on choice that completely erase the\ndistinction between the proof-irrelevant and data-relevant parts of\nthe theory.\n\n","context":"Theorem Proving in Lean 4\u0009Axioms and Computation","header":"12.1. Historical and Philosophical Context","id":"/Axioms-and-Computation/#historical-and-philosophical-context"},"/Induction-and-Recursion/#match-expressions":{"contents":"Lean also provides a compiler for match-with expressions found in\nmany functional languages:\n\n\n\nThis does not look very different from an ordinary pattern matching\ndefinition, but the point is that a match can be used anywhere in\nan expression, and with arbitrary arguments.\n\n\n\nHere is another example:\n\n\n\nLean uses the match construct internally to implement pattern-matching in all parts of the system.\nThus, all four of these definitions have the same net effect:\n\n\n\nThese variations are equally useful for destructing propositions:\n\n\n\n","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","header":"8.10. Match Expressions","id":"/Induction-and-Recursion/#match-expressions"}});