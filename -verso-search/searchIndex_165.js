window.docContents[165].resolve({"/Axioms-and-Computation/#function-extensionality":{"contents":"Similar to propositional extensionality, function extensionality\nasserts that any two functions of type (x : α) → β x that agree on\nall their inputs are equal:\n\nFrom a classical, set-theoretic perspective, this is exactly what it\nmeans for two functions to be equal. This is known as an “extensional”\nview of functions. From a constructive perspective, however, it is\nsometimes more natural to think of functions as algorithms, or\ncomputer programs, that are presented in some explicit way. It is\ncertainly the case that two computer programs can compute the same\nanswer for every input despite the fact that they are syntactically\nquite different. In much the same way, you might want to maintain a\nview of functions that does not force you to identify two functions\nthat have the same input / output behavior. This is known as an\n“intensional” view of functions.\n\nIn fact, function extensionality follows from the existence of\nquotients, which we describe in the next section. In the Lean standard\nlibrary, therefore, funext is thus\nproved from the quotient construction.\n\nSuppose that for α : Type u we define the Set α := α → Prop to\ndenote the type of subsets of α, essentially identifying subsets\nwith predicates. By combining funext and propext, we obtain an\nextensional theory of such sets:\n\nWe can then proceed to define the empty set and set intersection, for\nexample, and prove set identities:\n\n\n\nThe following is an example of how function extensionality blocks\ncomputation inside the Lean kernel:\n\n\n\nFirst, we show that the two functions f and g are equal using\nfunction extensionality, and then we cast 0 of type Nat\n by\nreplacing f by g in the type. Of course, the cast is\nvacuous, because Nat\n does not depend on f. But that is enough\nto do the damage: under the computational rules of the system, we now\nhave a closed term of Nat\n that does not reduce to a numeral. In this\ncase, we may be tempted to reduce the expression to 0\n. But in\nnontrivial examples, eliminating cast changes the type of the term,\nwhich might make an ambient expression type incorrect. The virtual\nmachine, however, has no trouble evaluating the expression to\n0\n. Here is a similarly contrived example that shows how\npropext\n can get in the way:\n\n\n\nCurrent research programs, including work on observational type\ntheory and cubical type theory, aim to extend type theory in ways\nthat permit reductions for casts involving function extensionality,\nquotients, and more. But the solutions are not so clear-cut, and the\nrules of Lean's underlying calculus do not sanction such reductions.\n\nIn a sense, however, a cast does not change the meaning of an\nexpression. Rather, it is a mechanism to reason about the expression's\ntype. Given an appropriate semantics, it then makes sense to reduce\nterms in ways that preserve their meaning, ignoring the intermediate\nbookkeeping needed to make the reductions type-correct. In that case,\nadding new axioms in Prop\n does not matter; by proof irrelevance,\nan expression in Prop\n carries no information, and can be safely\nignored by the reduction procedures.\n\n","context":"Theorem Proving in Lean 4\u0009Axioms and Computation","header":"12.3. Function Extensionality","id":"/Axioms-and-Computation/#function-extensionality"}});