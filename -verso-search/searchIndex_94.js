window.docContents[94].resolve({"/Structures-and-Records/#declaring-structures":{"contents":"The structure command is essentially a “front end” for defining\ninductive data types. Every structure declaration introduces a\nnamespace with the same name. The general form is as follows:\n\n    structure <name> <parameters> <parent-structures> where\n      <constructor> :: <fields>\n\n\nMost parts are optional. Here is an example:\n\n\n\nValues of type Point are created using Point.mk a b\n, and the\nfields of a point p\n are accessed using Point.x p\n and\nPoint.y p\n (but p.x\n and p.y\n also work, see below).\nThe structure command also generates useful recursors and\ntheorems. Here are some of the constructions generated for the\ndeclaration above.\n\n\n\nIf the constructor name is not provided, then a constructor is named\nmk by default.\n\nHere are some simple theorems and expressions that use the generated\nconstructions. As usual, you can avoid the prefix Point by using\nthe command open Point.\n\nGiven p : Point Nat, the dot notation p.x\n is shorthand for\nPoint.x p\n. This provides a convenient way of accessing the fields\nof a structure.\n\n\n\nThe dot notation is convenient not just for accessing the projections\nof a record, but also for applying functions defined in a namespace\nwith the same name. Recall from the Conjunction section if p\nhas type Point, the expression p.foo is interpreted as\nPoint.foo p, assuming that the first non-implicit argument to\nfoo has type Point. The expression p.add q is therefore\nshorthand for Point.add p q in the example below.\n\nIn the next chapter, you will learn how to define a function like\nadd so that it works generically for elements of Point α\n\nrather than just Point Nat\n, assuming α\n has an associated\naddition operation.\n\nMore generally, given an expression p.foo x y z where p : Point,\nLean will insert p at the first argument to Point.foo of type\nPoint. For example, with the definition of scalar multiplication\nbelow, p.smul 3 is interpreted as Point.smul 3 p.\n\nIt is common to use a similar trick with the List.map function,\nwhich takes a list as its second non-implicit argument:\n\n\n\nHere xs.map f is interpreted as List.map f xs.\n\n","context":"Theorem Proving in Lean 4\u0009Structures and Records","header":"9.1. Declaring Structures","id":"/Structures-and-Records/#declaring-structures"}});