window.docContents[128].resolve({"/Inductive-Types/#inductively-defined-propositions":{"id":"/Inductive-Types/#inductively-defined-propositions","header":"7.3. Inductively Defined Propositions","context":"Theorem Proving in Lean 4\u0009Inductive Types","contents":"Inductively defined types can live in any type universe, including the\nbottom-most one, Prop\n. In fact, this is exactly how the logical\nconnectives are defined.\n\n\n\nYou should think about how these give rise to the introduction and\nelimination rules that you have already seen. There are rules that\ngovern what the eliminator of an inductive type can eliminate to,\nthat is, what kinds of types can be the target of a recursor. Roughly\nspeaking, what characterizes inductive types in Prop\n is that one\ncan only eliminate to other types in Prop\n. This is consistent with\nthe understanding that if p : Prop, an element hp : p carries\nno data. There is a small exception to this rule, however, which we\nwill discuss below, in Inductive Families.Even the existential quantifier is inductively defined:Keep in mind that the notation ∃ x : α, p\n is syntactic sugar for Exists (fun x : α => p)\n.The definitions of False\n, True\n, And\n, and Or\n are\nperfectly analogous to the definitions of Empty\n, Unit\n,\nProd\n, and Sum\n. The difference is that the first group yields\nelements of Prop\n, and the second yields elements of Type u\n for\nsome u. In a similar way, ∃ x : α, p is a Prop\n-valued\nvariant of Σ x : α, β\n.\n\nThis is a good place to mention another inductive type, denoted\n{x : α // p}\n, which is sort of a hybrid between\n∃ x : α, p\n and Σ x : α, β\n.\n\nIn fact, in Lean, Subtype is defined using the structure command:The notation {x : α // p x}\n is syntactic sugar for Subtype (fun x : α => p x)\n.\nIt is modeled after subset notation in set theory: the idea is that {x : α // p x}\ndenotes the collection of elements of α that have property p.\n\n"}});