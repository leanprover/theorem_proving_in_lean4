window.docContents[14].resolve({"/Structures-and-Records/#objects":{"id":"/Structures-and-Records/#objects","header":"9.2. Objects","context":"Theorem Proving in Lean 4\u0009Structures and Records","contents":"We have been using constructors to create elements of a structure\ntype. For structures containing many fields, this is often\ninconvenient, because we have to remember the order in which the\nfields were defined. Lean therefore provides the following alternative\nnotations for defining elements of a structure type.\n\n    { (<field-name> := <expr>)* : structure-type }\n    or\n    { (<field-name> := <expr>)* }\n\n\nThe suffix : structure-type can be omitted whenever the name of\nthe structure can be inferred from the expected type. For example, we\nuse this notation to define “points.” The order that the fields are\nspecified does not matter, so all the expressions below define the\nsame point.\n\n\n\nFields can be marked as implicit using curly braces.\nImplicit fields become implicit parameters to the constructor.\n\nIf the value of a field is not specified, Lean tries to infer it. If\nthe unspecified fields cannot be inferred, Lean flags an error\nindicating the corresponding placeholder could not be synthesized.\n\n\n\nRecord update is another common operation which amounts to creating\na new record object by modifying the value of one or more fields in an\nold one. Lean allows you to specify that unassigned fields in the\nspecification of a record should be taken from a previously defined\nstructure object s by adding the annotation s with before the field\nassignments. If more than one record object is provided, then they are\nvisited in order until Lean finds one that contains the unspecified\nfield. Lean raises an error if any of the field names remain\nunspecified after all the objects are visited.\n\n\n\n"}});