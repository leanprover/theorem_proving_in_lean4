window.docContents[60].resolve({"/Propositions-and-Proofs/#propositions-as-types":{"contents":"One strategy for proving assertions about objects defined in the\nlanguage of dependent type theory is to layer an assertion language\nand a proof language on top of the definition language. But there is\nno reason to multiply languages in this way: dependent type theory is\nflexible and expressive, and there is no reason we cannot represent\nassertions and proofs in the same general framework.\n\nFor example, we could introduce a new type, Prop\n, to represent\npropositions, and introduce constructors to build new propositions\nfrom others.\n\n\n\n\n\nWe could then introduce, for each element p : Prop, another type\nProof p\n, for the type of proofs of p\n.  An “axiom” would be a\nconstant of such a type.\n\n\n\nIn addition to axioms, however, we would also need rules to build new\nproofs from old ones. For example, in many proof systems for\npropositional logic, we have the rule of modus ponens:\n\nFrom a proof of Implies p q\n and a proof of p\n, we obtain a proof of q\n.\n\nWe could represent this as follows:\n\n\n\nSystems of natural deduction for propositional logic also typically rely on the following rule:\n\nSuppose that, assuming p\n as a hypothesis, we have a proof of q\n. Then we can “cancel” the hypothesis and obtain a proof of Implies p q\n.\n\nWe could render this as follows:\n\n\n\nThis approach would provide us with a reasonable way of building assertions and proofs.\nDetermining that an expression t\n is a correct proof of assertion p\n would then\nsimply be a matter of checking that t\n has type Proof p\n.\n\nSome simplifications are possible, however. To start with, we can\navoid writing the term Proof\n repeatedly by conflating Proof p\n\nwith p\n itself. In other words, whenever we have p : Prop, we\ncan interpret p\n as a type, namely, the type of its proofs. We can\nthen read t : p as the assertion that t\n is a proof of p\n.\n\nMoreover, once we make this identification, the rules for implication\nshow that we can pass back and forth between Implies p q\n and\np → q\n. In other words, implication between propositions p\n and q\n\ncorresponds to having a function that takes any element of p\n to an\nelement of q\n. As a result, the introduction of the connective\nImplies\n is entirely redundant: we can use the usual function space\nconstructor p → q\n from dependent type theory as our notion of\nimplication.\n\nThis is the approach followed in the Calculus of Constructions, and\nhence in Lean as well. The fact that the rules for implication in a\nproof system for natural deduction correspond exactly to the rules\ngoverning abstraction and application for functions is an instance of\nthe Curry-Howard isomorphism, sometimes known as the\npropositions-as-types paradigm. In fact, the type Prop\n is\nsyntactic sugar for Sort 0\n, the very bottom of the type hierarchy\ndescribed in the last chapter. Moreover, Type u\n is also just\nsyntactic sugar for Sort (u+1)\n. Prop\n has some special\nfeatures, but like the other type universes, it is closed under the\narrow constructor: if we have p q : Prop, then p → q : Prop\n.\n\nThere are at least two ways of thinking about propositions as\ntypes. To some who take a constructive view of logic and mathematics,\nthis is a faithful rendering of what it means to be a proposition: a\nproposition p\n represents a sort of data type, namely, a\nspecification of the type of data that constitutes a proof. A proof of\np\n is then simply an object t : p of the right type.\n\nThose not inclined to this ideology can view it, rather, as a simple\ncoding trick. To each proposition p\n we associate a type that is\nempty if p\n is false and has a single element, say *, if p\n\nis true. In the latter case, let us say that (the type associated\nwith) p\n is inhabited. It just so happens that the rules for\nfunction application and abstraction can conveniently help us keep\ntrack of which elements of Prop\n are inhabited. So constructing an\nelement t : p tells us that p\n is indeed true. You can think of\nthe inhabitant of p\n as being the “fact that p\n is true.” A\nproof of p → q\n uses “the fact that p\n is true” to obtain “the\nfact that q\n is true.”\n\nIndeed, if p : Prop is any proposition, Lean's kernel treats any\ntwo elements t1 t2 : p as being definitionally equal, much the\nsame way as it treats (fun x => t) s and t[s/x] as\ndefinitionally equal. This is known as proof irrelevance, and is\nconsistent with the interpretation in the last paragraph. It means\nthat even though we can treat proofs t : p as ordinary objects in\nthe language of dependent type theory, they carry no information\nbeyond the fact that p\n is true.\n\nThe two ways we have suggested thinking about the\npropositions-as-types paradigm differ in a fundamental way. From the\nconstructive point of view, proofs are abstract mathematical objects\nthat are denoted by suitable expressions in dependent type\ntheory. In contrast, if we think in terms of the coding trick\ndescribed above, then the expressions themselves do not denote\nanything interesting. Rather, it is the fact that we can write them\ndown and check that they are well-typed that ensures that the\nproposition in question is true. In other words, the expressions\nthemselves are the proofs.\n\nIn the exposition below, we will slip back and forth between these two\nways of talking, at times saying that an expression “constructs” or\n“produces” or “returns” a proof of a proposition, and at other times\nsimply saying that it “is” such a proof. This is similar to the way\nthat computer scientists occasionally blur the distinction between\nsyntax and semantics by saying, at times, that a program “computes” a\ncertain function, and at other times speaking as though the program\n“is” the function in question.\n\nIn any case, all that really matters is the bottom line. To formally\nexpress a mathematical assertion in the language of dependent type\ntheory, we need to exhibit a term p : Prop. To prove that\nassertion, we need to exhibit a term t : p. Lean's task, as a\nproof assistant, is to help us to construct such a term, t\n, and to\nverify that it is well-formed and has the correct type.\n\n","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs","header":"3.1. Propositions as Types","id":"/Propositions-and-Proofs/#propositions-as-types"}});