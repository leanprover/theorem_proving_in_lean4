window.docContents[237].resolve({"/Dependent-Type-Theory/#implicit-arguments":{"id":"/Dependent-Type-Theory/#implicit-arguments","header":"2.9. Implicit Arguments","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","contents":"Suppose we have an implementation of lists as:\n\n\n\nThen, you can construct lists of Nat\n as follows:\n\n\n\nBecause the constructors are polymorphic over types, we have to insert\nthe type Nat\n as an argument repeatedly. But this information is\nredundant: one can infer the argument α in\nLst.cons Nat 5 (Lst.nil Nat) from the fact that the second argument, 5, has\ntype Nat\n. One can similarly infer the argument in Lst.nil Nat, not\nfrom anything else in that expression, but from the fact that it is\nsent as an argument to the function Lst.cons, which expects an element\nof type Lst α\n in that position.\n\nThis is a central feature of dependent type theory: terms carry a lot\nof information, and often some of that information can be inferred\nfrom the context. In Lean, one uses an underscore, _, to specify\nthat the system should fill in the information automatically. This is\nknown as an “implicit argument.”\n\n\n\nIt is still tedious, however, to type all these underscores. When a\nfunction takes an argument that can generally be inferred from\ncontext, Lean allows you to specify that this argument should, by\ndefault, be left implicit. This is done by putting the arguments in\ncurly braces, as follows:\n\n\n\nAll that has changed are the braces around α : Type u in the\ndeclaration of the variables. We can also use this device in function\ndefinitions:\n\n\n\nChecking the type of ident requires wrapping it in parentheses to avoid having its signature shown:\n\n\n\nThe makes the first argument to ident implicit. Notationally,\nthis hides the specification of the type, making it look as though\nident simply takes an argument of any type. In fact, the function\nid\n is defined in the standard library in exactly this way. We have\nchosen a nontraditional name here only to avoid a clash of names.\n\nVariables can also be specified as implicit when they are declared with\nthe variable command:\n\n\n\nThis definition of ident here has the same effect as the one\nabove.\n\nLean has very complex mechanisms for instantiating implicit arguments,\nand we will see that they can be used to infer function types,\npredicates, and even proofs. The process of instantiating these\n“holes,” or “placeholders,” in a term is often known as\nelaboration. The presence of implicit arguments means that at times\nthere may be insufficient information to fix the meaning of an\nexpression precisely. An expression like id\n or List.nil\n is\nsaid to be polymorphic, because it can take on different meanings in\ndifferent contexts.\n\nOne can always specify the type T\n of an expression e\n by\nwriting (e : T)\n. This instructs Lean's elaborator to use the value\nT\n as the type of e\n when trying to resolve implicit\narguments. In the second pair of examples below, this mechanism is\nused to specify the desired types of the expressions id\n and\nList.nil\n:\n\n\n\nNumerals are overloaded in Lean, but when the type of a numeral cannot\nbe inferred, Lean assumes, by default, that it is a natural number. So\nthe expressions in the first two #check commands below are\nelaborated in the same way, whereas the third #check command\ninterprets 2\n as an integer.\n\n\n\nSometimes, however, we may find ourselves in a situation where we have\ndeclared an argument to a function to be implicit, but now want to\nprovide the argument explicitly. If foo\n is such a function, the\nnotation @foo\n denotes the same function with all the arguments\nmade explicit.\n\n\n\nNotice that now the first #check command gives the type of the\nidentifier, id, without inserting any placeholders. Moreover, the\noutput indicates that the first argument is implicit.\n\n\n"}});