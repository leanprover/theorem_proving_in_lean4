window.docContents[156].resolve({"/Induction-and-Recursion/#well-founded-recursion-and-induction":{"id":"/Induction-and-Recursion/#well-founded-recursion-and-induction","header":"8.5. Well-Founded Recursion and Induction","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","contents":"When structural recursion cannot be used, we can prove termination using well-founded recursion.\nWe need a well-founded relation and a proof that each recursive application is decreasing with respect to\nthis relation. Dependent type theory is powerful enough to encode and justify\nwell-founded recursion. Let us start with the logical background that\nis needed to understand how it works.\n\nLean's standard library defines two predicates, Acc r a\n and\nWellFounded r\n, where r\n is a binary relation on a type α\n,\nand a\n is an element of type α\n.\n\n\n\n\n\nThe first, Acc, is an inductively defined predicate. According to\nits definition, Acc r x is equivalent to\n∀ y, r y x → Acc r y. If you think of r y x as denoting a kind of order relation\ny ≺ x, then Acc r x says that x is accessible from below,\nin the sense that all its predecessors are accessible. In particular,\nif x has no predecessors, it is accessible. Given any type α,\nwe should be able to assign a value to each accessible element of\nα, recursively, by assigning values to all its predecessors first.\n\nThe statement that r is well-founded, denoted WellFounded r,\nis exactly the statement that every element of the type is\naccessible. By the above considerations, if r is a well-founded\nrelation on a type α, we should have a principle of well-founded\nrecursion on α, with respect to the relation r. And, indeed,\nwe do: the standard library defines WellFounded.fix, which serves\nexactly that purpose.\n\n\n\nThere is a long cast of characters here, but the first block we have\nalready seen: the type, α, the relation, r, and the\nassumption, h, that r is well-founded. The variable C\nrepresents the motive of the recursive definition: for each element\nx : α, we would like to construct an element of C x. The\nfunction F provides the inductive recipe for doing that: it tells\nus how to construct an element C x, given elements of C y for\neach predecessor y of x.\n\nNote that WellFounded.fix works equally well as an induction\nprinciple. It says that if ≺ is well-founded and you want to prove\n∀ x, C x\n, it suffices to show that for an arbitrary x\n, if we\nhave ∀ y, r y x → C y\n, then we have C x\n.\n\nIn the example above we use the modifier noncomputable because the code\ngenerator currently does not support WellFounded.fix. The function\nWellFounded.fix is another tool Lean uses to justify that a function\nterminates.\n\nLean knows that the usual order < on the natural numbers is well\nfounded. It also knows a number of ways of constructing new well\nfounded orders from others, for example, using lexicographic order.\n\nHere is essentially the definition of division on the natural numbers that is found in the standard library.\n\n\n\n\n\nThe definition is somewhat inscrutable. Here the recursion is on\nx, and div.F x f : Nat → Nat returns the “divide by y”\nfunction for that fixed x. You have to remember that the second\nargument to div.F, the recipe for the recursion, is a function\nthat is supposed to return the divide by y function for all values\nx₁ smaller than x.\n\nThe elaborator is designed to make definitions like this more\nconvenient. It accepts the following:\n\n\n\nWhen Lean encounters a recursive definition, it first\ntries structural recursion, and only when that fails, does it fall\nback on well-founded recursion. Lean uses the tactic decreasing_tactic\nto show that the recursive applications are smaller. The auxiliary\nproposition x - y < x in the example above should be viewed as a hint\nfor this tactic.\n\nThe defining equation for div does not hold definitionally, but\nwe can unfold div using the unfold tactic. We use conv to select which\ndiv application we want to unfold.\n\n\n\nThe following example is similar: it converts any natural number to a\nbinary expression, represented as a list of 0's and 1's. We have to\nprovide evidence that the recursive call is\ndecreasing, which we do here with a sorry. The sorry does not\nprevent the interpreter from evaluating the function successfully,\nbut #eval! must be used instead of #eval when a term contains sorry.\n\nAs a final example, we observe that Ackermann's function can be\ndefined directly, because it is justified by the well-foundedness of\nthe lexicographic order on the natural numbers. The termination_by clause\ninstructs Lean to use a lexicographic order. This clause is actually mapping\nthe function arguments to elements of type Nat × Nat\n. Then, Lean uses typeclass\nresolution to synthesize an element of type WellFoundedRelation (Nat × Nat)\n.\n\nIn many cases, Lean can automatically determine an appropriate lexicographical order.\nAckermann's function is one such case, so the termination_by clause is optional:\n\n\n\nNote that a lexicographic order is used in the example above because the instance\nWellFoundedRelation (α × β)\n uses a lexicographic order. Lean also defines the instance\n\nIn the following example, we prove termination by showing that as.size - i is decreasing\nin the recursive application.\n\nNote that, auxiliary function go is recursive in this example, but takeWhile is not.\nOnce again, Lean can automatically recognize this pattern, so the termination_by clause is unnecessary:\n\n\n\nBy default, Lean uses the tactic decreasing_tactic to prove recursive applications are decreasing. The modifier decreasing_by allows us to provide our own tactic. Here is an example.\n\nNote that decreasing_by is not replacement for termination_by, they complement each other. termination_by is used to specify a well-founded relation, and decreasing_by for providing our own tactic for showing recursive applications are decreasing. In the following example, we use both of them.\n\n\n\nWe can use decreasing_by sorry to instruct Lean to “trust” us that the function terminates.\n\nRecall that using sorry is equivalent to using a new axiom, and should be avoided. In the following example, we used the sorry to prove False.\nThe command #print axioms unsound shows that unsound depends on the unsound axiom sorryAx\n used to implement sorry.\n\nSummary:* If there is no termination_by, a well-founded relation is derived (if possible) by selecting an argument and then using typeclass resolution to synthesize a well-founded relation for this argument's type.* If termination_by is specified, it maps the arguments of the function to a type α\n and type class resolution is again used. Recall that, the default instance for β × γ\n is a lexicographic order based on the well-founded relations for β\n and γ\n.* The default well-founded relation instance for Nat\n is (· < ·)\n.* By default, the tactic decreasing_tactic is used to show that recursive applications are smaller with respect to the selected well-founded relation. If decreasing_tactic fails, the error message includes the remaining goal ... |- G. Note that, the decreasing_tactic uses assumption. So, you can include a have-expression to prove goal G\n. You can also provide your own tactic using decreasing_by.\n\n"}});