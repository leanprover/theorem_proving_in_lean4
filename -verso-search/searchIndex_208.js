window.docContents[208].resolve({"/Dependent-Type-Theory/#simple-type-theory":{"id":"/Dependent-Type-Theory/#simple-type-theory","header":"2.1. Simple Type Theory","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","contents":"“Type theory” gets its name from the fact that every expression has an\nassociated type. For example, in a given context, x + 0 may\ndenote a natural number and f may denote a function on the natural\nnumbers. For those who like precise definitions, a Lean natural number\nis an arbitrary-precision unsigned integer.\n\nHere are some examples of how you can declare objects in Lean and\ncheck their types.\n\n\n\nAny text between /- and -/ constitutes a comment block that is\nignored by Lean. Similarly, two dashes --\n indicate that the rest of\nthe line contains a comment that is also ignored. Comment blocks can\nbe nested, making it possible to “comment out” chunks of code, just as\nin many programming languages.\n\nThe def keyword declares new constant symbols into the\nworking environment. In the example above, def m : Nat := 1\ndefines a new constant m of type Nat\n whose value is 1.\nThe #check command asks Lean to report their\ntypes; in Lean, auxiliary commands that query the system for\ninformation typically begin with the hash (#) symbol.\nThe #eval command asks Lean to evaluate the given expression.\nYou should try\ndeclaring some constants and type checking some expressions on your\nown. Declaring new objects in this manner is a good way to experiment\nwith the system.\n\nWhat makes simple type theory powerful is that you can build new types\nout of others. For example, if a\n and b\n are types, a -> b\n\ndenotes the type of functions from a\n to b\n, and a × b\n\ndenotes the type of pairs consisting of an element of a\n paired\nwith an element of b\n, also known as the Cartesian product. Note\nthat × is a Unicode symbol. The judicious use of Unicode improves\nlegibility, and all modern editors have great support for it. In the\nLean standard library, you often see Greek letters to denote types,\nand the Unicode symbol → as a more compact version of ->.\n\n\n\n\n\nOnce again, you should try some examples on your own.\n\nLet's take a look at some basic syntax. You can enter the Unicode\narrow → by typing  or  or . You can also use the\nASCII alternative ->, so the expressions Nat -> Nat\n and Nat → Nat\n\nmean the same thing. Both expressions denote the type of\nfunctions that take a natural number as input and return a natural\nnumber as output. The Unicode symbol × for the Cartesian product\nis entered as . You will generally use lower-case Greek\nletters like α, β, and γ to range over types. You can\nenter these particular ones with , , and .\n\nThere are a few more things to notice here. First, the application of\na function f\n to a value x\n is denoted f x\n (e.g., Nat.succ 2\n).\nSecond, when writing type expressions, arrows associate to the right; for\nexample, the type of Nat.add\n is Nat → Nat → Nat\n which is equivalent\nto Nat → (Nat → Nat)\n. Thus you can\nview Nat.add\n as a function that takes a natural number and returns\nanother function that takes a natural number and returns a natural\nnumber. In type theory, this is generally more convenient than\nwriting Nat.add\n as a function that takes a pair of natural numbers as\ninput and returns a natural number as output. For example, it allows\nyou to “partially apply” the function Nat.add\n.  The example above shows\nthat Nat.add 3\n has type Nat → Nat\n, that is, Nat.add 3\n returns a\nfunction that “waits” for a second argument, n\n, which is then\nequivalent to writing Nat.add 3 n\n.You have seen that if you have m : Nat and n : Nat, then\n(m, n)\n denotes the ordered pair of m\n and n\n which is of\ntype Nat × Nat\n. This gives you a way of creating pairs of natural\nnumbers. Conversely, if you have p : Nat × Nat, then you can write\np.1 : Nat\n and p.2 : Nat\n. This gives you a way of extracting\nits two components.\n\n"}});