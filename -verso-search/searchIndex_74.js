window.docContents[74].resolve({"/#Theorem-Proving-in-Lean-4":{"contents":"This version of the text assumes you’re using Lean 4 (specifically v4.23.0). See the\nQuickstart section of\nthe Lean documentation to install Lean. The first version of this book was\nwritten for Lean 2, and the Lean 3 version is available\nhere.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","context":"","header":"Theorem Proving in Lean 4","id":"/#Theorem-Proving-in-Lean-4"},"/Propositions-and-Proofs/#conjunction":{"contents":"The expression And.intro h1 h2\n builds a proof of p ∧ q\n using\nproofs h1 : p and h2 : q. It is common to describe\nAnd.intro\n as the and-introduction rule. In the next example we\nuse And.intro\n to create a proof of p → q → p ∧ q\n.\n\n\n\nThe example command states a theorem without naming it or storing\nit in the permanent context. Essentially, it just checks that the\ngiven term has the indicated type. It is convenient for illustration,\nand we will use it often.\n\nThe expression And.left h\n creates a proof of p\n from a proof\nh : p ∧ q. Similarly, And.right h\n is a proof of q\n. They\nare commonly known as the left and right and-elimination rules.\n\n\n\nWe can now prove p ∧ q → q ∧ p\n with the following proof term.\n\n\n\nNotice that and-introduction and and-elimination are similar to the\npairing and projection operations for the Cartesian product. The\ndifference is that given hp : p and hq : q, And.intro hp hq\n has type\np ∧ q : Prop\n, while given a : α and b : β, Prod.mk a b\n has type\nα × β : Type\n. Prod\n cannot be used with Prop\ns, and And\n cannot be used with Type\ns.\nThe similarity between ∧ and × is another instance\nof the Curry-Howard isomorphism, but in contrast to implication and\nthe function space constructor, ∧ and × are treated separately\nin Lean. With the analogy, however, the proof we have just constructed\nis similar to a function that swaps the elements of a pair.We will see in Structures and Records that certain\ntypes in Lean are structures, which is to say, the type is defined\nwith a single canonical constructor which builds an element of the\ntype from a sequence of suitable arguments. For every p q : Prop,\np ∧ q\n is an example: the canonical way to construct an element is\nto apply And.intro\n to suitable arguments hp : p and\nhq : q. Lean allows us to use anonymous constructor notation\n⟨arg1, arg2, ...⟩ in situations like these, when the relevant type is an\ninductive type and can be inferred from the context. In particular, we\ncan often write ⟨hp, hq⟩\n instead of And.intro hp hq\n:\n\n\n\nThese angle brackets are obtained by typing  and , respectively.\n\nLean provides another useful syntactic gadget. Given an expression\ne\n of an inductive type Foo\n (possibly applied to some\narguments), the notation e.bar\n is shorthand for Foo.bar e\n.\nThis provides a convenient way of accessing functions without opening\na namespace.  For example, the following two expressions mean the same\nthing:\n\n\n\nAs a result, given h : p ∧ q, we can write h.left\n for\nAnd.left h\n and h.right\n for And.right h\n. We can therefore\nrewrite the sample proof above conveniently as follows:\n\n\n\nThere is a fine line between brevity and obfuscation, and omitting\ninformation in this way can sometimes make a proof harder to read. But\nfor straightforward constructions like the one above, when the type of\nh and the goal of the construction are salient, the notation is\nclean and effective.\n\nIt is common to iterate constructions like “And.” Lean also allows you\nto flatten nested constructors that associate to the right, so that\nthese two proofs are equivalent:\n\n\n\nThis is often useful as well.\n\n","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs\u0009Propositional Logic","header":"3.3.1. Conjunction","id":"/Propositions-and-Proofs/#conjunction"},"/Propositions-and-Proofs/#disjunction":{"contents":"The expression Or.intro_left q hp\n creates a proof of p ∨ q\n\nfrom a proof hp : p. Similarly, Or.intro_right p hq\n creates a\nproof for p ∨ q\n using a proof hq : q. These are the left and\nright or-introduction rules.\n\n\n\nThe or-elimination rule is slightly more complicated. The idea is\nthat we can prove r\n from p ∨ q\n, by showing that r\n follows\nfrom p\n and that r\n follows from q\n.  In other words, it is a\nproof by cases. In the expression Or.elim hpq hpr hqr\n, Or.elim\n\ntakes three arguments, hpq : p ∨ q, hpr : p → r and\nhqr : q → r, and produces a proof of r\n. In the following example, we use\nOr.elim\n to prove p ∨ q → q ∨ p\n.\n\n\n\nIn most cases, the first argument of Or.intro_right\n and\nOr.intro_left\n can be inferred automatically by Lean. Lean\ntherefore provides Or.inr\n and Or.inl\n which can be viewed as\nshorthand for Or.intro_right _\n and Or.intro_left _\n. Thus the\nproof term above could be written more concisely:\n\n\n\nNotice that there is enough information in the full expression for\nLean to infer the types of hp and hq as well.  But using the\ntype annotations in the longer version makes the proof more readable,\nand can help catch and debug errors.\n\nBecause Or\n has two constructors, we cannot use anonymous\nconstructor notation. But we can still write h.elim\n instead of\nOr.elim h\n:\n\n\n\nOnce again, you should exercise judgment as to whether such\nabbreviations enhance or diminish readability.\n\n","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs\u0009Propositional Logic","header":"3.3.2. Disjunction","id":"/Propositions-and-Proofs/#disjunction"}});