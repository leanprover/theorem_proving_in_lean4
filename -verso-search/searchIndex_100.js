window.docContents[100].resolve({"/Quantifiers-and-Equality/#the-existential-quantifier":{"contents":"Finally, consider the existential quantifier, which can be written as\neither exists x : α, p x\n or ∃ x : α, p x\n.  Both versions are\nactually notationally convenient abbreviations for a more long-winded\nexpression, Exists (fun x : α => p x)\n, defined in Lean's library.\n\nAs you should by now expect, the library includes both an introduction\nrule and an elimination rule. The introduction rule is\nstraightforward: to prove ∃ x : α, p x\n, it suffices to provide a\nsuitable term t\n and a proof of p t\n. Here are some examples:\n\n\n\nWe can use the anonymous constructor notation ⟨t, h⟩\n for\nExists.intro t h\n, when the type is clear from the context.\n\n\n\nNote that Exists.intro\n has implicit arguments: Lean has to infer\nthe predicate p : α → Prop in the conclusion ∃ x, p x\n.  This\nis not a trivial affair. For example, if we have\nhg : g 0 0 = 0 and write Exists.intro 0 hg\n, there are many possible values\nfor the predicate p\n, corresponding to the theorems ∃ x, g x x = x\n,\n∃ x, g x x = 0\n, ∃ x, g x 0 = x\n, etc. Lean uses the\ncontext to infer which one is appropriate. This is illustrated in the\nfollowing example, in which we set the option pp.explicit to true\nto ask Lean's pretty-printer to show the implicit arguments.\n\n\n\nWe can view Exists.intro\n as an information-hiding operation, since\nit hides the witness to the body of the assertion. The existential\nelimination rule, Exists.elim\n, performs the opposite operation. It\nallows us to prove a proposition q\n from ∃ x : α, p x\n, by\nshowing that q\n follows from p w\n for an arbitrary value\nw\n. Roughly speaking, since we know there is an x\n satisfying\np x\n, we can give it a name, say, w\n. If q\n does not mention\nw\n, then showing that q\n follows from p w\n is tantamount to\nshowing that q\n follows from the existence of any such x\n. Here\nis an example:\n\n\n\nIt may be helpful to compare the exists-elimination rule to the\nor-elimination rule: the assertion ∃ x : α, p x\n can be thought of\nas a big disjunction of the propositions p a\n, as a\n ranges over\nall the elements of α\n. Note that the anonymous constructor\nnotation ⟨w, hw.right, hw.left⟩ abbreviates a nested constructor\napplication; we could equally well have written ⟨w, ⟨hw.right, hw.left⟩⟩.Notice that an existential proposition is very similar to a sigma\ntype, as described in dependent types section.  The difference is that\nexistential propositions are propositions, while sigma types are types.\nOtherwise, they are very similar. Given a predicate p : α → Prop and a family of types β : α → Type,\nfor a term a : α with h : p a and h' : β a\n, the term Exists.intro a h\n has\ntype (∃ x : α, p x) : Prop\n, while Sigma.mk a h'\n has type\n(Σ x : α, β x)\n. The similarity between ∃ and Σ is another\ninstance of the Curry-Howard isomorphism.\n\nLean provides a more convenient way to eliminate from an existential\nquantifier with the match expression:\n\n\n\nThe match expression is part of Lean's function definition system,\nwhich provides convenient and expressive ways of defining complex\nfunctions.  Once again, it is the Curry-Howard isomorphism that allows\nus to co-opt this mechanism for writing proofs as well.  The match\nstatement “destructs” the existential assertion into the components\nw and hw, which can then be used in the body of the statement\nto prove the proposition. We can annotate the types used in the match\nfor greater clarity:\n\n\n\nWe can even use the match statement to decompose the conjunction at the same time:\n\n\n\nLean also provides a pattern-matching let expression:\n\n\n\nThis is essentially just alternative notation for the match\nconstruct above. Lean will even allow us to use an implicit match\nin the fun expression:\n\n\n\nWe will see in Induction and Recursion that all these variations are\ninstances of a more general pattern-matching construct.\n\nIn the following example, we define IsEven a\n as ∃ b, a = 2 * b\n,\nand then we show that the sum of two even numbers is an even number.\n\n\n\nUsing the various gadgets described in this chapter—the match\nstatement, anonymous constructors, and the rewrite tactic, we can\nwrite this proof concisely as follows:\n\n\n\nJust as the constructive “or” is stronger than the classical “or,” so,\ntoo, is the constructive “exists” stronger than the classical\n“exists”. For example, the following implication requires classical\nreasoning because, from a constructive standpoint, knowing that it is\nnot the case that every x satisfies ¬ p is not the same as\nhaving a particular x that satisfies p.\n\nWhat follows are some common identities involving the existential\nquantifier. In the exercises below, we encourage you to prove as many\nas you can. We also leave it to you to determine which are\nnonconstructive, and hence require some form of classical reasoning.\n\n\n\nNotice that the second example and the last two examples require the\nassumption that there is at least one element a of type α.\n\nHere are solutions to two of the more difficult ones:\n\n\n\n","context":"Theorem Proving in Lean 4\u0009Quantifiers and Equality","header":"4.4. The Existential Quantifier","id":"/Quantifiers-and-Equality/#the-existential-quantifier"}});