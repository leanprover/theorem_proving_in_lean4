window.docContents[220].resolve({"/Dependent-Type-Theory/#types-as-objects":{"id":"/Dependent-Type-Theory/#types-as-objects","header":"2.2. Types as objects","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","contents":"One way in which Lean's dependent type theory extends simple type\ntheory is that types themselves—entities like Nat\n and Bool\n—are first-class citizens, which is to say that they themselves are\nobjects. For that to be the case, each of them also has to have a\ntype.\n\n\n\nYou can see that each one of the expressions above is an object of\ntype Type\n. You can also declare new constants for types:\n\n\n\nAs the example above suggests, you have already seen an example of a function of type\nType → Type → Type\n, namely, the Cartesian product Prod\n:\n\n\n\nHere is another example: given any type α, the type List α\ndenotes the type of lists of elements of type α.\n\nGiven that every expression in Lean has a type, it is natural to ask:\nwhat type does Type\n itself have?\n\n\n\nYou have actually come up against one of the most subtle aspects of\nLean's typing system. Lean's underlying foundation has an infinite\nhierarchy of types:\n\n\n\nThink of Type 0\n as a universe of “small” or “ordinary” types.\nType 1\n is then a larger universe of types, which contains Type 0\n\nas an element, and Type 2\n is an even larger universe of types,\nwhich contains Type 1\n as an element. The list is infinite:\nthere is a Type n\n for every natural number n\n. Type\n is\nan abbreviation for Type 0\n:\n\n\n\nThe following table may help concretize the relationships being discussed.\nMovement along the x-axis represents a change in the universe, while movement\nalong the y-axis represents a change in what is sometimes referred to as\n“degree”.\n\n* sort* Prop\n (Sort 0\n)* Type\n (Sort 1\n)* Type 1\n (Sort 2\n)* Type 2\n (Sort 3\n)* ...* type* True\n* Bool\n* Nat -> Type\n* Type -> Type 1\n* ...* term* True.intro\n* true\n* fun n => Fin n\n* fun (_ : Type) => Type\n* ...\n\nSome operations, however, need to be polymorphic over type\nuniverses. For example, List α\n should make sense for any type\nα\n, no matter which type universe α\n lives in. This explains the\ntype signature of the function List\n:Here u is a variable ranging over type levels. The output of the\n#check command means that whenever α\n has type Type u\n,\nList α\n also has type Type u\n. The function Prod\n is\nsimilarly polymorphic:\n\n\n\nTo define polymorphic constants, Lean allows you to\ndeclare universe variables explicitly using the universe command:\n\n\n\nYou can avoid the universe command by providing the universe parameters when defining F:\n\n"}});