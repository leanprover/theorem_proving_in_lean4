window.docContents[155].resolve({"/Inductive-Types/#inductive-types":{"id":"/Inductive-Types/#inductive-types","header":"7. Inductive Types","context":"Theorem Proving in Lean 4","contents":"We have seen that Lean's formal foundation includes basic types,\nProp\n, Type 0\n, Type 1\n, Type 2\n, ..., and allows for the formation of\ndependent function types, (x : α) → β\n. In the examples, we have\nalso made use of additional types like Bool\n, Nat\n, and Int\n,\nand type constructors, like List\n, and product, ×. In fact, in\nLean's library, every concrete type other than the universes and every\ntype constructor other than dependent arrows is an instance of a general family of\ntype constructions known as inductive types. It is remarkable that\nit is possible to construct a substantial edifice of mathematics based\non nothing more than the type universes, dependent arrow types, and inductive\ntypes; everything else follows from those.\n\nIntuitively, an inductive type is built up from a specified list of\nconstructors. In Lean, the syntax for specifying such a type is as\nfollows:\n\ninductive Foo where\n  | constructor₁ : ... → Foo\n  | constructor₂ : ... → Foo\n  ...\n  | constructorₙ : ... → Foo\nThe intuition is that each constructor specifies a way of building new\nobjects of Foo\n, possibly from previously constructed values. The\ntype Foo\n consists of nothing more than the objects that are\nconstructed in this way.We will see below that the arguments of the constructors can include\nobjects of type Foo\n, subject to a certain “positivity” constraint,\nwhich guarantees that elements of Foo\n are built from the bottom\nup. Roughly speaking, each ... can be any arrow type constructed from\nFoo\n and previously defined types, in which Foo\n appears, if at\nall, only as the “target” of the dependent arrow type.\n\nWe will provide a number of examples of inductive types. We will also\nconsider slight generalizations of the scheme above, to mutually\ndefined inductive types, and so-called inductive families.\n\nAs with the logical connectives, every inductive type comes with\nintroduction rules, which show how to construct an element of the\ntype, and elimination rules, which show how to “use” an element of the\ntype in another construction. The analogy to the logical connectives\nshould not come as a surprise; as we will see below, they, too, are\nexamples of inductive type constructions. You have already seen the\nintroduction rules for an inductive type: they are just the\nconstructors that are specified in the definition of the type. The\nelimination rules provide for a principle of recursion on the type,\nwhich includes, as a special case, a principle of induction as well.\n\nIn the next chapter, we will describe Lean's function definition\npackage, which provides even more convenient ways to define functions\non inductive types and carry out inductive proofs. But because the\nnotion of an inductive type is so fundamental, we feel it is important\nto start with a low-level, hands-on understanding. We will start with\nsome basic examples of inductive types, and work our way up to more\nelaborate and complex examples.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}});