window.docContents[9].resolve({"/Quantifiers-and-Equality/#calculational-proofs":{"id":"/Quantifiers-and-Equality/#calculational-proofs","header":"4.3. Calculational Proofs","context":"Theorem Proving in Lean 4\u0009Quantifiers and Equality","contents":"A calculational proof is just a chain of intermediate results that are\nmeant to be composed by basic principles such as the transitivity of\nequality. In Lean, a calculational proof starts with the keyword\ncalc, and has the following syntax:\n\ncalc\n  <expr>_0  'op_1'  <expr>_1  ':='  <proof>_1\n  '_'       'op_2'  <expr>_2  ':='  <proof>_2\n  ...\n  '_'       'op_n'  <expr>_n  ':='  <proof>_n\n\n\nNote that the calc relations all have the same indentation. Each\n<proof>_i is a proof for <expr>_{i-1} op_i <expr>_i.\n\nWe can also use _ in the first relation (right after <expr>_0)\nwhich is useful to align the sequence of relation/proof pairs:\n\ncalc <expr>_0\n    '_' 'op_1' <expr>_1 ':=' <proof>_1\n    '_' 'op_2' <expr>_2 ':=' <proof>_2\n    ...\n    '_' 'op_n' <expr>_n ':=' <proof>_n\n\n\nHere is an example:\n\n\n\nThis style of writing proofs is most effective when it is used in\nconjunction with the simp and rw tactics, which are\ndiscussed in greater detail in the next chapter. For example, using\nrw for rewrite, the proof above could be written\nas follows:\n\n\n\nEssentially, the rw tactic uses a given equality (which can be a\nhypothesis, a theorem name, or a complex term) to “rewrite” the\ngoal. If doing so reduces the goal to an identity t = t\n, the\ntactic applies reflexivity to prove it.\n\nRewrites can be applied sequentially, so that the proof above can be\nshortened to this:\n\n\n\nOr even this:\n\n\n\nThe simp tactic, instead, rewrites the goal by applying the given\nidentities repeatedly, in any order, anywhere they are applicable in a\nterm. It also uses other rules that have been previously declared to\nthe system, and applies commutativity wisely to avoid looping. As a\nresult, we can also prove the theorem as follows:\n\n\n\nWe will discuss variations of rw and simp in the next chapter.\n\nThe calc command can be configured for any relation that supports\nsome form of transitivity. It can even combine different relations.\n\n\n\nYou can “teach” calc new transitivity theorems by adding new instances\nof the Trans\n type class. Type classes are introduced later, but the following\nsmall example demonstrates how to extend the calc notation using new Trans\n instances.\n\n\n\nThe example above also makes it clear that you can use calc even if you do not have an infix\nnotation for your relation. Lean already includes the standard Unicode notation for divisibility\n(using ∣, which can be entered as  or ), so the example above uses the ordinary\nvertical bar to avoid a conflict. In practice, this is not a good idea, as it risks confusion with\nthe ASCII | used in the match ... with expression.\n\nWith calc, we can write the proof in the last section in a more\nnatural and perspicuous way.\n\n\n\nThe alternative calc notation is worth considering here. When the\nfirst expression is taking this much space, using _ in the first\nrelation naturally aligns all relations:\n\n\n\nHere the left arrow before Nat.add_assoc\n tells rewrite to use the\nidentity in the opposite direction. (You can enter it with  or\nuse the ASCII equivalent, <-.) If brevity is what we are after,\nboth rw and simp can do the job on their own:\n\n\n\n"},"/Interacting-with-Lean/#notations-and-precedence":{"id":"/Interacting-with-Lean/#notations-and-precedence","header":"6.7.1. Notations and Precedence","context":"Theorem Proving in Lean 4\u0009Interacting with Lean\u0009Notation","contents":"The most basic syntax extension commands allow introducing new (or\noverloading existing) prefix, infix, and postfix operators.\n\n\n\nAfter the initial command name describing the operator kind (its\n“fixity”), we give the parsing precedence of the operator preceded\nby a colon :, then a new or existing token surrounded by double\nquotes (the whitespace is used for pretty printing), then the function\nthis operator should be translated to after the arrow =>.\n\nThe precedence is a natural number describing how “tightly” an\noperator binds to its arguments, encoding the order of operations.  We\ncan make this more precise by looking at the commands the above unfold to:\n\n\n\nIt turns out that all commands from the first code block are in fact\ncommand macros translating to the more general notation command.\nWe will learn about writing such macros below.  Instead of a single\ntoken, the notation command accepts a mixed sequence of tokens and\nnamed term placeholders with precedences, which can be referenced on\nthe right-hand side of => and will be replaced by the respective\nterm parsed at that position. A placeholder with precedence p\n\naccepts only notations with precedence at least p\n in that place.\nThus the string a + b + c\n cannot be parsed as the equivalent of\na + (b + c)\n because the right-hand side operand of an infixl notation\nhas precedence one greater than the notation itself.  In contrast,\ninfixr reuses the notation's precedence for the right-hand side\noperand, so a ^ b ^ c\n can be parsed as a ^ (b ^ c)\n.  Note that\nif we used notation directly to introduce an infix notation like\n\n\n\nwhere the precedences do not sufficiently determine associativity,\nLean's parser will default to right associativity.  More precisely,\nLean's parser follows a local longest parse rule in the presence of\nambiguous grammars: when parsing the right-hand side of a ~ in\na ~ b ~ c\n, it will continue parsing as long as possible (as the current\nprecedence allows), not stopping after b but parsing ~ c as well.\nThus the term is equivalent to a ~ (b ~ c)\n.\n\nAs mentioned above, the notation command allows us to define\narbitrary mixfix syntax freely mixing tokens and placeholders.\n\n\n\nPlaceholders without precedence default to 0, i.e. they accept notations of any precedence in their place.\nIf two notations overlap, we again apply the longest parse rule:\n\n\n\nThe new notation is preferred to the binary notation since the latter,\nbefore chaining, would stop parsing after 1 + 2.  If there are\nmultiple notations accepting the same longest parse, the choice will\nbe delayed until elaboration, which will fail unless exactly one\noverload is type-correct.\n\n"}});