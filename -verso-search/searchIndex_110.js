window.docContents[110].resolve({"/Type-Classes/#managing-type-class-inference":{"id":"/Type-Classes/#managing-type-class-inference","header":"10.9. Managing Type Class Inference","context":"Theorem Proving in Lean 4\u0009Type Classes","contents":"If you are ever in a situation where you need to supply an expression\nthat Lean can infer by type class inference, you can ask Lean to carry\nout the inference using inferInstance:\n\n\n\nIn fact, you can use Lean's (t : T)\n notation to specify the class whose instance you are looking for,\nin a concise manner:\n\n\n\nYou can also use the auxiliary definition inferInstanceAs\n:\n\n\n\nSometimes Lean can't find an instance because the class is buried\nunder a definition. For example, Lean cannot\nfind an instance of Inhabited (Set α). We can declare one\nexplicitly:\n\nAt times, you may find that the type class inference fails to find an\nexpected instance, or, worse, falls into an infinite loop and times\nout. To help debug in these situations, Lean enables you to request a\ntrace of the search:\n\n\n\nIf you are using VS Code, you can read the results by hovering over\nthe relevant theorem or definition, or opening the messages window\nwith .\n\nYou can also limit the search using the following options:\n\n\n\nOption synthInstance.maxHeartbeats specifies the maximum amount of\nheartbeats per typeclass resolution problem. A heartbeat is the number of\n(small) memory allocations (in thousands), 0 means there is no limit.\nOption synthInstance.maxSize is the maximum number of instances used\nto construct a solution in the type class instance synthesis procedure.\n\nRemember also that in both the VS Code and Emacs editor modes, tab\ncompletion works in set_option, to help you find suitable options.\n\nAs noted above, the type class instances in a given context represent\na Prolog-like program, which gives rise to a backtracking search. Both\nthe efficiency of the program and the solutions that are found can\ndepend on the order in which the system tries the instance. Instances\nwhich are declared last are tried first. Moreover, if instances are\ndeclared in other modules, the order in which they are tried depends\non the order in which namespaces are opened. Instances declared in\nnamespaces which are opened later are tried earlier.\n\nYou can change the order that type class instances are tried by\nassigning them a priority. When an instance is declared, it is\nassigned a default priority value. You can assign other priorities\nwhen defining an instance. The following example illustrates how this\nis done:\n\n\n\n"},"/Tactics/#Theorem-Proving-in-Lean-4--Tactics--Exercises":{"id":"/Tactics/#Theorem-Proving-in-Lean-4--Tactics--Exercises","header":"5.10. Exercises","context":"Theorem Proving in Lean 4\u0009Tactics","contents":"1. Go back to the exercises in Propositions and Proofs and\nQuantifiers and Equality and\nredo as many as you can now with tactic proofs, using also rw\nand simp as appropriate.2. Use tactic combinators to obtain a one-line proof of the following:\n\n\n\n"},"/Propositions-and-Proofs/#propositional-logic":{"id":"/Propositions-and-Proofs/#propositional-logic","header":"3.3. Propositional Logic","context":"Theorem Proving in Lean 4\u0009Propositions and Proofs","contents":"Lean defines all the standard logical connectives and notation. The propositional connectives come with the following notation:\n\n* ASCII* Unicode* Editor shortcut* Definition* True\n* * * True\n* False\n* * * False\n* Not\n* ¬* , * Not\n* /\\* ∧* * And\n* \\/* ∨* * Or\n* ->* →* , , * * <->* ↔* , * Iff\n\n\nThey all take values in Prop\n.\n\n\n\nThe order of operations is as follows: unary negation ¬ binds most\nstrongly, then ∧, then ∨, then →, and finally ↔. For\nexample, a ∧ b → c ∨ d ∧ e\n means (a ∧ b) → (c ∨ (d ∧ e))\n.\nRemember that → associates to the right (nothing changes\nnow that the arguments are elements of Prop\n, instead of some other\nType\n), as do the other binary connectives. So if we have\np q r : Prop, the expression p → q → r\n reads “if p\n, then if q\n,\nthen r\n.” This is just the “curried” form of p ∧ q → r\n.\n\nIn the last chapter we observed that lambda abstraction can be viewed\nas an “introduction rule” for →. In the current setting, it shows\nhow to “introduce” or establish an implication. Application can be\nviewed as an “elimination rule,” showing how to “eliminate” or use an\nimplication in a proof. The other propositional connectives are\ndefined in Lean's library, and are automatically imported. Each connective\ncomes with its canonical introduction and elimination rules.\n\n\n\n\n\n\n\n\n\n"}});