window.docContents[248].resolve({"/Induction-and-Recursion/#inaccessible-patterns":{"contents":"Sometimes an argument in a dependent matching pattern is not essential\nto the definition, but nonetheless has to be included to specialize\nthe type of the expression appropriately. Lean allows users to mark\nsuch subterms as inaccessible for pattern matching. These\nannotations are essential, for example, when a term occurring in the\nleft-hand side is neither a variable nor a constructor application,\nbecause these are not suitable targets for pattern matching. We can\nview such inaccessible patterns as “don't care” components of the\npatterns. You can declare a subterm inaccessible by writing\n.(t). If the inaccessible pattern can be inferred, you can also write\n_.\n\nThe following example, we declare an inductive type that defines the\nproperty of “being in the image of f”. You can view an element of\nthe type ImageOf f b as evidence that b is in the image of\nf, whereby the constructor imf is used to build such\nevidence. We can then define any function f with an “inverse”\nwhich takes anything in the image of f to an element that is\nmapped to it. The typing rules forces us to write f a for the\nfirst argument, but this term is neither a variable nor a constructor\napplication, and plays no role in the pattern-matching definition. To\ndefine the function inverse below, we have to mark f a\ninaccessible.\n\nIn the example above, the inaccessible annotation makes it clear that\nf is not a pattern matching variable.\n\nInaccessible patterns can be used to clarify and control definitions that\nmake use of dependent pattern matching. Consider the following\ndefinition of the function Vect.add, which adds two vectors of\nelements of a type, assuming that type has an associated addition\nfunction:\n\nThe argument {n : Nat} appear after the colon, because it cannot\nbe held fixed throughout the definition.  When implementing this\ndefinition, the equation compiler starts with a case distinction as to\nwhether the first argument is 0 or of the form n+1.  This is\nfollowed by nested case splits on the next two arguments, and in each\ncase the equation compiler rules out the cases are not compatible with\nthe first pattern.\n\nBut, in fact, a case split is not required on the first argument; the\ncasesOn eliminator for Vect automatically abstracts this\nargument and replaces it by 0 and n + 1 when we do a case\nsplit on the second argument. Using inaccessible patterns, we can prompt\nthe equation compiler to avoid the case split on n.\n\n\n\nMarking the position as an inaccessible pattern tells the\nequation compiler first, that the form of the argument should be\ninferred from the constraints posed by the other arguments, and,\nsecond, that the first argument should not participate in pattern\nmatching.\n\nThe inaccessible pattern .(_) can be written as _ for convenience.\n\n\n\nAs we mentioned above, the argument {n : Nat} is part of the\npattern matching, because it cannot be held fixed throughout the\ndefinition. Rather than requiring that these discriminants be provided explicitly, Lean implicitly includes\nthese extra discriminants automatically for us.\n\n\n\nWhen combined with the auto bound implicits feature, you can simplify\nthe declare further and write:\n\n\n\nUsing these new features, you can write the other vector functions defined\nin the previous sections more compactly as follows:\n\n\n\n","context":"Theorem Proving in Lean 4\u0009Induction and Recursion","header":"8.9. Inaccessible Patterns","id":"/Induction-and-Recursion/#inaccessible-patterns"},"/Type-Classes/#default-instances":{"contents":"In the class HMul, the parameters α and β are treated as input values.\nThus, type class synthesis only starts after these two types are known. This may often\nbe too restrictive.\n\n\n\nThe instance HMul is not synthesized by Lean because the type of y has not been provided.\nHowever, it is natural to assume that the type of y and x should be the same in\nthis kind of situation. We can achieve exactly that using default instances.\n\n\n\nBy tagging the instance above with the attribute [default_instance], we are instructing Lean\nto use this instance on pending type class synthesis problems.\nThe actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.\nMoreover, a + b\n, a * b\n, a - b\n, a / b\n, and a % b\n are notations for the heterogeneous versions.\nThe instance OfNat Nat n\n is the default instance (with priority 100) for the OfNat\n class. This is why the numeral\n2\n has type Nat\n when the expected type is not known. You can define default instances with higher\npriority to override the builtin ones.\n\n\n\nPriorities are also useful to control the interaction between different default instances.\nFor example, suppose xs\n has type List α\n. When elaborating xs.map (fun x => 2 * x)\n, we want the homogeneous instance for multiplication\nto have higher priority than the default instance for OfNat α 2\n. This is particularly important when we have implemented only the instance\nHMul α α α\n, and did not implement HMul Nat α α\n.\nNow, we reveal how the notation a * b is defined in Lean.\n\n\n\nThe Mul class is convenient for types that only implement the homogeneous multiplication.\n\n","context":"Theorem Proving in Lean 4\u0009Type Classes","header":"10.5. Default Instances","id":"/Type-Classes/#default-instances"}});