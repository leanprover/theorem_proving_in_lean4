window.docContents[214].resolve({"/Interacting-with-Lean/#attributes":{"contents":"The main function of Lean is to translate user input to formal\nexpressions that are checked by the kernel for correctness and then\nstored in the environment for later use. But some commands have other\neffects on the environment, either assigning attributes to objects in\nthe environment, defining notation, or declaring instances of type\nclasses, as described in the chapter on type classes. Most of\nthese commands have global effects, which is to say, they remain\nin effect not only in the current file, but also in any file that\nimports it. However, such commands often support the local modifier,\nwhich indicates that they only have effect until\nthe current section or namespace is closed, or until the end\nof the current file.\n\nIn Using the Simplifier,\nwe saw that theorems can be annotated with the [simp] attribute,\nwhich makes them available for use by the simplifier.\nThe following example defines the prefix relation on lists,\nproves that this relation is reflexive, and assigns the [simp] attribute to that theorem.\n\n\n\nThe simplifier then proves isPrefix [1, 2, 3] [1, 2, 3] by rewriting it to True\n.\n\nOne can also assign the attribute any time after the definition takes place:\n\n\n\nIn all these cases, the attribute remains in effect in any file that\nimports the one in which the declaration occurs. Adding the local\nmodifier restricts the scope:\n\n\n\nFor another example, we can use the instance command to assign the\nnotation ≤ to the isPrefix relation. That command, which will\nbe explained in the chapter on type classes, works by\nassigning an [instance] attribute to the associated definition.\n\nThat assignment can also be made local:\n\n\n\nIn Notation below, we will discuss Lean's\nmechanisms for defining notation, and see that they also support the\nlocal modifier. However, in Setting Options, we will\ndiscuss Lean's mechanisms for setting options, which does not follow\nthis pattern: options can only be set locally, which is to say,\ntheir scope is always restricted to the current section or current\nfile.\n\n","context":"Theorem Proving in Lean 4\u0009Interacting with Lean","header":"6.5. Attributes","id":"/Interacting-with-Lean/#attributes"},"/Quantifiers-and-Equality/#more-on-the-proof-language":{"contents":"We have seen that keywords like fun, have, and show make\nit possible to write formal proof terms that mirror the structure of\ninformal mathematical proofs. In this section, we discuss some\nadditional features of the proof language that are often convenient.\n\nTo start with, we can use anonymous have expressions to introduce an\nauxiliary goal without having to label it. We can refer to the last\nexpression introduced in this way using the keyword this:\n\n\n\nOften proofs move from one fact to the next, so this can be effective\nin eliminating the clutter of lots of labels.\n\nWhen the goal can be inferred, we can also ask Lean instead to fill in\nthe proof by writing by assumption:\n\n\n\nThis tells Lean to use the assumption tactic, which, in turn,\nproves the goal by finding a suitable hypothesis in the local\ncontext. We will learn more about the assumption tactic in the\nnext chapter.\n\nWe can also ask Lean to fill in the proof by writing ‹p›\n, where\np\n is the proposition whose proof we want Lean to find in the\ncontext.  You can type these corner quotes using  and ,\nrespectively. The letter “f” is for “French,” since the Unicode\nsymbols can also be used as French quotation marks. In fact, the\nnotation is defined in Lean as follows:\n\n\n\nThis approach is more robust than using by assumption, because the\ntype of the assumption that needs to be inferred is given\nexplicitly. It also makes proofs more readable. Here is a more\nelaborate example:\n\n\n\nKeep in mind that you can use the French quotation marks in this way\nto refer to anything in the context, not just things that were\nintroduced anonymously. Its use is also not limited to propositions,\nthough using it for data is somewhat odd:\n\n\n\nLater, we show how you can extend the proof language using the Lean macro system.\n\n","context":"Theorem Proving in Lean 4\u0009Quantifiers and Equality","header":"4.5. More on the Proof Language","id":"/Quantifiers-and-Equality/#more-on-the-proof-language"}});