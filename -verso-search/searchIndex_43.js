window.docContents[43].resolve({"/Dependent-Type-Theory/#definitions":{"id":"/Dependent-Type-Theory/#definitions","header":"2.4. Definitions","context":"Theorem Proving in Lean 4\u0009Dependent Type Theory","contents":"Recall that the def keyword provides one important way of declaring new named\nobjects.\n\n\n\nThis might look more familiar to you if you know how functions work in\nother programming languages. The name double is defined as a\nfunction that takes an input parameter x of type Nat\n, where the\nresult of the call is x + x, so it is returning type Nat\n. You\ncan then invoke this function using:\n\n\n\nIn this case you can think of def as a kind of named fun.\nThe following yields the same result:\n\n\n\nYou can omit the type declarations when Lean has enough information to\ninfer it.  Type inference is an important part of Lean:\n\n\n\nThe general form of a definition is def foo : α := bar where\nα is the type returned from the expression bar.  Lean can\nusually infer the type α, but it is often a good idea to write it\nexplicitly.  This clarifies your intention, and Lean will flag an\nerror if the right-hand side of the definition does not have a matching\ntype.\n\nThe right hand side bar can be any expression, not just a lambda.\nSo def can also be used to simply name a value like this:\n\n\n\ndef can take multiple input parameters.  Let's create one\nthat adds two natural numbers:\n\n\n\nThe parameter list can be separated like this:\n\n\n\nNotice here we called the double function to create the first\nparameter to add.\n\nYou can use other more interesting expressions inside a def:\n\n\n\nYou can probably guess what this one will do.\n\nYou can also define a function that takes another function as input.\nThe following calls a given function twice passing the output of the\nfirst invocation to the second:\n\n\n\nNow to get a bit more abstract, you can also specify arguments that\nare like type parameters:\n\n\n\nThis means compose is a function that takes any two functions as input\narguments, so long as those functions each take only one input.\nThe type algebra β → γ and α → β means it is a requirement\nthat the type of the output of the second function must match the\ntype of the input to the first function—which makes sense, otherwise\nthe two functions would not be composable.\n\ncompose also takes a 3rd argument of type α which\nit uses to invoke the second function (locally named f) and it\npasses the result of that function (which is type β) as input to the\nfirst function (locally named g).  The first function returns a type\nγ so that is also the return type of the compose function.\n\ncompose is also very general in that it works over any type\nα β γ.  This means compose can compose just about any 2 functions\nso long as they each take one parameter, and so long as the type of\noutput of the second matches the input of the first.  For example:\n\n\n\n"}});