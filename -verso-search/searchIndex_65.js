window.docContents[65].resolve({"/Tactics/#using-the-simplifier":{"contents":"Whereas rw is designed as a surgical tool for manipulating a\ngoal, the simplifier offers a more powerful form of automation. A\nnumber of identities in Lean's library have been tagged with the\n[simp] attribute, and the simp tactic uses them to iteratively\nrewrite subterms in an expression.\n\n\n\nIn the first example, the left-hand side of the equality in the goal\nis simplified using the usual identities involving 0 and 1, reducing\nthe goal to x * y = x * y. At that point, simp applies\nreflexivity to finish it off. In the second example, simp reduces\nthe goal to p (x * y), at which point the assumption h\nfinishes it off. Here are some more examples\nwith lists:\n\n\n\nAs with rw, you can use the keyword at to simplify a hypothesis:\n\n\n\nMoreover, you can use a “wildcard” asterisk to simplify all the hypotheses and the goal:\n\n\n\nFor operations that are commutative and associative, like\nmultiplication on the natural numbers, the simplifier uses these two\nfacts to rewrite an expression, as well as left commutativity. In\nthe case of multiplication the latter is expressed as follows:\nx * (y * z) = y * (x * z)\n. The local modifier tells the simplifier\nto use these rules in the current file (or section or namespace, as\nthe case may be). It may seem that commutativity and\nleft-commutativity are problematic, in that repeated application of\neither causes looping. But the simplifier detects identities that\npermute their arguments, and uses a technique known as ordered\nrewriting. This means that the system maintains an internal ordering\nof terms, and only applies the identity if doing so decreases the\norder. With the three identities mentioned above, this has the effect\nthat all the parentheses in an expression are associated to the right,\nand the expressions are ordered in a canonical (though somewhat\narbitrary) way. Two expressions that are equivalent up to\nassociativity and commutativity are then rewritten to the same\ncanonical form.\n\n\n\nAs with rw, you can send simp a list of facts to use,\nincluding general lemmas, local hypotheses, definitions to unfold, and\ncompound expressions. The simp tactic also recognizes the ←t\nsyntax that rewrite does. In any case, the additional rules are\nadded to the collection of identities that are used to simplify a\nterm.\n\n\n\nA common idiom is to simplify a goal using local hypotheses:\n\n\n\nTo use all the hypotheses present in the local context when\nsimplifying, we can use the wildcard symbol, *:\n\nHere is another example:\n\n\n\nThe simplifier will also do propositional rewriting. For example,\nusing the hypothesis p, it rewrites p ∧ q to q and p ∨ q to True\n,\nwhich it then proves trivially. Iterating such\nrewrites produces nontrivial propositional reasoning.\n\nThe next example simplifies all the hypotheses, and then uses them to prove the goal.\n\n\n\nOne thing that makes the simplifier especially useful is that its\ncapabilities can grow as a library develops. For example, suppose we\ndefine a list operation that symmetrizes its input by appending its\nreversal:\n\n\n\nThen for any list xs, (mk_symm xs).reverse is equal to mk_symm xs,\nwhich can easily be proved by unfolding the definition:\n\nWe can now use this theorem to prove new results:\n\n\n\nBut using reverse_mk_symm is generally the right thing to do, and\nit would be nice if users did not have to invoke it explicitly. You can\nachieve that by marking it as a simplification rule when the theorem\nis defined:\n\n\n\nThe notation @[simp] declares reverse_mk_symm to have the\n[simp] attribute, and can be spelled out more explicitly:\n\n\n\nThe attribute can also be applied any time after the theorem is declared:\n\n\n\nOnce the attribute is applied, however, there is no way to permanently\nremove it; it persists in any file that imports the one where the\nattribute is assigned. As we will discuss further in\nAttributes, one can limit the scope of an attribute to the\ncurrent file or section using the local modifier:\n\nOutside the section, the simplifier will no longer use\nreverse_mk_symm by default.\n\nNote that the various simp options we have discussed—giving an\nexplicit list of rules, and using at to specify the location—can be combined,\nbut the order they are listed is rigid. You can see the correct order\nin an editor by placing the cursor on the simp identifier to see\nthe documentation string that is associated with it.\n\nThere are two additional modifiers that are useful. By default,\nsimp includes all theorems that have been marked with the\nattribute [simp]. Writing simp only excludes these defaults,\nallowing you to use a more explicitly crafted list of\nrules. In the examples below, the minus sign and\nonly are used to block the application of reverse_mk_symm.\n\nThe simp tactic has many configuration options. For example, we can enable contextual simplifications as follows:\n\n\n\nWith +contextual, the simp tactic uses the fact that x = 0 when simplifying y + x = y, and\nx ≠ 0 when simplifying the other branch. Here is another example:\n\n\n\nAnother useful configuration option is +arith which enables arithmetical simplifications.\n\n","context":"Theorem Proving in Lean 4\u0009Tactics","header":"5.7. Using the Simplifier","id":"/Tactics/#using-the-simplifier"}});