window.docContents[75].resolve({"/Axioms-and-Computation/#the-law-of-the-excluded-middle":{"contents":"The law of the excluded middle is the following:\n\n\n\nDiaconescu's theorem states\nthat the axiom of choice is sufficient to derive the law of excluded\nmiddle. More precisely, it shows that the law of the excluded middle\nfollows from Classical.choice\n, propext\n, and funext\n. We\nsketch the proof that is found in the standard library.\n\n\n\nFirst, we import the necessary axioms, and define two predicates U and V:\n\nIf p is true, then every element of Prop\n is in both U and V.\nIf p is false, then U is the singleton True, and V is the singleton False.\n\nNext, we use choose to choose an element from each of U and V:\n\nEach of U and V is a disjunction, so u_def and v_def\nrepresent four cases. In one of these cases, u = True and\nv = False, and in all the other cases, p is true. Thus we have:\n\nOn the other hand, if p is true, then, by function extensionality\nand propositional extensionality, U and V are equal. By the\ndefinition of u and v, this implies that they are equal as well.\n\n\n\nPutting these last two facts together yields the desired conclusion:\n\n\n\nConsequences of excluded middle include double-negation elimination,\nproof by cases, and proof by contradiction, all of which are described\nin the section on classical logic.\nThe law of the excluded middle and propositional extensionality imply propositional completeness:\n\n\n\nTogether with choice, we also get the stronger principle that every\nproposition is decidable. Recall that the class of Decidable\n\npropositions is defined as follows:\n\n\n\nIn contrast to p ∨ ¬ p\n, which can only eliminate to Prop\n, the\ntype Decidable p\n is equivalent to the sum type Sum p (¬ p), which\ncan eliminate to any type. It is this data that is needed to write an\nif-then-else expression.As an example of classical reasoning, we use choose\n to show that if\nf : α → β is injective and α\n is inhabited, then f\n has a\nleft inverse. To define the left inverse linv, we use a dependent\nif-then-else expression. Recall that if h : c then t else e\n is\nnotation for dite c (fun h : c => t) (fun h : ¬ c => e)\n. In the definition\nof linv, choice is used twice: first, to show that\n(∃ a : α, f a = b) is “decidable,” and then to choose an a such that\nf a = b. Notice that propDecidable\n is a scoped instance and is activated\nby the open Classical command. We use this instance to justify\nthe if-then-else expression. (See also the discussion in\nDecidable Propositions).From a classical point of view, linv is a function. From a\nconstructive point of view, it is unacceptable; because there is no\nway to implement such a function in general, the construction is not\ninformative.\n\n","context":"Theorem Proving in Lean 4\u0009Axioms and Computation","header":"12.6. The Law of the Excluded Middle","id":"/Axioms-and-Computation/#the-law-of-the-excluded-middle"}});