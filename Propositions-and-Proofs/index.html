<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Propositions and Proofs</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <script src="-verso-data/copybutton.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <link rel="stylesheet" href="-verso-data/copybutton.css">
    <link rel="stylesheet" href="-verso-data/examples.css">
    <link rel="stylesheet" href="-verso-data/proof-state.css">
    <style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
code.unicode-abbrev {
  background-color: #eee;
  border-radius: 3px;
  border: 1px solid #ccc;
  white-space: nowrap;
}

kbd {
  white-space: nowrap;
}

kbd > code {
  background-color: #eee;
  border-radius: 3px;
  border: 1px solid #b4b4b4;
  box-shadow:
    0 1px 1px rgba(0, 0, 0, 0.2),
    0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
  color: #333;
  display: inline-block;
  font-size: 0.85em;
  font-weight: 700;
  line-height: 1;
  padding: 2px 4px;
  white-space: nowrap;
  vertical-align: middle;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><style>
a.technical-term {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}
a.technical-term:hover {
  text-decoration: currentcolor underline solid;
}

</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Theorem Proving in Lean 4</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Theorem Proving in Lean 4</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot" checked="checked"></label><span class="">Table of Contents</span></div>
              <table><tr class="numbered"><td class="num">1.</td><td><a href="Introduction/#Intro">Introduction</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Dependent-Type-Theory/#dependent-type-theory">Dependent Type Theory</a></td></tr><tr class="current numbered"><td class="num">3.</td><td><a href="Propositions-and-Proofs/#propositions-and-proofs">Propositions and Proofs</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Quantifiers-and-Equality/#quantifiers-and-equality">Quantifiers and Equality</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Tactics/#Theorem-Proving-in-Lean-4--Tactics">Tactics</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Interacting-with-Lean/#Theorem-Proving-in-Lean-4--Interacting-with-Lean">Interacting with Lean</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Inductive-Types/#inductive-types">Inductive Types</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Induction-and-Recursion/#induction-and-recursion">Induction and Recursion</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Structures-and-Records/#structures-and-records">Structures and Records</a></td></tr><tr class="numbered"><td class="num">10.</td><td><a href="Type-Classes/#type-classes">Type Classes</a></td></tr><tr class="numbered"><td class="num">11.</td><td><a href="The-Conversion-Tactic-Mode/#conv">The Conversion Tactic Mode</a></td></tr><tr class="numbered"><td class="num">12.</td><td><a href="Axioms-and-Computation/#axioms-and-computation">Axioms and Computation</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-propositions-and-proofs" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-propositions-and-proofs" checked="checked"></label><span class="number">3.</span> <span class="current"><a href="Propositions-and-Proofs/#propositions-and-proofs">Propositions and Proofs</a></span></div>
              <table><tr class="numbered"><td class="num">3.1.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositions-as-Types">Propositions as Types</a></td></tr><tr class="numbered"><td class="num">3.2.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Working-with-Propositions-as-Types">Working with Propositions as Types</a></td></tr><tr class="numbered"><td class="num">3.3.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositional-Logic">Propositional Logic</a></td></tr><tr class="numbered"><td class="num">3.4.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Introducing-Auxiliary-Subgoals">Introducing Auxiliary Subgoals</a></td></tr><tr class="numbered"><td class="num">3.5.</td><td><a href="Propositions-and-Proofs/#classical-logic">Classical Logic</a></td></tr><tr class="numbered"><td class="num">3.6.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Examples-of-Propositional-Validities">Examples of Propositional Validities</a></td></tr><tr class="numbered"><td class="num">3.7.</td><td><a href="Propositions-and-Proofs/#Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Exercises">Exercises</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/theorem_proving_in_lean4">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/theorem_proving_in_lean4/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Dependent-Type-Theory/#dependent-type-theory" rel="prev" title="2. Dependent Type Theory"><span class="arrow">←</span><span class="where">2. Dependent Type Theory</span></a><a class="local-button active" href="Quantifiers-and-Equality/#quantifiers-and-equality" rel="next" title="4. Quantifiers and Equality"><span class="where">4. Quantifiers and Equality</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              3. Propositions and Proofs<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=propositions-and-proofs" title="Permalink">🔗</a></span></h1>
            <p>
              By now, you have seen some ways of defining objects and functions in
Lean. In this chapter, we will begin to explain how to write
mathematical assertions and proofs in the language of dependent type
theory as well.</p>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositions-as-Types">
                3.1. Propositions as Types</h2>
              <p>
                One strategy for proving assertions about objects defined in the
language of dependent type theory is to layer an assertion language
and a proof language on top of the definition language. But there is
no reason to multiply languages in this way: dependent type theory is
flexible and expressive, and there is no reason we cannot represent
assertions and proofs in the same general framework.</p>
              <p>
                For example, we could introduce a new type, <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, to represent
propositions, and introduce constructors to build new propositions
from others.</p>
              <div class="example" id="--verso-unique-61">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">And (a b : Prop) : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-50">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a></code><div class="information">
                  <pre>And (a b : Prop) : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Or (a b : Prop) : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-93">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or in Lean Language Reference"><span class="const token" data-binding="const-Or" data-verso-hover="139">Or</span></a></code><div class="information">
                  <pre>Or (a b : Prop) : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Not (a : Prop) : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-135">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not in Lean Language Reference"><span class="const token" data-binding="const-Not" data-verso-hover="140">Not</span></a></code><div class="information">
                  <pre>Not (a : Prop) : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Implies (p q : Prop) : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-176">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span></code><div class="information">
                  <pre>Implies (p q : Prop) : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-223" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">p ∧ q : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-248">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">q</span></code><div class="information">
                  <pre>p ∧ q : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">p ∧ q ∨ r : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-303">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or in Lean Language Reference"><span class="const token" data-binding="const-Or" data-verso-hover="139">Or</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="1">r</span></code><div class="information">
                  <pre>p ∧ q ∨ r : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Implies (p ∧ q) (q ∧ p) : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-364">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                  <pre>Implies (p ∧ q) (q ∧ p) : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-61", "def Implies (p q : Prop) : Prop := p → q\ndef Implies (p q : Prop) : Prop := p → q\n#check And#check Or#check Not#check Impliesvariable (p q r : Prop)\n\n#check And p q#check Or (And p q) r#check Implies (And p q) (And q p)");
addToggleButtonToElement("--verso-unique-61");</script>
              <p>
                We could then introduce, for each element <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.259" data-verso-hover="1">p</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, another type
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.292" data-verso-hover="1">p</span></code>, for the type of proofs of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.308" data-verso-hover="1">p</span></code>.  An “axiom” would be a
constant of such a type.</p>
              <div class="example" id="--verso-unique-62">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-43">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-77">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Proof.proof" data-verso-hover="142">proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Proof (p : Prop) : Type</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-102">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span></code><div class="information">
                  <pre>Proof (p : Prop) : Type</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-145">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-and_commut" data-verso-hover="143">and_commut</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-214" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.226" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.228" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">and_commut p q : Proof (Implies (p ∧ q) (q ∧ p))</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-237">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-and_commut" data-verso-hover="143">and_commut</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.226" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span></code><div class="information">
                  <pre>and_commut p q : Proof (Implies (p ∧ q) (q ∧ p))</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-62", "def Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\ndef Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\n#check Proofaxiom and_commut (p q : Prop) : Proof (Implies (And p q) (And q p))\n\nvariable (p q : Prop)\n\n#check and_commut p q");
addToggleButtonToElement("--verso-unique-62");</script>
              <p>
                In addition to axioms, however, we would also need rules to build new
proofs from old ones. For example, in many proof systems for
propositional logic, we have the rule of <em>modus ponens</em>:</p>
              <blockquote><p>
                  From a proof of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.324" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.328" data-verso-hover="1">q</span></code> and a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.340" data-verso-hover="1">p</span></code>, we obtain a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.360" data-verso-hover="1">q</span></code>.</p>
                </blockquote><p>
                We could represent this as follows:</p>
              <div class="example" id="--verso-unique-63">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-43">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-77">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Proof.proof" data-verso-hover="142">proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-102">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-modus_ponens" data-verso-hover="144">modus_ponens</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-63", "def Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\ndef Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\naxiom modus_ponens (p q : Prop) :\n  Proof (Implies p q) → Proof p →\n  Proof q\n");
addToggleButtonToElement("--verso-unique-63");</script>
              <p>
                Systems of natural deduction for propositional logic also typically rely on the following rule:</p>
              <blockquote><p>
                  Suppose that, assuming <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.372" data-verso-hover="1">p</span></code> as a hypothesis, we have a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.392" data-verso-hover="1">q</span></code>. Then we can “cancel” the hypothesis and obtain a proof of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.404" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.408" data-verso-hover="1">q</span></code>.</p>
                </blockquote><p>
                We could render this as follows:</p>
              <div class="example" id="--verso-unique-64">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-43">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-77">where</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Proof.proof" data-verso-hover="142">proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="1">p</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-102">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-implies_intro" data-verso-hover="145">implies_intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.221" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.223" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-64", "def Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\ndef Implies (p q : Prop) : Prop := p → q\nstructure Proof (p : Prop) : Type where\n  proof : p\naxiom implies_intro (p q : Prop) :\n  (Proof p → Proof q) → Proof (Implies p q)\n");
addToggleButtonToElement("--verso-unique-64");</script>
              <p>
                This approach would provide us with a reasonable way of building assertions and proofs.
Determining that an expression <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.422" data-verso-hover="4">t</span></code> is a correct proof of assertion <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.436" data-verso-hover="1">p</span></code> would then
simply be a matter of checking that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.454" data-verso-hover="4">t</span></code> has type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.468" data-verso-hover="1">p</span></code>.</p>
              <p>
                Some simplifications are possible, however. To start with, we can
avoid writing the term <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span></code> repeatedly by conflating <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Proof" data-verso-hover="141">Proof</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.501" data-verso-hover="1">p</span></code>
with <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.517" data-verso-hover="1">p</span></code> itself. In other words, whenever we have <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.533" data-verso-hover="1">p</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, we
can interpret <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.566" data-verso-hover="1">p</span></code> as a type, namely, the type of its proofs. We can
then read <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.584" data-verso-hover="4">t</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.599" data-verso-hover="1">p</span></code> as the assertion that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.617" data-verso-hover="4">t</span></code> is a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.631" data-verso-hover="1">p</span></code>.</p>
              <p>
                Moreover, once we make this identification, the rules for implication
show that we can pass back and forth between <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.647" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.651" data-verso-hover="1">q</span></code> and
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.663" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.667" data-verso-hover="1">q</span></code>. In other words, implication between propositions <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.683" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.703" data-verso-hover="1">q</span></code>
corresponds to having a function that takes any element of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.715" data-verso-hover="1">p</span></code> to an
element of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.735" data-verso-hover="1">q</span></code>. As a result, the introduction of the connective
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Implies" data-verso-hover="137">Implies</span></code> is entirely redundant: we can use the usual function space
constructor <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.765" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.769" data-verso-hover="1">q</span></code> from dependent type theory as our notion of
implication.</p>
              <p>
                This is the approach followed in the Calculus of Constructions, and
hence in Lean as well. The fact that the rules for implication in a
proof system for natural deduction correspond exactly to the rules
governing abstraction and application for functions is an instance of
the <span id="--tech-term-Curry-Howard-isomorphism" class="def-technical-term"><em>Curry-Howard isomorphism</em></span>, sometimes known as the
<span id="--tech-term-propositions-as-types" class="def-technical-term"><em>propositions-as-types</em></span> paradigm. In fact, the type <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code> is
syntactic sugar for <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="38">Sort</span><span class="inter-text"> </span><span class="level-const token" data-binding="level-const-0" data-verso-hover="36">0</span></code>, the very bottom of the type hierarchy
described in the last chapter. Moreover, <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span><span class="inter-text"> </span><span class="level-var token" data-binding="level-var-u" data-verso-hover="43">u</span></code> is also just
syntactic sugar for <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-112978979043057490" data-verso-hover="38">Sort</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="level-var token" data-binding="level-var-u" data-verso-hover="43">u</span><span class="level-op token" data-binding="level-op-+">+</span><span class="level-const token" data-binding="level-const-1" data-verso-hover="32">1</span><span class="unknown token" data-binding="">)</span></code>. <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code> has some special
features, but like the other type universes, it is closed under the
arrow constructor: if we have <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.865" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.886" data-verso-hover="1">q</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.915" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.919" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>.</p>
              <p>
                There are at least two ways of thinking about propositions as
types. To some who take a constructive view of logic and mathematics,
this is a faithful rendering of what it means to be a proposition: a
proposition <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.936" data-verso-hover="1">p</span></code> represents a sort of data type, namely, a
specification of the type of data that constitutes a proof. A proof of
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.952" data-verso-hover="1">p</span></code> is then simply an object <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.970" data-verso-hover="4">t</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.985" data-verso-hover="1">p</span></code> of the right type.</p>
              <p>
                Those not inclined to this ideology can view it, rather, as a simple
coding trick. To each proposition <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1001" data-verso-hover="1">p</span></code> we associate a type that is
empty if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1017" data-verso-hover="1">p</span></code> is false and has a single element, say <code>*</code>, if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1033" data-verso-hover="1">p</span></code>
is true. In the latter case, let us say that (the type associated
with) <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1049" data-verso-hover="1">p</span></code> is <em>inhabited</em>. It just so happens that the rules for
function application and abstraction can conveniently help us keep
track of which elements of <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code> are inhabited. So constructing an
element <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1083" data-verso-hover="4">t</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.1098" data-verso-hover="1">p</span></code> tells us that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1114" data-verso-hover="1">p</span></code> is indeed true. You can think of
the inhabitant of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1130" data-verso-hover="1">p</span></code> as being the “fact that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1146" data-verso-hover="1">p</span></code> is true.” A
proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1162" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1166" data-verso-hover="1">q</span></code> uses “the fact that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1182" data-verso-hover="1">p</span></code> is true” to obtain “the
fact that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1202" data-verso-hover="1">q</span></code> is true.”</p>
              <p>
                Indeed, if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1214" data-verso-hover="1">p</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code> is any proposition, Lean's kernel treats any
two elements <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1255" data-verso-hover="4">t1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1274" data-verso-hover="4">t2</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="1">p</span></code> as being definitionally equal, much the
same way as it treats <code>(fun x =&gt; t) s</code> and <code>t[s/x]</code> as
definitionally equal. This is known as <span id="--tech-term-proof-irrelevance" class="def-technical-term"><em>proof irrelevance</em></span>, and is
consistent with the interpretation in the last paragraph. It means
that even though we can treat proofs <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1299" data-verso-hover="4">t</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.1314" data-verso-hover="1">p</span></code> as ordinary objects in
the language of dependent type theory, they carry no information
beyond the fact that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1330" data-verso-hover="1">p</span></code> is true.</p>
              <p>
                The two ways we have suggested thinking about the
<a class="technical-term" href="Propositions-and-Proofs/#--tech-term-propositions-as-types">propositions-as-types</a> paradigm differ in a fundamental way. From the
constructive point of view, proofs are abstract mathematical objects
that are <em>denoted</em> by suitable expressions in dependent type
theory. In contrast, if we think in terms of the coding trick
described above, then the expressions themselves do not denote
anything interesting. Rather, it is the fact that we can write them
down and check that they are well-typed that ensures that the
proposition in question is true. In other words, the expressions
<em>themselves</em> are the proofs.</p>
              <p>
                In the exposition below, we will slip back and forth between these two
ways of talking, at times saying that an expression “constructs” or
“produces” or “returns” a proof of a proposition, and at other times
simply saying that it “is” such a proof. This is similar to the way
that computer scientists occasionally blur the distinction between
syntax and semantics by saying, at times, that a program “computes” a
certain function, and at other times speaking as though the program
“is” the function in question.</p>
              <p>
                In any case, all that really matters is the bottom line. To formally
express a mathematical assertion in the language of dependent type
theory, we need to exhibit a term <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1346" data-verso-hover="1">p</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>. To <em>prove</em> that
assertion, we need to exhibit a term <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1381" data-verso-hover="4">t</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.1396" data-verso-hover="1">p</span></code>. Lean's task, as a
proof assistant, is to help us to construct such a term, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1414" data-verso-hover="4">t</span></code>, and to
verify that it is well-formed and has the correct type.</p>
              </section>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Working-with-Propositions-as-Types">
                3.2. Working with Propositions as Types</h2>
              <p>
                In the <a class="technical-term" href="Propositions-and-Proofs/#--tech-term-propositions-as-types">propositions-as-types</a> paradigm, theorems involving only <code>→</code>
can be proved using lambda abstraction and application. In Lean, the
<code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">theorem</span></code> command introduces a new theorem:</p>
              <div class="example" id="--verso-unique-65">
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">---
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-44" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-64" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-85">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-115">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-129">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-65", "set_option linter.unusedVariables false\n---\nvariable {p : Prop}\nvariable {q : Prop}\n\ntheorem t1 : p → q → p := fun hp : p => fun hq : q => hp\n");</script>
              <p>
                Compare this proof to the expression <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1444" data-verso-hover="24">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1440" data-verso-hover="42">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-16">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1446" data-verso-hover="47">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1442" data-verso-hover="149">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1444" data-verso-hover="24">x</span></code>
of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1464" data-verso-hover="42">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1466" data-verso-hover="149">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1464" data-verso-hover="42">α</span></code>, where <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1488" data-verso-hover="42">α</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1506" data-verso-hover="149">β</span></code> are data types.
This describes the function that takes arguments <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1444" data-verso-hover="24">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1446" data-verso-hover="47">y</span></code>
of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1520" data-verso-hover="42">α</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1538" data-verso-hover="149">β</span></code>, respectively, and returns <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1444" data-verso-hover="24">x</span></code>.
The proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1548" data-verso-hover="4">t1</span></code> has the same form, the only difference being that
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1556" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1576" data-verso-hover="1">q</span></code> are elements of <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code> rather than <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span></code>.
Intuitively, our proof of
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1620" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1624" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1620" data-verso-hover="1">p</span></code> assumes <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1644" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1664" data-verso-hover="1">q</span></code> are true, and uses the first
hypothesis (trivially) to establish that the conclusion, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1676" data-verso-hover="1">p</span></code>, is
true.</p>
              <p>
                Note that the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">theorem</span></code> command is really a version of the
<code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code> command: under the propositions and types
correspondence, proving the theorem <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1696" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1692" data-verso-hover="1">p</span></code> is really the same
as defining an element of the associated type. To the kernel type
checker, there is no difference between the two.</p>
              <p>
                There are a few pragmatic differences between definitions and
theorems, however. In normal circumstances, it is never necessary to
unfold the “definition” of a theorem; by <a class="technical-term" href="Propositions-and-Proofs/#--tech-term-proof-irrelevance">proof irrelevance</a>, any two
proofs of that theorem are definitionally equal. Once the proof of a
theorem is complete, typically we only need to know that the proof
exists; it doesn't matter what the proof is. In light of that fact,
Lean tags proofs as <em>irreducible</em>, which serves as a hint to the
parser (more precisely, the <em>elaborator</em>) that there is generally no
need to unfold them when processing a file. In fact, Lean is generally
able to process and check proofs in parallel, since assessing the
correctness of one proof does not require knowing the details of
another. Additionally, <a href="Dependent-Type-Theory/#variables-and-sections">section variables</a>
that are referred to in the body of a definition are automatically added as
parameters, but only the variables referred to in a theorem's type are added.
This is because the way in which a statement is proved should not influence
the statement that is being proved.</p>
              <p>
                As with definitions, the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">#print</span></code> command will show you the proof of
a theorem:</p>
              <div class="example" id="--verso-unique-66">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-40" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-60" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-87">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-117">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-131">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-149">#print</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">t1</span></code><div class="information">
                  <pre>theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-66", "set_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\nset_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\ntheorem t1 : p → q → p := fun hp : p => fun hq : q => hp\n\n#print t1");
addToggleButtonToElement("--verso-unique-66");</script>
              <p>
                Notice that the lambda abstractions <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span></code> can be
viewed as temporary assumptions in the proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1724" data-verso-hover="4">t1</span></code>.  Lean also
allows us to specify the type of the final term <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span></code>, explicitly,
with a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">show</span></code> statement:</p>
              <div class="example" id="--verso-unique-67">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-40" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-60" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-87">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-119">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-135">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-151">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-158">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-67", "set_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\nset_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\ntheorem t1 : p → q → p :=\n  fun hp : p =>\n  fun hq : q =>\n  show p from hp\n");
addToggleButtonToElement("--verso-unique-67");</script>
              <p>
                Adding such extra information can improve the clarity of a proof and
help detect errors when writing a proof. The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">show</span></code> command does
nothing more than annotate the type, and, internally, all the
presentations of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span></code> that we have seen produce the same term.</p>
              <p>
                As with ordinary definitions, we can move the lambda-abstracted
variables to the left of the colon:</p>
              <div class="example" id="--verso-unique-68">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-40" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-60" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-87">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">hp</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-127">#print</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">t1</span></code><div class="information">
                  <pre>theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-68", "set_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\nset_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\ntheorem t1 (hp : p) (hq : q) : p := hp\n\n#print t1");
addToggleButtonToElement("--verso-unique-68");</script>
              <p>
                We can use the theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span></code> just as a function application:</p>
              <div class="example" id="--verso-unique-69">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-40" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-60" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-87">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="4">hp</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-127">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-hp" data-verso-hover="151">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-141">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t2" data-verso-hover="152">t2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span><span class="inter-text"> </span><span class="const token" data-binding="const-hp" data-verso-hover="151">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-69", "set_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\nset_option linter.unusedVariables false\nvariable {p : Prop}\nvariable {q : Prop}\ntheorem t1 (hp : p) (hq : q) : p := hp\n\naxiom hp : p\n\ntheorem t2 : q → p := t1 hp\n");
addToggleButtonToElement("--verso-unique-69");</script>
              <p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">axiom</span></code> declaration postulates the existence of an
element of the given type and may compromise logical consistency. For
example, we can use it to postulate that the empty type <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code> has an
element:</p>
              <div class="example" id="--verso-unique-70">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Axioms/#Lean___Parser___Command___axiom-next" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.axiom-0">axiom</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-unsound" data-verso-hover="154">unsound</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- Everything follows from false
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-55">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-ex" data-verso-hover="155">ex</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="11">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim in Lean Language Reference"><span class="const token" data-binding="const-False.elim" data-verso-hover="156">False.elim</span></a><span class="inter-text"> </span><span class="const token" data-binding="const-unsound" data-verso-hover="154">unsound</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-70", "axiom unsound : False\n-- Everything follows from false\ntheorem ex : 1 = 0 :=\n  False.elim unsound\n");</script>
              <p>
                Declaring an “axiom” <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="1">p</span></code> is tantamount to declaring that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.39" data-verso-hover="1">p</span></code>
is true, as witnessed by <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.55" data-verso-hover="4">hp</span></code>. Applying the theorem
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="157">t1</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.82" data-verso-hover="1">p</span></code> to the fact <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.106" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="1">p</span></code> that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.127" data-verso-hover="1">p</span></code> is true yields the theorem
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.316" data-verso-hover="157">t1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.310" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.308" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.308" data-verso-hover="1">p</span></code>.</p>
              <p>
                Recall that we can also write theorem <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span></code> as follows:</p>
              <div class="example" id="--verso-unique-71">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-47">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">hp</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.print-100">#print</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">t1</span></code><div class="information">
                  <pre>theorem t1 : ∀ {p q : Prop}, p → q → p :=
fun {p q} hp hq =&gt; hp</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-71", "set_option linter.unusedVariables false\nset_option linter.unusedVariables false\ntheorem t1 {p q : Prop} (hp : p) (hq : q) : p := hp\n\n#print t1");
addToggleButtonToElement("--verso-unique-71");</script>
              <p>
                The type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t1" data-verso-hover="150">t1</span></code> is now <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1764" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1766" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1764" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1766" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1764" data-verso-hover="1">p</span></code>. We can read
this as the assertion “for every pair of propositions <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1781" data-verso-hover="1">p</span></code><code> </code><code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1801" data-verso-hover="1">q</span></code>, we have
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1813" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1817" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1813" data-verso-hover="1">p</span></code>.” For example, we can move all parameters to the right
of the colon:</p>
              <div class="example" id="--verso-unique-72">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-47">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-97">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-72", "set_option linter.unusedVariables false\nset_option linter.unusedVariables false\ntheorem t1 : ∀ {p q : Prop}, p → q → p :=\n  fun {p q : Prop} (hp : p) (hq : q) => hp\n");
addToggleButtonToElement("--verso-unique-72");</script>
              <p>
                If <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1837" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1857" data-verso-hover="1">q</span></code> have been declared as <a href="Dependent-Type-Theory/#variables-and-sections">variables</a>, Lean will
generalize them for us automatically:</p>
              <div class="example" id="--verso-unique-73">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-23">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-53">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">unused variable `hq`
note: this linter can be disabled with `set_option linter.unusedVariables false`</code></span></span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="6">hq</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-73", "variable {p q : Prop}\n\ntheorem t1 : p → q → p := fun (hp : p) (hq : q) => hp\n");</script>
              <p>
                When we generalize <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t1" data-verso-hover="148">t1</span></code> in such a way, we can then apply it to
different pairs of propositions, to obtain different instances of the
general theorem.</p>
              <div class="example" id="--verso-unique-74">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">set_option</span><span class="inter-text"> </span><span class="option token" data-binding="option-linter.unusedVariables" data-verso-hover="147">linter.unusedVariables</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.set_option-0" data-verso-hover="146">false</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-47">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="158">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="4">hp</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-100" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.69" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">t1 p q : p → q → p</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-127">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="158">t1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.69" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="1">q</span></code><div class="information">
                  <pre>t1 p q : p → q → p</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">t1 r s : r → s → r</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-182">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="158">t1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span></code><div class="information">
                  <pre>t1 r s : r → s → r</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">t1 (r → s) (s → r) : (r → s) → (s → r) → r → s</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-237">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="158">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                  <pre>t1 (r → s) (s → r) : (r → s) → (s → r) → r → s</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-335" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="159">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">t1 (r → s) (s → r) h : (s → r) → r → s</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-359">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-t1" data-verso-hover="158">t1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span></code><div class="information">
                  <pre>t1 (r → s) (s → r) h : (s → r) → r → s</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-74", "set_option linter.unusedVariables false\nset_option linter.unusedVariables false\ntheorem t1 (p q : Prop) (hp : p) (hq : q) : p := hp\n\nvariable (p q r s : Prop)\n\n#check t1 p q#check t1 r s#check t1 (r → s) (s → r)variable (h : r → s)\n\n#check t1 (r → s) (s → r) h");
addToggleButtonToElement("--verso-unique-74");</script>
              <p>
                Once again, using the <a class="technical-term" href="Propositions-and-Proofs/#--tech-term-propositions-as-types">propositions-as-types</a> correspondence, the
variable <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.79" data-verso-hover="159">h</span></code> of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span></code> can be viewed as the hypothesis, or
premise, that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="1">s</span></code> holds.</p>
              <p>
                As another example, let us consider the composition function discussed
in the last chapter, now with propositions instead of types.</p>
              <div class="example" id="--verso-unique-75">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-27">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-t2" data-verso-hover="160">t2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="161">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="162">h₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-87">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="4">h₃</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-105">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-112">from</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="161">h₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="162">h₂</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="4">h₃</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-75", "variable (p q r s : Prop)\n\ntheorem t2 (h₁ : q → r) (h₂ : p → q) : p → r :=\n  fun h₃ : p =>\n  show r from h₁ (h₂ h₃)\n");</script>
              <p>
                As a theorem of propositional logic, what does <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-t2" data-verso-hover="160">t2</span></code> say?</p>
              <p>
                Note that it is often useful to use numeric Unicode subscripts,
entered as <code class="unicode-abbrev">\0</code>, <code class="unicode-abbrev">\1</code>, <code class="unicode-abbrev">\2</code>, ..., for hypotheses, as we did in
this example.</p>
              </section>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositional-Logic">
                3.3. Propositional Logic</h2>
              <p>
                Lean defines all the standard logical connectives and notation. The propositional connectives come with the following notation:</p>
              <table class="tabular"><thead><tr><th><p>
                        ASCII</p>
                      </th><th><p>
                        Unicode</p>
                      </th><th><p>
                        Editor shortcut</p>
                      </th><th><p>
                        Definition</p>
                      </th></tr></thead><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True in Lean Language Reference"><span class="const token" data-binding="const-True" data-verso-hover="39">True</span></a></code></p>
                    </td><td><p>
                    </td><td><p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True in Lean Language Reference"><span class="const token" data-binding="const-True" data-verso-hover="39">True</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code></p>
                    </td><td><p>
                    </td><td><p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not in Lean Language Reference"><span class="const token" data-binding="const-Not" data-verso-hover="140">Not</span></a></code></p>
                    </td><td><p>
                      <code>¬</code></p>
                    </td><td><p>
                      <code class="unicode-abbrev">\not</code>, <code class="unicode-abbrev">\neg</code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Not" title="Documentation for Not in Lean Language Reference"><span class="const token" data-binding="const-Not" data-verso-hover="140">Not</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code>/\</code></p>
                    </td><td><p>
                      <code>∧</code></p>
                    </td><td><p>
                      <code class="unicode-abbrev">\and</code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code>\/</code></p>
                    </td><td><p>
                      <code>∨</code></p>
                    </td><td><p>
                      <code class="unicode-abbrev">\or</code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or in Lean Language Reference"><span class="const token" data-binding="const-Or" data-verso-hover="139">Or</span></a></code></p>
                    </td></tr><tr><td><p>
                      <code>-&gt;</code></p>
                    </td><td><p>
                      <code>→</code></p>
                    </td><td><p>
                      <code class="unicode-abbrev">\to</code>, <code class="unicode-abbrev">\r</code>, <code class="unicode-abbrev">\imp</code></p>
                    </td><td><p>
                    </td></tr><tr><td><p>
                      <code>&lt;-&gt;</code></p>
                    </td><td><p>
                      <code>↔</code></p>
                    </td><td><p>
                      <code class="unicode-abbrev">\iff</code>, <code class="unicode-abbrev">\lr</code></p>
                    </td><td><p>
                      <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff in Lean Language Reference"><span class="const token" data-binding="const-Iff" data-verso-hover="163">Iff</span></a></code></p>
                    </td></tr></table><p>
                They all take values in <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>.</p>
              <div class="example" id="--verso-unique-76">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">p → q → p ∧ q : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-23">#check</span></a></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span></code><div class="information">
                  <pre>p → q → p ∧ q : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">¬p → p ↔ False : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-51">#check</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code><div class="information">
                  <pre>¬p → p ↔ False : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">p ∨ q → q ∨ p : Prop</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-79">#check</span></a></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span></code><div class="information">
                  <pre>p ∨ q → q ∨ p : Prop</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-76", "variable (p q : Prop)\n\n#check p → q → p ∧ q#check ¬p → p ↔ False#check p ∨ q → q ∨ p");</script>
              <p>
                The order of operations is as follows: unary negation <code>¬</code> binds most
strongly, then <code>∧</code>, then <code>∨</code>, then <code>→</code>, and finally <code>↔</code>. For
example, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">b</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="1">e</span></code> means <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="1">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="1">b</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="1">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">e</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code>.
Remember that <code>→</code> associates to the right (nothing changes
now that the arguments are elements of <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, instead of some other
<code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span></code>), as do the other binary connectives. So if we have
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.109" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="1">r</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, the expression <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.157" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.159" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.161" data-verso-hover="1">r</span></code> reads “if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.181" data-verso-hover="1">p</span></code>, then if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.199" data-verso-hover="1">q</span></code>,
then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="1">r</span></code>.” This is just the “curried” form of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.229" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.231" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.233" data-verso-hover="1">r</span></code>.</p>
              <p>
                In the last chapter we observed that lambda abstraction can be viewed
as an “introduction rule” for <code>→</code>. In the current setting, it shows
how to “introduce” or establish an implication. Application can be
viewed as an “elimination rule,” showing how to “eliminate” or use an
implication in a proof. The other propositional connectives are
defined in Lean's library, and are automatically imported. Each connective
comes with its canonical introduction and elimination rules.</p>
              <section>
                <h3 id="conjunction">
                  3.3.1. Conjunction<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=conjunction" title="Permalink">🔗</a></span></h3>
                <p>
                  The expression <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="4">h1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="6">h2</span></code> builds a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1">q</span></code> using
proofs <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="4">h1</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.51" data-verso-hover="6">h2</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">q</span></code>. It is common to describe
<code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a></code> as the <em>and-introduction</em> rule. In the next example we
use <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a></code> to create a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88" data-verso-hover="1">q</span></code>.</p>
                <div class="example" id="--verso-unique-77">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="6">hq</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun hp hq =&gt; ⟨hp, hq⟩ : p → q → p ∧ q</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-79">#check</span></a></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-86">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq</span></code><div class="information">
                    <pre>fun hp hq =&gt; ⟨hp, hq⟩ : p → q → p ∧ q</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-77", "variable (p q : Prop)\n\nexample (hp : p) (hq : q) : p ∧ q := And.intro hp hq\n\n#check fun (hp : p) (hq : q) => And.intro hp hq");</script>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">example</span></code> command states a theorem without naming it or storing
it in the permanent context. Essentially, it just checks that the
given term has the indicated type. It is convenient for illustration,
and we will use it often.</p>
                <p>
                  The expression <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="3">h</span></code> creates a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">p</span></code> from a proof
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="1">q</span></code>. Similarly, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.43" data-verso-hover="1">h</span></code> is a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.53" data-verso-hover="1">q</span></code>. They
are commonly known as the left and right <em>and-elimination</em> rules.</p>
                <div class="example" id="--verso-unique-78">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-63">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="3">h</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-78", "variable (p q : Prop)\n\nexample (h : p ∧ q) : p := And.left h\nexample (h : p ∧ q) : q := And.right h\n");</script>
                <p>
                  We can now prove <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2037" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2041" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2041" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2037" data-verso-hover="1">p</span></code> with the following proof term.</p>
                <div class="example" id="--verso-unique-79">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-79", "variable (p q : Prop)\n\nexample (h : p ∧ q) : q ∧ p :=\n  And.intro (And.right h) (And.left h)\n");</script>
                <p>
                  Notice that and-introduction and and-elimination are similar to the
pairing and projection operations for the Cartesian product. The
difference is that given <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.57" data-verso-hover="6">hq</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.70" data-verso-hover="1">q</span></code>, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="6">hq</span></code> has type
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.102" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>, while given <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.131" data-verso-hover="24">a</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.144" data-verso-hover="19">α</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.166" data-verso-hover="47">b</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.179" data-verso-hover="19">β</span></code>, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod.mk in Lean Language Reference"><span class="const token" data-binding="const-Prod.mk" data-verso-hover="164">Prod.mk</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.197" data-verso-hover="1">a</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.199" data-verso-hover="1">b</span></code> has type
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.213" data-verso-hover="19">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.215" data-verso-hover="19">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span></code>. <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Tuples/#Prod___mk" title="Documentation for Prod in Lean Language Reference"><span class="const token" data-binding="const-Prod" data-verso-hover="20">Prod</span></a></code> cannot be used with <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>s, and <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And in Lean Language Reference"><span class="const token" data-binding="const-And" data-verso-hover="138">And</span></a></code> cannot be used with <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="sort-7243200735919010059" data-verso-hover="26">Type</span></code>s.
The similarity between <code>∧</code> and <code>×</code> is another instance
of the <a class="technical-term" href="Propositions-and-Proofs/#--tech-term-Curry-Howard-isomorphism">Curry-Howard isomorphism</a>, but in contrast to implication and
the function space constructor, <code>∧</code> and <code>×</code> are treated separately
in Lean. With the analogy, however, the proof we have just constructed
is similar to a function that swaps the elements of a pair.</p>
                <p>
                  We will see in <a href="Structures-and-Records/#structures-and-records">Structures and Records</a> that certain
types in Lean are <em>structures</em>, which is to say, the type is defined
with a single canonical <em>constructor</em> which builds an element of the
type from a sequence of suitable arguments. For every <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.294" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.313" data-verso-hover="1">q</span><span class="inter-text"> : </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span></code>,
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.344" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.346" data-verso-hover="1">q</span></code> is an example: the canonical way to construct an element is
to apply <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a></code> to suitable arguments <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.384" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.397" data-verso-hover="1">p</span></code> and
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.419" data-verso-hover="6">hq</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.432" data-verso-hover="1">q</span></code>. Lean allows us to use <em>anonymous constructor</em> notation
<code>⟨arg1, arg2, ...⟩</code> in situations like these, when the relevant type is an
inductive type and can be inferred from the context. In particular, we
can often write <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.450" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.452" data-verso-hover="6">hq</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span></code> instead of <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.475" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.477" data-verso-hover="6">hq</span></code>:</p>
                <div class="example" id="--verso-unique-80">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-22" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">⟨hp, hq⟩ : p ∧ q</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-50">#check</span></a></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="6">hq</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                    <pre>⟨hp, hq⟩ : p ∧ q</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-80", "variable (p q : Prop)\nvariable (hp : p) (hq : q)\n\n#check (⟨hp, hq⟩ : p ∧ q)");</script>
                <p>
                  These angle brackets are obtained by typing <code class="unicode-abbrev">\&lt;</code> and <code class="unicode-abbrev">\&gt;</code>, respectively.</p>
                <p>
                  Lean provides another useful syntactic gadget. Given an expression
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.371" data-verso-hover="165">e</span></code> of an inductive type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Foo" data-verso-hover="166">Foo</span></code> (possibly applied to some
arguments), the notation <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.375" data-verso-hover="165">e</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Foo.bar" data-verso-hover="167">bar</span></code> is shorthand for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Foo.bar" data-verso-hover="167">Foo.bar</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.378" data-verso-hover="165">e</span></code>.
This provides a convenient way of accessing functions without opening
a namespace.  For example, the following two expressions mean the same
thing:</p>
                <div class="example" id="--verso-unique-81">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="168">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Linked-Lists/#List___nil" title="Documentation for List in Lean Language Reference"><span class="const token" data-binding="const-List" data-verso-hover="30">List</span></a><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Natural-Numbers/#Nat___zero" title="Documentation for Nat in Lean Language Reference"><span class="const token" data-binding="const-Nat" data-verso-hover="10">Nat</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">xs.length : Nat</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-26">#check</span></a></span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Linked-Lists/#List___length" title="Documentation for List.length in Lean Language Reference"><span class="const token" data-binding="const-List.length" data-verso-hover="110">List.length</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="168">xs</span></code><div class="information">
                    <pre>xs.length : Nat</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">xs.length : Nat</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-49">#check</span></a></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="168">xs</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Types/Linked-Lists/#List___length" title="Documentation for List.length in Lean Language Reference"><span class="const token" data-binding="const-List.length" data-verso-hover="110">length</span></a></code><div class="information">
                    <pre>xs.length : Nat</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-81", "variable (xs : List Nat)\n\n#check List.length xs#check xs.length");</script>
                <p>
                  As a result, given <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="1">q</span></code>, we can write <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.25" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a></code> for
<code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="3">h</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.49" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a></code> for <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.61" data-verso-hover="1">h</span></code>. We can therefore
rewrite the sample proof above conveniently as follows:</p>
                <div class="example" id="--verso-unique-82">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="unknown token" data-binding="">⟩</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-82", "variable (p q : Prop)\n\nexample (h : p ∧ q) : q ∧ p :=\n  ⟨h.right, h.left⟩\n");</script>
                <p>
                  There is a fine line between brevity and obfuscation, and omitting
information in this way can sometimes make a proof harder to read. But
for straightforward constructions like the one above, when the type of
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span></code> and the goal of the construction are salient, the notation is
clean and effective.</p>
                <p>
                  It is common to iterate constructions like “And.” Lean also allows you
to flatten nested constructors that associate to the right, so that
these two proofs are equivalent:</p>
                <div class="example" id="--verso-unique-83">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-104">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.39" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">⟨</span><span class="var token" data-binding="var-_uniq.39" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="">⟩</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-83", "variable (p q : Prop)\n\nexample (h : p ∧ q) : q ∧ p ∧ q :=\n  ⟨h.right, ⟨h.left, h.right⟩⟩\n\nexample (h : p ∧ q) : q ∧ p ∧ q :=\n  ⟨h.right, h.left, h.right⟩\n");</script>
                <p>
                  This is often useful as well.</p>
                </section>
              <section>
                <h3 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositional-Logic--Disjunction">
                  3.3.2. Disjunction</h3>
                <p>
                  The expression <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_left" data-verso-hover="169">Or.intro_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="4">hp</span></code> creates a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.19" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="1">q</span></code>
from a proof <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.31" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="1">p</span></code>. Similarly, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_right" data-verso-hover="170">Or.intro_right</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="6">hq</span></code> creates a
proof for <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.53" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.55" data-verso-hover="1">q</span></code> using a proof <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.67" data-verso-hover="6">hq</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="1">q</span></code>. These are the left and
right <em>or-introduction</em> rules.</p>
                <div class="example" id="--verso-unique-84">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-22">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Or.intro_left" data-verso-hover="169">Or.intro_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-71">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Or.intro_right" data-verso-hover="170">Or.intro_right</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-84", "variable (p q : Prop)\nexample (hp : p) : p ∨ q := Or.intro_left q hp\nexample (hq : q) : p ∨ q := Or.intro_right p hq\n");</script>
                <p>
                  The <em>or-elimination</em> rule is slightly more complicated. The idea is
that we can prove <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1">r</span></code> from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.34" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="1">q</span></code>, by showing that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.54" data-verso-hover="1">r</span></code> follows
from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.66" data-verso-hover="1">p</span></code> and that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86" data-verso-hover="1">r</span></code> follows from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.100" data-verso-hover="1">q</span></code>.  In other words, it is a
proof by cases. In the expression <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.120" data-verso-hover="172">hpq</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="173">hpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="161">hqr</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span></code>
takes three arguments, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.173" data-verso-hover="172">hpq</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.210" data-verso-hover="173">hpr</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.220" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.224" data-verso-hover="1">r</span></code> and
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.254" data-verso-hover="161">hqr</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.264" data-verso-hover="1">r</span></code>, and produces a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.284" data-verso-hover="1">r</span></code>. In the following example, we use
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span></code> to prove <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.318" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.320" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.320" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.318" data-verso-hover="1">p</span></code>.</p>
                <div class="example" id="--verso-unique-85">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-77">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-97">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-110">from</span><span class="inter-text"> </span><span class="const token" data-binding="const-Or.intro_right" data-verso-hover="170">Or.intro_right</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-141">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-161">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-174">from</span><span class="inter-text"> </span><span class="const token" data-binding="const-Or.intro_left" data-verso-hover="169">Or.intro_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33" data-verso-hover="6">hq</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-85", "variable (p q r : Prop)\n\nexample (h : p ∨ q) : q ∨ p :=\n  Or.elim h\n    (fun hp : p =>\n      show q ∨ p from Or.intro_right q hp)\n    (fun hq : q =>\n      show q ∨ p from Or.intro_left p hq)\n");</script>
                <p>
                  In most cases, the first argument of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_right" data-verso-hover="170">Or.intro_right</span></code> and
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_left" data-verso-hover="169">Or.intro_left</span></code> can be inferred automatically by Lean. Lean
therefore provides <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a></code> and <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a></code> which can be viewed as
shorthand for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_right" data-verso-hover="170">Or.intro_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.intro_left" data-verso-hover="169">Or.intro_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code>. Thus the
proof term above could be written more concisely:</p>
                <div class="example" id="--verso-unique-86">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-73">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.25" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-95">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="6">hq</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-86", "variable (p q r : Prop)\n\nexample (h : p ∨ q) : q ∨ p :=\n  Or.elim h (fun hp => Or.inr hp) (fun hq => Or.inl hq)\n");</script>
                <p>
                  Notice that there is enough information in the full expression for
Lean to infer the types of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.25" data-verso-hover="4">hp</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="6">hq</span></code> as well.  But using the
type annotations in the longer version makes the proof more readable,
and can help catch and debug errors.</p>
                <p>
                  Because <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or in Lean Language Reference"><span class="const token" data-binding="const-Or" data-verso-hover="139">Or</span></a></code> has two constructors, we cannot use anonymous
constructor notation. But we can still write <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="172">h</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">elim</span></code> instead of
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.57" data-verso-hover="172">h</span></code>:</p>
                <div class="example" id="--verso-unique-87">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="172">h</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-70">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.31" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-92">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="6">hq</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-87", "variable (p q r : Prop)\n\nexample (h : p ∨ q) : q ∨ p :=\n  h.elim (fun hp => Or.inr hp) (fun hq => Or.inl hq)\n");</script>
                <p>
                  Once again, you should exercise judgment as to whether such
abbreviations enhance or diminish readability.</p>
                </section>
              <section>
                <h3 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositional-Logic--Negation-and-Falsity">
                  3.3.3. Negation and Falsity</h3>
                <p>
                  Negation, <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1">p</span></code>, is actually defined to be <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code>, so we
obtain <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">p</span></code> by deriving a contradiction from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.38" data-verso-hover="1">p</span></code>. Similarly, the
expression <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.50" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="4">hp</span></code> produces a proof of <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code> from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.68" data-verso-hover="4">hp</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="1">p</span></code>
and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.83" data-verso-hover="176">hnp</span><span class="inter-text"> : </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.89" data-verso-hover="1">p</span></code>. The next example uses both these rules to produce a
proof of <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.99" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.97" data-verso-hover="1">p</span></code>. (The symbol <code>¬</code> is produced by
typing <code class="unicode-abbrev">\not</code> or <code class="unicode-abbrev">\neg</code>.)</p>
                <div class="example" id="--verso-unique-88">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="162">hpq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="177">hnq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-70">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-86">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">False</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-97">from</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="177">hnq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="162">hpq</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-88", "variable (p q : Prop)\n\nexample (hpq : p → q) (hnq : ¬q) : ¬p :=\n  fun hp : p =>\n  show False from hnq (hpq hp)\n");</script>
                <p>
                  The connective <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code> has a single elimination rule,
<code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim in Lean Language Reference"><span class="const token" data-binding="const-False.elim" data-verso-hover="156">False.elim</span></a></code>, which expresses the fact that anything follows from a
contradiction. This rule is sometimes called <em>ex falso</em> (short for <em>ex
falso sequitur quodlibet</em>), or the <em>principle of explosion</em>.</p>
                <div class="example" id="--verso-unique-89">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim in Lean Language Reference"><span class="const token" data-binding="const-False.elim" data-verso-hover="156">False.elim</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-89", "variable (p q : Prop)\n\nexample (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)\n");</script>
                <p>
                  The arbitrary fact, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2210" data-verso-hover="1">q</span></code>, that follows from falsity is an implicit
argument in <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False___elim" title="Documentation for False.elim in Lean Language Reference"><span class="const token" data-binding="const-False.elim" data-verso-hover="156">False.elim</span></a></code> and is inferred automatically. This
pattern, deriving an arbitrary fact from contradictory hypotheses, is
quite common, and is represented by <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a></code>.</p>
                <div class="example" id="--verso-unique-90">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hnp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-90", "variable (p q : Prop)\n\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n");</script>
                <p>
                  Here, for example, is a proof of <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2266" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2266" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2266" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2266" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2268" data-verso-hover="1">r</span></code>:</p>
                <div class="example" id="--verso-unique-91">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-25">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="179">hqp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="179">hqp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="6">hq</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hnp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-91", "variable (p q r : Prop)\n\nexample (hnp : ¬p) (hq : q) (hqp : q → p) : r :=\n  absurd (hqp hq) hnp\n");</script>
                <p>
                  Incidentally, just as <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code> has only an elimination rule, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True in Lean Language Reference"><span class="const token" data-binding="const-True" data-verso-hover="39">True</span></a></code>
has only an introduction rule, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True.intro in Lean Language Reference"><span class="const token" data-binding="const-True.intro" data-verso-hover="40">True.intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True in Lean Language Reference"><span class="const token" data-binding="const-True" data-verso-hover="39">True</span></a></code>.  In other words,
<code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True in Lean Language Reference"><span class="const token" data-binding="const-True" data-verso-hover="39">True</span></a></code> is simply true, and has a canonical proof, <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#True___intro" title="Documentation for True.intro in Lean Language Reference"><span class="const token" data-binding="const-True.intro" data-verso-hover="40">True.intro</span></a></code>.</p>
                </section>
              <section>
                <h3 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Propositional-Logic--Logical-Equivalence">
                  3.3.4. Logical Equivalence</h3>
                <p>
                  The expression <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.intro in Lean Language Reference"><span class="const token" data-binding="const-Iff.intro" data-verso-hover="180">Iff.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="162">h1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="179">h2</span></code> produces a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.40" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="1">q</span></code> from
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.60" data-verso-hover="162">h1</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.72" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.74" data-verso-hover="1">q</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.100" data-verso-hover="179">h2</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.110" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.108" data-verso-hover="1">p</span></code>.  The expression <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.mp in Lean Language Reference"><span class="const token" data-binding="const-Iff.mp" data-verso-hover="181">Iff.mp</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.138" data-verso-hover="182">h</span></code>
produces a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.147" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="1">q</span></code> from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.165" data-verso-hover="1">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.180" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.182" data-verso-hover="1">q</span></code>. Similarly,
<code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.mpr in Lean Language Reference"><span class="const token" data-binding="const-Iff.mpr" data-verso-hover="183">Iff.mpr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.206" data-verso-hover="1">h</span></code> produces a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.217" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.215" data-verso-hover="1">p</span></code> from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.233" data-verso-hover="1">h</span><span class="inter-text"> : </span><span class="var token" data-binding="var-_uniq.248" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.250" data-verso-hover="1">q</span></code>. Here is a proof
of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.262" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.264" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.264" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="1">p</span></code>:</p>
                <div class="example" id="--verso-unique-92">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-23">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-and_swap" data-verso-hover="184">and_swap</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.intro in Lean Language Reference"><span class="const token" data-binding="const-Iff.intro" data-verso-hover="180">Iff.intro</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-82">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
     </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-106">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-119">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="3">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="3">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-167">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="185">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
     </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-191">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-204">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="185">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">And.left</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="185">h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">and_swap p q : p ∧ q ↔ q ∧ p</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-248">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-and_swap" data-verso-hover="184">and_swap</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span></code><div class="information">
                    <pre>and_swap p q : p ∧ q ↔ q ∧ p</pre></div>
                  <code class="hl lean block" data-lean-context="examples"><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-310" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-333">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.mp in Lean Language Reference"><span class="const token" data-binding="const-Iff.mp" data-verso-hover="181">Iff.mp</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-and_swap" data-verso-hover="184">and_swap</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-92", "variable (p q : Prop)\n\ntheorem and_swap : p ∧ q ↔ q ∧ p :=\n  Iff.intro\n    (fun h : p ∧ q =>\n     show q ∧ p from And.intro (And.right h) (And.left h))\n    (fun h : q ∧ p =>\n     show p ∧ q from And.intro (And.right h) (And.left h))\n\n#check and_swap p qvariable (h : p ∧ q)\nexample : q ∧ p := Iff.mp (and_swap p q) h\n");</script>
                <p>
                  We can use the anonymous constructor notation to construct a proof of
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2376" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2380" data-verso-hover="1">q</span></code> from proofs of the forward and backward directions, and we
can also use <code>.</code> notation with <code>mp</code> and <code>mpr</code>. The previous
examples can therefore be written concisely as follows:</p>
                <div class="example" id="--verso-unique-93">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-23">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-and_swap" data-verso-hover="184">and_swap</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">⟨</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-71">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.21" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-103">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="185">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="185">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="185">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-139">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-and_swap" data-verso-hover="184">and_swap</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.mp in Lean Language Reference"><span class="const token" data-binding="const-Iff.mp" data-verso-hover="181">mp</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="3">h</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
                <script>
                  addCopyButtonToElement("--verso-unique-93", "variable (p q : Prop)\n\ntheorem and_swap : p ∧ q ↔ q ∧ p :=\n  ⟨ fun h => ⟨h.right, h.left⟩, fun h => ⟨h.right, h.left⟩ ⟩\n\nexample (h : p ∧ q) : q ∧ p := (and_swap p q).mp h\n");</script>
                </section>
              </section>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Introducing-Auxiliary-Subgoals">
                3.4. Introducing Auxiliary Subgoals</h2>
              <p>
                This is a good place to introduce another device Lean offers to help
structure long proofs, namely, the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">have</span></code> construct, which
introduces an auxiliary subgoal in a proof. Here is a small example,
adapted from the last section:</p>
              <div class="example" id="--verso-unique-94">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-60">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-84">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-109">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-122">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-94", "variable (p q : Prop)\n\nexample (h : p ∧ q) : q ∧ p :=\n  have hp : p := h.left\n  have hq : q := h.right\n  show q ∧ p from And.intro hq hp\n");</script>
              <p>
                Internally, the expression <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-2">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="4">s</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.16" data-verso-hover="6">t</span></code> produces the term
<code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="4">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="6">t</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="4">s</span></code>. In other words, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.41" data-verso-hover="4">s</span></code> is a proof of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.45" data-verso-hover="1">p</span></code>,
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.59" data-verso-hover="6">t</span></code> is a proof of the desired conclusion assuming <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.32" data-verso-hover="4">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">p</span></code>, and the
two are combined by a lambda abstraction and application. This simple
device is extremely useful when it comes to structuring long proofs,
since we can use intermediate <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">have</span></code>'s as stepping stones leading to
the final goal.</p>
              <p>
                Lean also supports a structured way of reasoning backwards from a
goal, which models the “suffices to show” construction in ordinary
mathematics. The next example simply permutes the last two lines in
the previous proof.</p>
              <div class="example" id="--verso-unique-95">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-23">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-60">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.suffices-84">suffices</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-100">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="4">hp</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-123">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-130">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">And.right</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="3">h</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-95", "variable (p q : Prop)\n\nexample (h : p ∧ q) : q ∧ p :=\n  have hp : p := h.left\n  suffices hq : q from And.intro hq hp\n  show q from And.right h\n");</script>
              <p>
                Writing <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.suffices-84">suffices</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span></code> leaves us with two goals. First, we have
to show that it indeed suffices to show <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2396" data-verso-hover="1">q</span></code>, by proving the original
goal of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.264" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="1">p</span></code> with the additional hypothesis <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span></code>. Finally,
we have to show <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.264" data-verso-hover="1">q</span></code>.</p>
              </section>
            <section>
              <h2 id="classical-logic">
                3.5. Classical Logic<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&amp;name=classical-logic" title="Permalink">🔗</a></span></h2>
              <p>
                The introduction and elimination rules we have seen so far are all
constructive, which is to say, they reflect a computational
understanding of the logical connectives based on the
<a class="technical-term" href="Propositions-and-Proofs/#--tech-term-propositions-as-types">propositions-as-types</a> correspondence. Ordinary classical logic adds to
this the law of the excluded middle, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2408" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2408" data-verso-hover="1">p</span></code>. To use this
principle, you have to open the classical namespace.</p>
              <div class="example" id="--verso-unique-96">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-16" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">em p : p ∨ ¬p</code></span></span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Interacting-with-Lean/#Lean___Parser___Command___check" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-37">#check</span></a></span><span class="inter-text"> </span><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span></code><div class="information">
                  <pre>em p : p ∨ ¬p</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-96", "open Classical\n\nvariable (p : Prop)\n\n#check em p");</script>
              <p>
                Intuitively, the constructive “Or” is very strong: asserting <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.8" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1">q</span></code>
amounts to knowing which is the case. If <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">RH</span></code> represents the Riemann
hypothesis, a classical mathematician is willing to assert
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">RH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.24" data-verso-hover="1">RH</span></code>, even though we cannot yet assert either disjunct.</p>
              <p>
                One consequence of the law of the excluded middle is the principle of
double-negation elimination:</p>
              <div class="example" id="--verso-unique-97">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-16">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-dne" data-verso-hover="187">dne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="188">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-80">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15" data-verso-hover="4">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-103">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19" data-verso-hover="176">hnp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="188">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-97", "open Classical\n\ntheorem dne {p : Prop} (h : ¬¬p) : p :=\n  Or.elim (em p)\n    (fun hp : p => hp)\n    (fun hnp : ¬p => absurd hnp h)\n");</script>
              <p>
                Double-negation elimination allows one to prove any proposition,
<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.35" data-verso-hover="1">p</span></code>, by assuming <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.37" data-verso-hover="1">p</span></code> and deriving <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code>, because that amounts
to proving <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.41" data-verso-hover="1">p</span></code>. In other words, double-negation elimination allows
one to carry out a proof by contradiction, something which is not
generally possible in constructive logic. As an exercise, you might
try proving the converse, that is, showing that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span></code> can be proved
from <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dne" data-verso-hover="187">dne</span></code>.</p>
              <p>
                The classical axioms also give you access to additional patterns of
proof that can be justified by appeal to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span></code>.  For example, one can
carry out a proof by cases:</p>
              <div class="example" id="--verso-unique-98">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-15" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-36">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="188">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Classical.byCases" data-verso-hover="189">byCases</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-78">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13" data-verso-hover="4">h1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-101">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="176">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="176">h1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="188">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-98", "open Classical\nvariable (p : Prop)\n\nexample (h : ¬¬p) : p :=\n  byCases\n    (fun h1 : p => h1)\n    (fun h1 : ¬p => absurd h1 h)\n");</script>
              <p>
                Or you can carry out a proof by contradiction:</p>
              <div class="example" id="--verso-unique-99">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-15" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-36">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="188">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Classical.byContradiction" data-verso-hover="190">byContradiction</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-86">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="176">h1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
     </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-107">show</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-118">from</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="188">h</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="176">h1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-99", "open Classical\nvariable (p : Prop)\n\nexample (h : ¬¬p) : p :=\n  byContradiction\n    (fun h1 : ¬p =>\n     show False from h h1)\n");</script>
              <p>
                If you are not used to thinking constructively, it may take some time
for you to get a sense of where classical reasoning is used.  It is
needed in the following example because, from a constructive
standpoint, knowing that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2424" data-verso-hover="1">p</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2444" data-verso-hover="1">q</span></code> are not both true does not
necessarily tell you which one is false:</p>
              <div class="example" id="--verso-unique-100">
                <div class="hidden">
                  <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">
</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-15" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code></div>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-44">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="191">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-109">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-145">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-154">from</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-169">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
          </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="191">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.27" data-verso-hover="6">hq</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-215">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="176">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="176">hp</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-100", "open Classical\nvariable (p q : Prop)\nopen Classical\nvariable (p q : Prop)\nexample (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=\n  Or.elim (em p)\n    (fun hp : p =>\n      Or.inr\n        (show ¬q from\n          fun hq : q =>\n          h ⟨hp, hq⟩))\n    (fun hp : ¬p =>\n      Or.inl hp)\n");
addToggleButtonToElement("--verso-unique-100");</script>
              <p>
                We will see later that there <em>are</em> situations in constructive logic
where principles like excluded middle and double-negation elimination
are permissible, and Lean supports the use of classical reasoning in
such contexts without relying on excluded middle.</p>
              <p>
                The full list of axioms that are used in Lean to support classical
reasoning are discussed in <a href="Axioms-and-Computation/#axioms-and-computation">Axioms and Computation</a>.</p>
              </section>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Examples-of-Propositional-Validities">
                3.6. Examples of Propositional Validities</h2>
              <p>
                Lean's standard library contains proofs of many valid statements of
propositional logic, all of which you are free to use in proofs of
your own. The following list includes a number of common identities.</p>
              <p>
                Commutativity:</p>
              <ol start="1">
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10" data-verso-hover="1">p</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.20" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.22" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="1">p</span></code></p>
                  </li>
                </ol>
              <p>
                Associativity:</p>
              <ol start="3">
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.40" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.38" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                </ol>
              <p>
                Distributivity:</p>
              <ol start="5">
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.42" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.44" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.42" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.46" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.52" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.54" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                </ol>
              <p>
                Other properties:</p>
              <ol start="7">
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.60" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.62" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.106" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.104" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.106" data-verso-hover="1">q</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.112" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.124" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.134" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.134" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.151" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.165" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.167" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.165" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.167" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.181" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.181" data-verso-hover="1">p</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.189" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.197" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.197" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.207" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                </ol>
              <p>
                These require classical reasoning:</p>
              <ol start="19">
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.226" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.230" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="1">s</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.226" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.230" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.226" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.232" data-verso-hover="1">s</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.253" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.255" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.253" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.255" data-verso-hover="1">q</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.265" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.267" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.265" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.267" data-verso-hover="1">q</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.282" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.284" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.282" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.284" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.301" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.299" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.299" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.301" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.322" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.322" data-verso-hover="1">p</span></code></p>
                  </li>
                <li>
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.330" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.332" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.330" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.330" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code></p>
                  </li>
                </ol>
              <p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code> identifier magically produces a proof of anything, or
provides an object of any data type at all. Of course, it is unsound
as a proof method—for example, you can use it to prove <code class="hl lean inline" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a></code>—and
Lean produces severe warnings when files use or import theorems
which depend on it. But it is very useful for building long proofs
incrementally. Start writing the proof from the top down, using
<code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code> to fill in subproofs. Make sure Lean accepts the term with
all the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code>'s; if not, there are errors that you need to
correct. Then go back and replace each <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code> with an actual proof,
until no more remain.</p>
              <p>
                Here is another useful trick. Instead of using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code>, you can use
an underscore <code>_</code> as a placeholder. Recall this tells Lean that
the argument is implicit, and should be filled in automatically. If
Lean tries to do so and fails, it returns with an error message “don't
know how to synthesize placeholder,” followed by the type of
the term it is expecting, and all the objects and hypotheses available
in the context. In other words, for each unresolved placeholder, Lean
reports the subgoal that needs to be filled at that point. You can
then construct a proof by incrementally filling in these placeholders.</p>
              <p>
                For reference, here are two sample proofs of validities taken from the
list above.</p>
              <div class="example" id="--verso-unique-101">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- distributivity
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-34">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Iff___intro" title="Documentation for Iff.intro in Lean Language Reference"><span class="const token" data-binding="const-Iff.intro" data-verso-hover="180">Iff.intro</span></a><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-123">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="193">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-156">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="193">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="inter-text">
      </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.17" data-verso-hover="193">h</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="unknown token" data-binding="">)</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-211">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-235">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-264">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.32" data-verso-hover="6">hq</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-299">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="194">hr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-323">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-352">from</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.23" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="194">hr</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-384">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66" data-verso-hover="195">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.66" data-verso-hover="195">h</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-444">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="3">hpq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-475">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="3">hpq</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-509">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.71" data-verso-hover="3">hpq</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-544">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-565">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.75" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inl in Lean Language Reference"><span class="const token" data-binding="const-Or.inl" data-verso-hover="175">Or.inl</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.79" data-verso-hover="6">hq</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-600">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="196">hpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-631">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.99" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="196">hpr</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.left in Lean Language Reference"><span class="const token" data-binding="const-And.left" data-verso-hover="5">left</span></a><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.have-665">have</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="194">hr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95" data-verso-hover="196">hpr</span><span class="unknown token" data-binding="">.</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.right in Lean Language Reference"><span class="const token" data-binding="const-And.right" data-verso-hover="7">right</span></a><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-700">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-721">from</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟨</span><span class="var token" data-binding="var-_uniq.99" data-verso-hover="4">hp</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">,</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#Or___inl" title="Documentation for Or.inr in Lean Language Reference"><span class="const token" data-binding="const-Or.inr" data-verso-hover="174">Or.inr</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="194">hr</span><span class="unknown token" data-binding="const-And.intro" data-verso-hover="8">⟩</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- an example that requires classical reasoning
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-797">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.121" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.121" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.121" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-853">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="197">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.121" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-880">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.139" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.121" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-896">show</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fromTerm-903">from</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Or.elim" data-verso-hover="171">Or.elim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Classical.em" data-verso-hover="186">em</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-934">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="6">hq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.149" data-verso-hover="6">hq</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-959">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.153" data-verso-hover="177">hnq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.123" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#absurd" title="Documentation for absurd in Lean Language Reference"><span class="const token" data-binding="const-absurd" data-verso-hover="178">absurd</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Logical-Connectives/#And___intro" title="Documentation for And.intro in Lean Language Reference"><span class="const token" data-binding="const-And.intro" data-verso-hover="8">And.intro</span></a><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.139" data-verso-hover="4">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.153" data-verso-hover="177">hnq</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.137" data-verso-hover="197">h</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-101", "open Classical\n\n-- distributivity\nexample (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=\n  Iff.intro\n    (fun h : p ∧ (q ∨ r) =>\n      have hp : p := h.left\n      Or.elim (h.right)\n        (fun hq : q =>\n          show (p ∧ q) ∨ (p ∧ r) from Or.inl ⟨hp, hq⟩)\n        (fun hr : r =>\n          show (p ∧ q) ∨ (p ∧ r) from Or.inr ⟨hp, hr⟩))\n    (fun h : (p ∧ q) ∨ (p ∧ r) =>\n      Or.elim h\n        (fun hpq : p ∧ q =>\n          have hp : p := hpq.left\n          have hq : q := hpq.right\n          show p ∧ (q ∨ r) from ⟨hp, Or.inl hq⟩)\n        (fun hpr : p ∧ r =>\n          have hp : p := hpr.left\n          have hr : r := hpr.right\n          show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))\n\n-- an example that requires classical reasoning\nexample (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=\n  fun h : ¬(p ∧ ¬q) =>\n  fun hp : p =>\n  show q from\n    Or.elim (em q)\n      (fun hq : q => hq)\n      (fun hnq : ¬q => absurd (And.intro hp hnq) h)\n");</script>
              </section>
            <section>
              <h2 id="Theorem-Proving-in-Lean-4--Propositions-and-Proofs--Exercises">
                3.7. Exercises</h2>
              <p>
                Prove the following identities, replacing the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code> placeholders with actual proofs.</p>
              <div class="example" id="--verso-unique-102">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-0" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- commutativity of ∧ and ∨
</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-57">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-90" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-96">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-129" data-verso-hover="192">sorry</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- associativity of ∧ and ∨
</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-168">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-217" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-223">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-272" data-verso-hover="192">sorry</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- distributivity
</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-297">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-354" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-360">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-417" data-verso-hover="192">sorry</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="inter-text">-- other properties
</span><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-444">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-495" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-501">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.188" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-560" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-566">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-607" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-613">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-654" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-660">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-687" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-693">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-732" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-738">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-769" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-775">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-814" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-820">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-851" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-857">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Basic-Propositions/Truth/#False" title="Documentation for False in Lean Language Reference"><span class="const token" data-binding="const-False" data-verso-hover="153">False</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-892" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-898">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.186" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.184" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-939" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-102", "variable (p q r : Prop)\n\n-- commutativity of ∧ and ∨\nexample : p ∧ q ↔ q ∧ p := sorry\nexample : p ∨ q ↔ q ∨ p := sorry\n\n-- associativity of ∧ and ∨\nexample : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry\nexample : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry\n\n-- distributivity\nexample : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry\nexample : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry\n\n-- other properties\nexample : (p → (q → r)) ↔ (p ∧ q → r) := sorry\nexample : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry\nexample : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry\nexample : ¬p ∨ ¬q → ¬(p ∧ q) := sorry\nexample : ¬(p ∧ ¬p) := sorry\nexample : p ∧ ¬q → ¬(p → q) := sorry\nexample : ¬p → (p → q) := sorry\nexample : (¬p ∨ q) → (p → q) := sorry\nexample : p ∨ False ↔ p := sorry\nexample : p ∧ False ↔ False := sorry\nexample : (p → q) → (¬q → ¬p) := sorry\n");</script>
              <p>
                Prove the following identities, replacing the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-2" data-verso-hover="192">sorry</span></code> placeholders
with actual proofs. These require classical reasoning.</p>
              <div class="example" id="--verso-unique-103">
                <code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___open" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-0" data-verso-hover="101">open</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">Classical</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><a href="https://lean-lang.org/doc/reference/4.21.0-rc3/Namespaces-and-Sections/#Lean___Parser___Command___variable" title="Documentation for syntax in Lean Language Reference"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-16" data-verso-hover="93">variable</span></a><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-14430969920833713138" data-verso-hover="2">Prop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-41">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.94" data-verso-hover="1">r</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-100" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-106">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-147" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-153">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-192" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-198">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-237" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-243">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-284" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-290">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-313" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-319">example</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92" data-verso-hover="1">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.sorry-358" data-verso-hover="192">sorry</span><span class="inter-text">
</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding=""></span></code></div>
              <script>
                addCopyButtonToElement("--verso-unique-103", "open Classical\n\nvariable (p q r : Prop)\n\nexample : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry\nexample : ¬(p ∧ q) → ¬p ∨ ¬q := sorry\nexample : ¬(p → q) → p ∧ ¬q := sorry\nexample : (p → q) → (¬p ∨ q) := sorry\nexample : (¬q → ¬p) → (p → q) := sorry\nexample : p ∨ ¬p := sorry\nexample : (((p → q) → p) → p) := sorry\n");</script>
              <p>
                Prove <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2498" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="var token" data-binding="var-_uniq.2498" data-verso-hover="1">p</span><span class="unknown token" data-binding="">)</span></code> without using classical logic.
</p>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Dependent-Type-Theory/#dependent-type-theory" rel="prev" title="2. Dependent Type Theory"><span class="arrow">←</span><span class="where">2. Dependent Type Theory</span></a><a class="local-button active" href="Quantifiers-and-Equality/#quantifiers-and-equality" rel="next" title="4. Quantifiers and Equality"><span class="where">4. Quantifiers and Equality</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

