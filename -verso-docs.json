{"999": "<code>Type u_3</code>",
 "998": "<code>α → β → γ</code>",
 "997":
 "<code>Vect.map.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) {n : Nat} :\n  Vect α n → Vect β n → Vect γ n</code>",
 "996":
 "<code>Vect.eta.{u_1} {α : Type u_1} {n : Nat} (v : Vect α (n + 1)) : cons v.head v.tail = v</code>",
 "995":
 "<code>Vect.head.{u_1} {α : Type u_1} {n : Nat} : Vect α (n + 1) → α</code>",
 "994":
 "<code>Vect.tail.{u_1} {α : Type u_1} {n : Nat} : Vect α (n + 1) → Vect α n</code>",
 "993":
 "<code>Vect.tail.{u_1} {α : Type u_1} {n : Nat} (v : Vect α (n + 1)) : Vect α n</code>",
 "992":
 "<code>Nat.noConfusion.{u} {P : Sort u} {v1 v2 : Nat} (h12 : v1 = v2) : Nat.noConfusionType P v1 v2</code>",
 "991": "<code>0 = n + 1</code>",
 "990": "<code>Vect α m</code>",
 "99": "<code>Foo.fa : Nat</code>",
 "989":
 "<code>Vect.tailAux.{u_1} {α : Type u_1} {m n : Nat} (v : Vect α m) : m = n + 1 → Vect α n</code>",
 "988":
 "<code>Vect.cons.{u} {α : Type u} : α → {n : Nat} → Vect α n → Vect α (n + 1)</code>",
 "987": "<code>Vect α n</code>",
 "986":
 "<code>(a : α) → {n : Nat} → (a_1 : Vect α n) → motive (n + 1) (Vect.cons a a_1)</code>",
 "985": "<code>motive 0 Vect.nil</code>",
 "984": "<code>Vect α a</code>",
 "983": "<code>(a : Nat) → Vect α a → Sort u</code>",
 "982":
 "<code>Vect.casesOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vect α a → Sort u_1} {a✝ : Nat} (t : Vect α a✝)\n  (nil : motive 0 nil) (cons : (a : α) → {n : Nat} → (a_1 : Vect α n) → motive (n + 1) (cons a a_1)) : motive a✝ t</code>",
 "981": "<code>Vect α (n + 1)</code>",
 "980":
 "<code>tail.{u_1} {α : Type u_1} {n : Nat} : Vect α (n + 1) → Vect α n</code>",
 "98": "<code>Foo.f (x : Nat) : Nat</code>",
 "979":
 "<code>unzip.{u_1, u_2} {α : Type u_1} {β : Type u_2} {n : Nat} : Vect (α × β) n → Vect α n × Vect β n</code>",
 "978":
 "<code>zip.{u_1, u_2} {α : Type u_1} {n : Nat} {β : Type u_2} : Vect α n → Vect β n → Vect (α × β) n</code>",
 "977":
 "<code>map.{u_1, u_2} {α : Type u_1} {β : Type u_2} {n : Nat} (f : α → β) : Vect α n → Vect β n</code>",
 "976":
 "<code>Term.numConsts_replaceConstLst (a b : String) (es : List Term) : numConstsLst (replaceConstLst a b es) = numConstsLst es</code>",
 "975": "<code>¬a = c</code>",
 "974":
 "<code>Term.numConsts_replaceConst (a b : String) (e : Term) : (replaceConst a b e).numConsts = e.numConsts</code>",
 "973":
 "<code>Term.replaceConstLst (a b : String) : List Term → List Term</code>",
 "972": "<code>Term.replaceConst (a b : String) : Term → Term</code>",
 "971": "<code><span class=\"literal string\">\"y\"</span> : String</code>",
 "970": "<code><span class=\"literal string\">\"x\"</span> : String</code>",
 "97": "<code>Foo.a : Nat</code>",
 "969": "<code><span class=\"literal string\">\"g\"</span> : String</code>",
 "968": "<code><span class=\"literal string\">\"f\"</span> : String</code>",
 "967": "<code>Term.sample : Term</code>",
 "966": "<code>Term.numConstsLst : List Term → Nat</code>",
 "965": "<code>List Term</code>",
 "964": "<code>Term.numConsts : Term → Nat</code>",
 "963": "<code>Term.app : String → List Term → Term</code>",
 "962": "<code>Term.const : String → Term</code>",
 "961": "<code>Odd n</code>",
 "960": "<code>odd_of_even_succ (n : Nat) : Even (n + 1) → Odd n</code>",
 "96":
 "<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ℕ := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>",
 "959": "<code>Even n</code>",
 "958": "<code>even_of_odd_succ (n : Nat) : Odd (n + 1) → Even n</code>",
 "957":
 "<code class=\"docstring\">Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n</code>",
 "956": "<code>Odd 0</code>",
 "955": "<code>not_odd_zero : ¬Odd 0</code>",
 "954": "<code>even n✝ = !odd n✝</code>",
 "953": "<code>even_eq_not_odd (a : Nat) : even a = !odd a</code>",
 "952": "<code>odd : Nat → Bool</code>",
 "951": "<code>even : Nat → Bool</code>",
 "950": "<code>b4 = true → False</code>",
 "95":
 "<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>",
 "949": "<code>b3 = true → False</code>",
 "948": "<code>b2 = true → False</code>",
 "947": "<code>b1 = true → False</code>",
 "946":
 "<code>f_or {b1 b2 b3 b4 b5 : Bool} : f b1 b2 b3 b4 b5 = (b1 || b2 || b3 || b4 || b5)</code>",
 "945": "<code>f : Bool → Bool → Bool → Bool → Bool → Bool</code>",
 "944":
 "<code class=\"docstring\">The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional\ncases principle.\n\nThe tactic invocation\n```\nfun_cases f x ... y ...`\n```\nis equivalent to\n```\ncases y, ... using f.fun_cases_unfolding x ...\n```\nwhere the arguments of `f` are used as arguments to `f.fun_cases_unfolding` or targets of the case\nanalysis, as appropriate.\n\nThe form\n```\nfun_cases f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe form `fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` works like with `cases`.\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.fun_cases_unfolding` theorem, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.fun_cases` instead.\n</code>",
 "943": "<code>ack x✝ (ack (x✝ + 1) y✝) &gt; 0</code>",
 "942": "<code>ack (x✝ + 1) y✝ &gt; 0</code>",
 "941": "<code>ack x✝ 1 &gt; 0</code>",
 "940": "<code>ack x (ack (x + 1) y) &gt; 0</code>",
 "94":
 "<code class=\"docstring\">A `section`/`end` pair delimits the scope of `variable`, `include, `open`, `set_option`, and `local`\ncommands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear\nwith the matching `end`. In either case, the `end` can be omitted, in which case the section is\nclosed at the end of the file.\n</code>",
 "939": "<code>ack (x + 1) y &gt; 0</code>",
 "938": "<code>ack x 1 &gt; 0</code>",
 "937":
 "<code class=\"docstring\">The `fun_induction` tactic is a convenience wrapper around the `induction` tactic to use the the\nfunctional induction principle.\n\nThe tactic invocation\n```\nfun_induction f x₁ ... xₙ y₁ ... yₘ\n```\nwhere `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to\n```\ninduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\n```\nwhere the arguments of `f` are used as arguments to `f.induct_unfolding` or targets of the\ninduction, as appropriate.\n\nThe form\n```\nfun_induction f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe forms `fun_induction f x y generalizing z₁ ... zₙ` and\n`fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` work like with `induction.`\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.induct_unfolding` induction principle, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.induct` instead.\n</code>",
 "936": "<code>ack_gt_zero {n m : Nat} : ack n m &gt; 0</code>",
 "935":
 "<code>sorryAx.{u} (α : Sort u) (synthetic : Bool) : α</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary axiom used to implement the `sorry` term and tactic.\n\nThe `sorry` term/tactic expands to `sorryAx _ (synthetic := false)`.\nIt is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can check if a declaration depends on `sorry` either directly or indirectly by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command.\n\nThe `synthetic` flag is false when a `sorry` is written explicitly by the user, but it is\nset to `true` when a tactic fails to prove a goal, or if there is a type error\nin the expression. A synthetic `sorry` acts like a regular one, except that it\nsuppresses follow-up errors in order to prevent an error from causing a cascade\nof other errors because the desired term was not constructed.\n</code>",
 "934": "<code>unsound (x : Nat) : False</code>",
 "933":
 "<code>Prod.Lex.right.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} (a : α) {b₁ b₂ : β}\n  (h : rb b₁ b₂) : Prod.Lex ra rb (a, b₁) (a, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are equal, then they are lexicographically ordered if the\nsecond projections are ordered.\n</code>",
 "932":
 "<code>Prod.Lex.left.{u, v} {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} {a₁ : α} (b₁ : β) {a₂ : α}\n  (b₂ : β) (h : ra a₁ a₂) : Prod.Lex ra rb (a₁, b₁) (a₂, b₂)</code><span class=\"sep\"></span><code class=\"docstring\">If the first projections of two pairs are ordered, then they are lexicographically ordered.\n</code>",
 "931":
 "<code>Prod.Lex.{u, v} {α : Type u} {β : Type v} (ra : α → α → Prop) (rb : β → β → Prop) : α × β → α × β → Prop</code><span class=\"sep\"></span><code class=\"docstring\">A lexicographical order based on the orders `ra` and `rb` for the elements of pairs.\n</code>",
 "930":
 "<code>PSigma.mk.{u, v} {α : Sort u} {β : α → Sort v} (fst : α) (snd : β fst) : PSigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a fully universe-polymorphic dependent pair. </code>",
 "93":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {α : Type u}      -- implicit\n    (a : α)           -- explicit\n    [instBEq : BEq α] -- instance implicit, named\n    [Hashable α]      -- instance implicit, anonymous\n\n  def isEqual (b : α) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : α} := a == b ↔ b == a\n\n  #check eqComm\n  -- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src × String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {α : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString α]  -- available in the proof as `α` is included\n  (a : α)       -- available in the proof as mentioned in the header\n  {β : Type}    -- not available in the proof\n  [ToString β]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString α]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "929":
 "<code>Prod.instWellFoundedRelation.{u, v} {α : Type u} {β : Type v} [ha : WellFoundedRelation α]\n  [hb : WellFoundedRelation β] : WellFoundedRelation (α × β)</code>",
 "928":
 "<code>PSigma.casesOn.{u_1, u, v} {α : Sort u} {β : α → Sort v} {motive : PSigma β → Sort u_1} (t : PSigma β)\n  (mk : (fst : α) → (snd : β fst) → motive ⟨fst, snd⟩) : motive t</code>",
 "927":
 "<code>invImage.{u_1, u_2} {α : Sort u_1} {β : Sort u_2} (f : α → β) (h : WellFoundedRelation β) : WellFoundedRelation α</code><span class=\"sep\"></span><code class=\"docstring\">The inverse image of a well-founded relation is well-founded.\n</code>",
 "926": "<code>(_ : Nat) ×' Nat</code>",
 "925":
 "<code>(y_1 : (_ : Nat) ×' Nat) →\n  (invImage (fun x =&gt; PSigma.casesOn x fun a a_1 =&gt; (a, a_1)) Prod.instWellFoundedRelation).1 y_1 ⟨x.succ, y.succ⟩ → Nat</code>",
 "924":
 "<code class=\"docstring\">Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n</code>",
 "923": "<code>y ≤ x</code>",
 "922": "<code>0 &lt; y</code>",
 "921":
 "<code class=\"docstring\">Manually prove that the termination measure (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n\nForces the use of well-founded recursion and is hence incompatible with\n`termination_by structural`.\n</code>",
 "920":
 "<code>Array.push.{u} {α : Type u} (a : Array α) (v : α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Adds an element to the end of an array. The resulting array's size is one greater than the input\narray. If there are no other references to the array, then it is modified in-place.\n\nThis takes amortized `O(1)` time because `Array α` is represented by a dynamic array.\n\nExamples:\n* `#[].push \"apple\" = #[\"apple\"]`\n* `#[\"apple\"].push \"orange\" = #[\"apple\", \"orange\"]`\n</code>",
 "92": "<code>doThrice (α : Type) (h : α → α) (x : α) : α</code>",
 "919": "<code>i &lt; as.size</code>",
 "918":
 "<code>takeWhile.go.{u_1} {α : Type u_1} (p : α → Bool) (as : Array α) (i : Nat) (r : Array α) : Array α</code>",
 "917":
 "<code>Array.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements\nfrom `α`. This type has special support in the runtime.\n\nArrays perform best when unshared. As long as there is never more than one reference to an array,\nall updates will be performed _destructively_. This results in performance comparable to mutable\narrays in imperative programming languages.\n\nAn array has a size and a capacity. The size is the number of elements present in the array, while\nthe capacity is the amount of memory currently allocated for elements. The size is accessible via\n`Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates\nan array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size\nexceeds the capacity, allocation is required to grow the array.\n\nFrom the point of view of proofs, `Array α` is just a wrapper around `List α`.\n</code>",
 "916": "<code>α → Bool</code>",
 "915":
 "<code>takeWhile.{u_1} {α : Type u_1} (p : α → Bool) (as : Array α) : Array α</code>",
 "914":
 "<code>Array.size.{u} {α : Type u} (a : Array α) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Gets the number of elements stored in an array.\n\nThis is a cached value, so it is `O(1)` to access. The space allocated for an array, referred to as\nits _capacity_, is at least as large as its size, but may be larger. The capacity of an array is an\ninternal detail that's not observable by Lean code.\n</code>",
 "913": "<code>Array α</code>",
 "912":
 "<code>SizeOf.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`SizeOf` is a typeclass automatically derived for every inductive type,\nwhich equips the type with a \"size\" function to `Nat`.\nThe default instance defines each constructor to be `1` plus the sum of the\nsizes of all the constructor fields.\n\nThis is used for proofs by well-founded induction, since every field of the\nconstructor has a smaller size than the constructor itself,\nand in many cases this will suffice to do the proof that a recursive function\nis only called on smaller values.\nIf the default proof strategy fails, it is recommended to supply a custom\nsize measure using the `termination_by` argument on the function definition.\n</code>",
 "911":
 "<code class=\"docstring\">The standardized \"low\" priority `low = 100`, for things that should be lower than default priority. </code>",
 "910": "<code>ack : Nat → Nat → Nat</code>",
 "91": "<code>α → α</code>",
 "909":
 "<code>WellFoundedRelation.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A type that has a standard well-founded relation.\n\nInstances are used to prove that functions terminate using well-founded recursion by showing that\nrecursive calls reduce some measure according to a well-founded relation. This relation can combine\nwell-founded relations on the recursive function's parameters.\n</code>",
 "908":
 "<code class=\"docstring\">Specify a termination measure for recursive functions.\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the arguments `a` and `b` decreases.\n\nIf the function takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c =&gt; a - b\n```\n\nBy default, a `termination_by` clause will cause the function to be constructed using well-founded\nrecursion. The syntax `termination_by structural a` (or `termination_by structural _ c =&gt; c`)\nindicates the function is expected to be structural recursive on the argument. In this case\nthe body of the `termination_by` clause must be one of the function's parameters.\n\nIf omitted, a termination measure will be inferred. If written as `termination_by?`,\nthe inferrred termination measure will be suggested.\n\n</code>",
 "907": "<code>natToBin : Nat → List Nat</code>",
 "906": "<code>x - y &lt; x</code>",
 "905":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n\nThis is the `conv` version of the `unfold` tactic.\n</code>",
 "904":
 "<code class=\"docstring\">Traverses into the left subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the second to last argument.\nIt is a synonym for `arg -2`.\n</code>",
 "903": "<code>div (x y : Nat) : Nat</code>",
 "902":
 "<code>WellFoundedRelation.wf.{u} {α : Sort u} [self : WellFoundedRelation α] : WellFounded WellFoundedRelation.rel</code><span class=\"sep\"></span><code class=\"docstring\">A proof that `rel` is, in fact, well-founded. </code>",
 "901":
 "<code>measure.{u} {α : Sort u} (f : α → Nat) : WellFoundedRelation α</code>",
 "900": "<code>div (x : Nat) : Nat → Nat</code>",
 "90": "<code>doTwice (α : Type) (h : α → α) (x : α) : α</code>",
 "9": "<code>m : Nat</code>",
 "899":
 "<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "898": "<code>(x₁ : Nat) → x₁ &lt; x → Nat → Nat</code>",
 "897":
 "<code>div.F (x : Nat) (f : (x₁ : Nat) → x₁ &lt; x → Nat → Nat) (y : Nat) : Nat</code>",
 "896":
 "<code>Nat.lt_of_lt_of_le {n m k : Nat} : n &lt; m → m ≤ k → n &lt; k</code>",
 "895":
 "<code>Nat.sub_lt {n m : Nat} : 0 &lt; n → 0 &lt; m → n - m &lt; n</code>",
 "894": "<code>div_lemma {x y : Nat} : 0 &lt; y ∧ y ≤ x → x - y &lt; x</code>",
 "893": "<code>(x : α) → ((y : α) → r y x → C y) → C x</code>",
 "892": "<code>α → Sort v</code>",
 "891": "<code>WellFounded r</code>",
 "890":
 "<code>f.{u, v} {α : Sort u} (r : α → α → Prop) (h : WellFounded r) (C : α → Sort v)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : C x</code>",
 "89": "<code>a</code>",
 "889":
 "<code>WellFounded.fix.{u, v} {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r)\n  (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α) : C x</code><span class=\"sep\"></span><code class=\"docstring\">A well-founded fixpoint. If satisfying the motive `C` for all values that are smaller according to a\nwell-founded relation allows it to be satisfied for the current value, then it is satisfied for all\nvalues.\n\nThis function is used as part of the elaboration of well-founded recursion.\n</code>",
 "888":
 "<code>WellFounded.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A relation `r` is `WellFounded` if all elements of `α` are accessible within `r`.\nIf a relation is `WellFounded`, it does not allow for an infinite descent along the relation.\n\nIf the arguments of the recursive calls in a function definition decrease according to\na well founded relation, then the function terminates.\nWell-founded relations are sometimes called _Artinian_ or said to satisfy the “descending chain condition”.\n</code>",
 "887":
 "<code>Acc.{u} {α : Sort u} (r : α → α → Prop) : α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Acc` is the accessibility predicate. Given some relation `r` (e.g. `&lt;`) and a value `x`,\n`Acc r x` means that `x` is accessible through `r`:\n\n`x` is accessible if there exists no infinite sequence `... &lt; y₂ &lt; y₁ &lt; y₀ &lt; x`.\n</code>",
 "886":
 "<code>length_replicate.aux.{u_1} {α : Type u_1} (a : α) (n : Nat) (as : List α) :\n  (replicate.loop a n as).length = n + as.length</code>",
 "885":
 "<code class=\"docstring\">`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. </code>",
 "884":
 "<code>length_replicate.{u_1} {α : Type u_1} (n : Nat) (a : α) : (replicate n a).length = n</code>",
 "883":
 "<code>replicate.loop.{u_1} {α : Type u_1} (a : α) : Nat → List α → List α</code>",
 "882":
 "<code>replicate.{u_1} {α : Type u_1} (n : Nat) (a : α) : List α</code>",
 "881":
 "<code>listAdd.{u_1} {α : Type u_1} [Add α] : List α → List α → List α</code>",
 "880": "<code>append.{u_1} {α : Type u_1} : List α → List α → List α</code>",
 "88": "<code>foo (x : Nat) : Nat</code>",
 "879": "<code>Nat → Type u</code>",
 "878":
 "<code>Nat.brecOn.{u} {motive : Nat → Sort u} (t : Nat) (F_1 : (t : Nat) → Nat.below t → motive t) : motive t</code>",
 "877":
 "<code>Nat.below.{u} {motive : Nat → Sort u} (t : Nat) : Sort (max 1 u)</code>",
 "876": "<code>fibFast.loop : Nat → Nat × Nat</code>",
 "875": "<code>fibFast (n : Nat) : Nat</code>",
 "874": "<code>fib : Nat → Nat</code>",
 "873": "<code>add (m : Nat) : Nat → Nat</code>",
 "872": "<code>mul : Nat → Nat → Nat</code>",
 "871": "<code>zero_add (n : Nat) : add zero n = n</code>",
 "870": "<code>add_succ (m n : Nat) : add m n.succ = (add m n).succ</code>",
 "87": "<code>Sort ?u.66</code>",
 "869": "<code>add_zero (m : Nat) : add m zero = m</code>",
 "868": "<code>add : Nat → Nat → Nat</code>",
 "867":
 "<code>Char : Type</code><span class=\"sep\"></span><code class=\"docstring\">Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).\n</code>",
 "866": "<code>foo : Char → Nat</code>",
 "865": "<code>bar : Nat → List Nat → Bool → Nat</code>",
 "864": "<code>f2 : Nat → Nat → Option Nat</code>",
 "863": "<code>f1 : Nat → Nat → Nat</code>",
 "862":
 "<code>Inhabited.default.{u} {α : Sort u} [self : Inhabited α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "861": "<code>tail2.{u} {α : Type u} : List α → List α</code>",
 "860": "<code>tail1.{u} {α : Type u} : List α → List α</code>",
 "86": "<code>t (x : Nat) : Nat</code>",
 "859": "<code>tail.{u_1} {α : Type u_1} : List α → List α</code>",
 "858": "<code>Hidden.cond.{u_1} {α : Sort u_1} : Bool → α → α → α</code>",
 "857": "<code>Hidden.or : Bool → Bool → Bool</code>",
 "856": "<code>Hidden.and : Bool → Bool → Bool</code>",
 "855": "<code>bar : List Nat → List Nat → Nat</code>",
 "854": "<code>foo : Nat → Nat → Nat</code>",
 "853":
 "<code>sub2.match_1.{u_1} (motive : Nat → Sort u_1) (x✝ : Nat) (h_1 : Unit → motive 0) (h_2 : Unit → motive 1)\n  (h_3 : (x : Nat) → motive x.succ.succ) : motive x✝</code>",
 "852": "<code>sub2 : Nat → Nat</code>",
 "851": "<code>Hidden.not_not (b : Bool) : not (not b) = b</code>",
 "850": "<code>Hidden.not : Bool → Bool</code>",
 "85": "<code>twice_double (x : Nat) : Nat</code>",
 "849": "<code>bar : Option Nat → Nat</code>",
 "848": "<code>foo : Nat × Nat → Nat</code>",
 "847":
 "<code>swap.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α × β → β × α</code>",
 "846": "<code>isZero : Nat → Bool</code>",
 "845": "<code>sub1 : Nat → Nat</code>",
 "844": "<code>Term.times (s t : Term) : Term</code>",
 "843": "<code>Term.plus (s t : Term) : Term</code>",
 "842": "<code>Term.var (n : Nat) : Term</code>",
 "841": "<code>Term.const (n : Nat) : Term</code>",
 "840": "<code>reverse.{u_1} {α : Type u_1} : List α → List α</code>",
 "84": "<code>Sort ?u.25</code>",
 "839": "<code>length.{u_1} {α : Type u_1} : List α → Nat</code>",
 "838": "<code>Tree.mk.{u} {α : Type u} : α → List (Tree α) → Tree α</code>",
 "837":
 "<code>TreeList.cons.{u} {α : Type u} : Tree α → TreeList α → TreeList α</code>",
 "836": "<code>TreeList.nil.{u} {α : Type u} : TreeList α</code>",
 "835": "<code>TreeList.{u} (α : Type u) : Type u</code>",
 "834": "<code>Tree.node.{u} {α : Type u} : α → TreeList α → Tree α</code>",
 "833": "<code>Tree.{u} (α : Type u) : Type u</code>",
 "832": "<code>Odd.odd_succ (n : Nat) : Even n → Odd (n + 1)</code>",
 "831": "<code>Odd : Nat → Prop</code>",
 "830": "<code>Even.even_succ (n : Nat) : Odd n → Even (n + 1)</code>",
 "83":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n</code>",
 "829": "<code>Even.even_zero : Even 0</code>",
 "828": "<code>Even : Nat → Prop</code>",
 "827": "<code>b = c</code>",
 "826":
 "<code>Hidden.congr.{u} {α β : Type u} {a b : α} (f : α → β) (h : a = b) : f a = f b</code>",
 "825":
 "<code>Hidden.trans.{u} {α : Type u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c</code>",
 "824":
 "<code>Hidden.symm.{u} {α : Type u} {a b : α} (h : a = b) : b = a</code>",
 "823":
 "<code>Eq.casesOn.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → @Eq.{u_1} α a✝ a → Sort u} {a✝¹ : α}\n  (t : @Eq.{u_1} α a✝ a✝¹) (refl : motive a✝ (@Eq.refl.{u_1} α a✝)) : motive a✝¹ t</code>",
 "822":
 "<code>Hidden.subst.{u} {α : Type u} {a b : α} {p : α → Prop} (h₁ : @Eq.{u + 1} α a b) (h₂ : p a) : p b</code>",
 "821":
 "<code>Eq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : α → Sort u1} (m : motive a) {b : α} (h : a = b) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">Non-dependent recursor for the equality type. </code>",
 "820":
 "<code>Eq.casesOn.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} {a✝¹ : α} (t : a✝ = a✝¹)\n  (refl : motive a✝ ⋯) : motive a✝¹ t</code>",
 "82": "<code>square (x : Nat) : Nat</code>",
 "819":
 "<code>Eq.rec.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} (refl : motive a✝ ⋯) {a✝¹ : α}\n  (t : a✝ = a✝¹) : motive a✝¹ t</code>",
 "818":
 "<code>Hidden.subst.{u} {α : Type u} {a b : α} {p : α → Prop} (h₁ : a = b) (h₂ : p a) : p b</code>",
 "817": "<code>(x : α) → a = x → Sort v</code>",
 "816":
 "<code>Eq.rec.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} (refl : motive a✝ (Eq.refl a✝)) {a✝¹ : α}\n  (t : a✝ = a✝¹) : motive a✝¹ t</code>",
 "815":
 "<code>pp.proofs</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display proofs when true, and replace proofs appearing within expressions by `⋯` when false</code>",
 "814": "<code>Hidden.Eq.refl.{u} {α : Sort u} {a : α} : Eq a a</code>",
 "813": "<code>Hidden.Eq.{u} {α : Sort u} (a : α) : α → Prop</code>",
 "812": "<code>Vect.nil.{u} {α : Type u} : Vect α 0</code>",
 "811": "<code>Vect.{u} (α : Type u) : Nat → Type u</code>",
 "810": "<code>7 = 4</code>",
 "81":
 "<code>compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ</code>",
 "809": "<code>m.succ = 0</code>",
 "808": "<code>m + 1 = n + 1</code>",
 "807": "<code>m.succ.succ = n.succ.succ</code>",
 "806":
 "<code class=\"docstring\">The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n</code>",
 "805": "<code>s</code>",
 "804":
 "<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>",
 "803": "<code>y &gt; x % y</code>",
 "802": "<code>Nat.mod_eq_of_lt {a b : Nat} (h : a &lt; b) : a % b = a</code>",
 "801": "<code>Nat.gt_of_not_le {n m : Nat} (h : ¬n ≤ m) : n &gt; m</code>",
 "800": "<code>y &gt; x</code>",
 "80": "<code>Nat → Nat</code>",
 "8":
 "<code>And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</code><span class=\"sep\"></span><code class=\"docstring\">`And.intro : a → b → a ∧ b` is the constructor for the And operation. </code>",
 "799": "<code>¬y ≤ x</code>",
 "798": "<code>¬0 &lt; y</code>",
 "797": "<code>¬0 &lt; y ∨ ¬y ≤ x</code>",
 "796":
 "<code>Decidable.not_and_iff_or_not {p q : Prop} [d₁ : Decidable p] [d₂ : Decidable q] : ¬(p ∧ q) ↔ ¬p ∨ ¬q</code>",
 "795": "<code>¬(0 &lt; y ∧ y ≤ x)</code>",
 "794":
 "<code>Nat.mod_eq_sub_mod {a b : Nat} (h : a ≥ b) : a % b = (a - b) % b</code>",
 "793": "<code>y &gt; 0 → (x - y) % y &lt; y</code>",
 "792": "<code>0 &lt; y ∧ y ≤ x</code>",
 "791":
 "<code>HMod.hMod.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMod α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `%` in identifiers is `mod`.</code>",
 "790":
 "<code>GT.gt.{u} {α : Type u} [LT α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a &gt; b` is an abbreviation for `b &lt; a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;` in identifiers is `gt`.</code>",
 "79": "<code>doTwice (f : Nat → Nat) (x : Nat) : Nat</code>",
 "789": "<code>y &gt; 0</code>",
 "788": "<code>(x y : Nat) → ¬(0 &lt; y ∧ y ≤ x) → motive x y</code>",
 "787":
 "<code>(x y : Nat) → 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y</code>",
 "786": "<code>Nat → Nat → Sort u</code>",
 "785":
 "<code>Nat.mod.inductionOn.{u} {motive : Nat → Nat → Sort u} (x y : Nat)\n  (ind : (x y : Nat) → 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y)\n  (base : (x y : Nat) → ¬(0 &lt; y ∧ y ≤ x) → motive x y) : motive x y</code><span class=\"sep\"></span><code class=\"docstring\">An induction principle customized for reasoning about the recursion pattern of `Nat.mod`.\n</code>",
 "784": "<code>m + n + a✝ = m + (n + a✝)</code>",
 "783": "<code>m + a✝ = a✝ + m</code>",
 "782": "<code>m.succ + a✝ = (m + a✝).succ</code>",
 "781": "<code>Hidden.succ_add (m n : Nat) : m.succ + n = (m + n).succ</code>",
 "780": "<code>0 + a✝ = a✝</code>",
 "78": "<code>greater (x y : Nat) : Nat</code>",
 "779": "<code>Hidden.add_succ (n k : Nat) : n + k.succ = (n + k).succ</code>",
 "778": "<code>Hidden.add_zero (n : Nat) : n + 0 = n</code>",
 "777": "<code>Hidden.zero_zero : Nat.zero = 0</code>",
 "776":
 "<code>Nat</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "775":
 "<code>OfNat.{u} (α : Type u) : _root_.Nat → Type u</code><span class=\"sep\"></span><code class=\"docstring\">The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, Lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that Lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n</code>",
 "774": "<code>_root_.Nat</code>",
 "773":
 "<code>_root_.Nat.zero : _root_.Nat</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "772": "<code>Hidden.Nat.ofNat : _root_.Nat → Nat</code>",
 "771":
 "<code>_root_.Nat.succ (n : _root_.Nat) : _root_.Nat</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "770":
 "<code>_root_.Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "77": "<code>add (x y : Nat) : Nat</code>",
 "769": "<code>Hidden.Nat.toNat : Nat → _root_.Nat</code>",
 "768": "<code>0 + n✝ = n✝</code>",
 "767":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>",
 "766": "<code>¬m = n</code>",
 "765": "<code>Nat.sub_self (n : Nat) : n - n = 0</code>",
 "764": "<code>m = n</code>",
 "763": "<code>Decidable.em (p : Prop) [Decidable p] : p ∨ ¬p</code>",
 "762":
 "<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "761": "<code>m &lt; n ∨ m ≥ n</code>",
 "760": "<code>m ≥ n</code>",
 "76": "<code>pi : Float</code>",
 "759": "<code>m &lt; n</code>",
 "758": "<code>Nat.lt_or_ge (n m : Nat) : n &lt; m ∨ n ≥ m</code>",
 "757": "<code>m ≥ n → p</code>",
 "756": "<code>m &lt; n → p</code>",
 "755": "<code>Foo.bar2 : Nat → Nat → Nat → Foo</code>",
 "754": "<code>silly (x : Foo) : Nat</code>",
 "753": "<code>Foo.bar1 : Nat → Nat → Foo</code>",
 "752":
 "<code>Subtype.mk.{u} {α : Sort u} {p : α → Prop} (val : α) (property : p val) : Subtype p</code>",
 "751": "<code>myTuple : Tuple Nat 3</code>",
 "750": "<code>Tuple α (n✝ + 1)</code>",
 "75": "<code>double : Nat → Nat</code>",
 "749": "<code>f {α : Type} {n : Nat} (t : Tuple α n) : Nat</code>",
 "748": "<code>f (n : Nat) : Nat</code>",
 "747":
 "<code>Nat.pred : Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The predecessor of a natural number is one less than it. The predecessor of `0` is defined to be\n`0`.\n\nThis definition is overridden in the compiler with an efficient implementation. This definition is\nthe logical model.\n</code>",
 "746": "<code>m + 1 ≠ 0</code>",
 "745": "<code>0 ≠ 0</code>",
 "744": "<code>n ≠ 0</code>",
 "743": "<code>∀ (n : Nat), p n.succ</code>",
 "742": "<code>p 0</code>",
 "741": "<code>InductiveType</code>",
 "740": "<code>CBTree.omega : CBTree</code>",
 "74": "<code>double (x : Nat) : Nat</code>",
 "739": "<code>CBTree.toCBTree : Nat → CBTree</code>",
 "738": "<code>CBTree</code>",
 "737": "<code>CBTree.succ (t : CBTree) : CBTree</code>",
 "736": "<code>CBTree.sup : (Nat → CBTree) → CBTree</code>",
 "735": "<code>CBTree.leaf : CBTree</code>",
 "734": "<code>CBTree : Type</code>",
 "733": "<code>BinaryTree.leaf : BinaryTree</code>",
 "732": "<code>BinaryTree : Type</code>",
 "731": "<code>append.{u} {α : Type u} : List α → List α → List α</code>",
 "730": "<code>length.{u} {α : Type u} : List α → Nat</code>",
 "73": "<code>Sort ?u.275</code>",
 "729":
 "<code>Hidden.List.append_assoc.{u_1} {α : Type u_1} (as bs cs : List α) : (as.append bs).append cs = as.append (bs.append cs)</code>",
 "728":
 "<code>Hidden.List.append_nil.{u_1} {α : Type u_1} (as : List α) : as.append nil = as</code>",
 "727": "<code>Hidden.List.cons.{u} {α : Type u} : α → List α → List α</code>",
 "726":
 "<code>Hidden.List.cons_append.{u_1} {α : Type u_1} (a : α) (as bs : List α) : (cons a as).append bs = cons a (as.append bs)</code>",
 "725":
 "<code>Hidden.List.nil_append.{u_1} {α : Type u_1} (as : List α) : nil.append as = as</code>",
 "724":
 "<code>Hidden.List.append.{u_1} {α : Type u_1} (as bs : List α) : List α</code>",
 "723":
 "<code>Hidden.List.cons.{u} {α : Type u} (h : α) (t : List α) : List α</code>",
 "722": "<code>Hidden.List.nil.{u} {α : Type u} : List α</code>",
 "721": "<code>Hidden.List.{u} (α : Type u) : Type u</code>",
 "720":
 "<code class=\"docstring\">`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n</code>",
 "72": "<code>Sort ?u.90</code>",
 "719": "<code>(fun x =&gt; m✝ + x = x + m✝) m</code>",
 "718": "<code>Hidden.add_comm (m n : Nat) : m + n = n + m</code>",
 "717": "<code>(fun x =&gt; n.succ + x = (n + x).succ) m</code>",
 "716": "<code>Hidden.succ_add (n m : Nat) : n.succ + m = (n + m).succ</code>",
 "715":
 "<code class=\"docstring\">This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n</code>",
 "714": "<code>(fun x =&gt; zero + x = x) n</code>",
 "713":
 "<code>Hidden.Nat.recOn.{u} {motive : Nat → Sort u} (t : Nat) (zero : motive zero)\n  (succ : (a : Nat) → motive a → motive a.succ) : motive t</code>",
 "712": "<code>Hidden.Nat.zero_add (n : Nat) : zero + n = n</code>",
 "711": "<code>n.succ + m = (n + m).succ</code>",
 "710": "<code>succ_add (n m : Nat) : n.succ + m = (n + m).succ</code>",
 "71": "<code>Sort ?u.52</code>",
 "709": "<code>m + n = n + m</code>",
 "708": "<code>add_comm (m n : Nat) : m + n = n + m</code>",
 "707": "<code>Nat.add_succ (n m : Nat) : n + m.succ = (n + m).succ</code>",
 "706": "<code>(fun k =&gt; m + n + k = m + (n + k)) k</code>",
 "705": "<code>add_assoc (m n k : Nat) : m + n + k = m + (n + k)</code>",
 "704": "<code>m + n + k = m + (n + k)</code>",
 "703": "<code>Hidden.add_assoc (m n k : Nat) : m + n + k = m + (n + k)</code>",
 "702": "<code>?m.108 m n</code>",
 "701": "<code>?m.107 m</code>",
 "700": "<code>?m.75</code>",
 "70": "<code>Sort ?u.51</code>",
 "7":
 "<code>And.right {a b : Prop} (self : a ∧ b) : b</code><span class=\"sep\"></span><code class=\"docstring\">Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. </code>",
 "699": "<code>(fun x =&gt; 0 + x = x) n</code>",
 "698": "<code>0 + n = n</code>",
 "697":
 "<code>Nat.recOn.{u} {motive : Nat → Sort u} (t : Nat) (zero : motive zero) (succ : (n : Nat) → motive n → motive n.succ) :\n  motive t</code>",
 "696": "<code>Hidden.zero_add (n : Nat) : 0 + n = n</code>",
 "695": "<code>motive n</code>",
 "694":
 "<code>Hidden.Nat.add_succ (m n : Nat) : m + n.succ = (m + n).succ</code>",
 "693": "<code>Hidden.Nat.add_zero (m : Nat) : m + zero = m</code>",
 "692":
 "<code>Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "691": "<code>Hidden.Nat.add (m n : Nat) : Nat</code>",
 "690": "<code>Hidden.add (m n : Nat) : Nat</code>",
 "69": "<code>Sort ?u.223</code>",
 "689": "<code>Hidden.Nat.succ : Nat → Nat</code>",
 "688": "<code>add (m n : Nat) : Nat</code>",
 "687": "<code>(n : Nat) → motive n → motive n.succ</code>",
 "686": "<code>motive Nat.zero</code>",
 "685": "<code>Nat → Sort u</code>",
 "684": "<code>(n : Nat) → motive n</code>",
 "683": "<code>Hidden.Nat.zero : Nat</code>",
 "682": "<code>Hidden.Nat : Type</code>",
 "681":
 "<code>Subtype.{u} {α : Sort u} (p : α → Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : α // p x }` or `{ x // p x }`, contains all elements `x : α` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : α // p x }` is represented identically to `α`.\n\nThere is a coercion from `{ x : α // p x }` to `α`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List α`, `List { x : α // x ∈ xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`.</code>",
 "680":
 "<code>Hidden.Subtype.property.{u} {α : Sort u} {p : α → Prop} (self : Subtype p) : p self.val</code>",
 "68": "<code>b.{u_1} {γ : Sort u_1} : γ</code>",
 "679":
 "<code>Hidden.Subtype.val.{u} {α : Sort u} {p : α → Prop} (self : Subtype p) : α</code>",
 "678":
 "<code>Hidden.Subtype.{u} {α : Sort u} (p : α → Prop) : Sort (max 1 u)</code>",
 "677":
 "<code>Hidden.Subtype.mk.{u} {α : Type u} {p : α → Prop} (x : α) : p x → Subtype p</code>",
 "676": "<code>Hidden.Subtype.{u} {α : Type u} (p : α → Prop) : Type u</code>",
 "675":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "674":
 "<code>Empty : Type</code><span class=\"sep\"></span><code class=\"docstring\">The empty type. It has no constructors.\n\nUse `Empty.elim` in contexts where a value of type `Empty` is in scope.\n</code>",
 "673":
 "<code>Hidden.Exists.intro.{u} {α : Sort u} {p : α → Prop} (w : α) (h : p w) : Exists p</code>",
 "672": "<code>Hidden.Exists.{u} {α : Sort u} (p : α → Prop) : Prop</code>",
 "671": "<code>Hidden.Or.inl {a b : Prop} : a → Or a b</code>",
 "670": "<code>Hidden.Or (a b : Prop) : Prop</code>",
 "67": "<code>Sort ?u.193</code>",
 "669": "<code>Hidden.And.intro {a b : Prop} : a → b → And a b</code>",
 "668": "<code>Hidden.And (a b : Prop) : Prop</code>",
 "667": "<code>Hidden.True.intro : True</code>",
 "666": "<code>Hidden.True : Prop</code>",
 "665": "<code>Hidden.False : Prop</code>",
 "664": "<code>Type u'</code>",
 "663":
 "<code>Inhabited.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n</code>",
 "662": "<code>α → Option β</code>",
 "661": "<code>Hidden.Inhabited.mk.{u} {α : Type u} : α → Inhabited α</code>",
 "660": "<code>Hidden.Inhabited.{u} (α : Type u) : Type u</code>",
 "66": "<code>β → γ</code>",
 "659": "<code>Hidden.Option.none.{u} {α : Type u} : Option α</code>",
 "658": "<code>Hidden.Option.{u} (α : Type u) : Type u</code>",
 "657":
 "<code>Hidden.Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (a : α) : β a → Sigma β</code>",
 "656":
 "<code>Hidden.Sigma.{u, v} {α : Type u} (β : α → Type v) : Type (max u v)</code>",
 "655": "<code>carrier → carrier → carrier</code>",
 "654": "<code>carrier</code>",
 "653":
 "<code>Semigroup.mul_assoc.{u} (self : Semigroup) (a b c : self.carrier) :\n  self.mul (self.mul a b) c = self.mul a (self.mul b c)</code>",
 "652":
 "<code>Semigroup.mul.{u} (self : Semigroup) : self.carrier → self.carrier → self.carrier</code>",
 "651": "<code>Semigroup.carrier.{u} (self : Semigroup) : Type u</code>",
 "650": "<code>Semigroup.{u} : Type (u + 1)</code>",
 "65": "<code>String → Bool</code>",
 "649": "<code>Color.mk (red green blue : Nat) : Color</code>",
 "648": "<code>yellow : Color</code>",
 "647": "<code>Color.blue (self : Color) : Nat</code>",
 "646": "<code>Color.green (self : Color) : Nat</code>",
 "645": "<code>Color.red (self : Color) : Nat</code>",
 "644": "<code>Color : Type</code>",
 "643":
 "<code>Hidden.Prod.snd.{u, v} {α : Type u} {β : Type v} (self : Prod α β) : β</code>",
 "642":
 "<code>Hidden.Prod.fst.{u, v} {α : Type u} {β : Type v} (self : Prod α β) : α</code>",
 "641":
 "<code>Hidden.Sum.inl.{u, v} {α : Type u} {β : Type v} (a : α) : Sum α β</code>",
 "640":
 "<code>Hidden.Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : Prod α β</code>",
 "64": "<code>Nat → String</code>",
 "639": "<code>(fun x =&gt; Nat) (Sum.inr n)</code>",
 "638": "<code>(fun x =&gt; Nat) (Sum.inl n)</code>",
 "637":
 "<code>Sum.casesOn.{u_1, u, v} {α : Type u} {β : Type v} {motive : α ⊕ β → Sort u_1} (t : α ⊕ β)\n  (inl : (val : α) → motive (Sum.inl val)) (inr : (val : β) → motive (Sum.inr val)) : motive t</code>",
 "636": "<code>Nat ⊕ Nat</code>",
 "635": "<code>sum_example (s : Nat ⊕ Nat) : Nat</code>",
 "634": "<code>(fun x =&gt; Nat) (b, n)</code>",
 "633":
 "<code>cond.{u} {α : Sort u} (c : Bool) (x y : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The conditional function.\n\n`cond c x y` is the same as `if c then x else y`, but optimized for a Boolean condition rather than\na decidable proposition. It can also be written using the notation `bif c then x else y`.\n\nJust like `ite`, `cond` is declared `@[macro_inline]`, which causes applications of `cond` to be\nunfolded. As a result, `x` and `y` are not evaluated at runtime until one of them is selected, and\nonly the selected branch is evaluated.\n</code>",
 "632": "<code>Bool × Nat</code>",
 "631": "<code>prod_example (p : Bool × Nat) : Nat</code>",
 "630":
 "<code>Prod.casesOn.{u_1, u, v} {α : Type u} {β : Type v} {motive : α × β → Sort u_1} (t : α × β)\n  (mk : (fst : α) → (snd : β) → motive (fst, snd)) : motive t</code>",
 "63":
 "<code>String.length : String → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Returns the length of a string in Unicode code points.\n\nExamples:\n* `\"\".length = 0`\n* `\"abc\".length = 3`\n* `\"L∃∀N\".length = 4`\n</code>",
 "629":
 "<code>Hidden.snd.{u, v} {α : Type u} {β : Type v} (p : Prod α β) : β</code>",
 "628": "<code>Prod α β</code>",
 "627":
 "<code>Hidden.fst.{u, v} {α : Type u} {β : Type v} (p : Prod α β) : α</code>",
 "626":
 "<code>Hidden.Sum.inl.{u, v} {α : Type u} {β : Type v} : α → Sum α β</code>",
 "625":
 "<code>Hidden.Sum.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "624":
 "<code>Hidden.Prod.mk.{u, v} {α : Type u} {β : Type v} : α → β → Prod α β</code>",
 "623":
 "<code>Hidden.Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>",
 "622": "<code>Hidden.and (a b : Bool) : Bool</code>",
 "621":
 "<code>Bool.or (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “or”, also known as disjunction. `or x y` can be written `x || y`.\n\nThe corresponding propositional connective is `Or : Prop → Prop → Prop`, written with the `∨`\noperator.\n\nThe Boolean `or` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `true` then `y` is not evaluated at runtime.\n</code>",
 "620":
 "<code>Bool.and (x y : Bool) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean “and”, also known as conjunction. `and x y` can be written `x && y`.\n\nThe corresponding propositional connective is `And : Prop → Prop → Prop`, written with the `∧`\noperator.\n\nThe Boolean `and` is a `@[macro_inline]` function in order to give it short-circuiting evaluation:\nif `x` is `false` then `y` is not evaluated at runtime.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&&` in identifiers is `and`.\n\n * The recommended spelling of `||` in identifiers is `or`.</code>",
 "62": "<code>String</code>",
 "619": "<code>Hidden.Bool.false : Bool</code>",
 "618": "<code>Hidden.Bool : Type</code>",
 "617":
 "<code>Weekday.next_previous (d : Weekday) : d.previous.next = d</code>",
 "616": "<code>Weekday.previous (d : Weekday) : Weekday</code>",
 "615": "<code>Weekday.next (d : Weekday) : Weekday</code>",
 "614":
 "<code>Repr.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A typeclass that specifies the standard way of turning values of some type into `Format`.\n\nWhen rendered this `Format` should be as close as possible to something that can be parsed as the\ninput value.\n</code>",
 "613":
 "<code>Weekday.casesOn.{u} {motive : Weekday → Sort u} (t : Weekday) (sunday : motive Weekday.sunday)\n  (monday : motive Weekday.monday) (tuesday : motive Weekday.tuesday) (wednesday : motive Weekday.wednesday)\n  (thursday : motive Weekday.thursday) (friday : motive Weekday.friday) (saturday : motive Weekday.saturday) : motive t</code>",
 "612":
 "<code>numberOfDay.match_1.{u_1} (motive : Weekday → Sort u_1) (d✝ : Weekday) (h_1 : Unit → motive Weekday.sunday)\n  (h_2 : Unit → motive Weekday.monday) (h_3 : Unit → motive Weekday.tuesday) (h_4 : Unit → motive Weekday.wednesday)\n  (h_5 : Unit → motive Weekday.thursday) (h_6 : Unit → motive Weekday.friday) (h_7 : Unit → motive Weekday.saturday) :\n  motive d✝</code>",
 "611": "<code>numberOfDay (d : Weekday) : Nat</code>",
 "610": "<code>Weekday</code>",
 "61": "<code>g (s : String) : Bool</code>",
 "609": "<code>motive Weekday.saturday</code>",
 "608": "<code>motive Weekday.friday</code>",
 "607": "<code>motive Weekday.thursday</code>",
 "606": "<code>motive Weekday.wednesday</code>",
 "605": "<code>motive Weekday.tuesday</code>",
 "604": "<code>motive Weekday.monday</code>",
 "603": "<code>motive Weekday.sunday</code>",
 "602": "<code>Weekday → Sort u</code>",
 "601":
 "<code>Weekday.rec.{u} {motive : Weekday → Sort u} (sunday : motive Weekday.sunday) (monday : motive Weekday.monday)\n  (tuesday : motive Weekday.tuesday) (wednesday : motive Weekday.wednesday) (thursday : motive Weekday.thursday)\n  (friday : motive Weekday.friday) (saturday : motive Weekday.saturday) (t : Weekday) : motive t</code>",
 "600": "<code>Weekday.saturday : Weekday</code>",
 "60":
 "<code>ToString.toString.{u} {α : Type u} [self : ToString α] : α → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "6": "<code>q</code>",
 "599": "<code>Weekday.friday : Weekday</code>",
 "598": "<code>Weekday.thursday : Weekday</code>",
 "597": "<code>Weekday.wednesday : Weekday</code>",
 "596": "<code>Weekday.tuesday : Weekday</code>",
 "595": "<code>Weekday.monday : Weekday</code>",
 "594": "<code>Weekday.sunday : Weekday</code>",
 "593": "<code>Weekday : Type</code>",
 "592": "<code>Foo {α β ω : Type} : Type</code>",
 "591": "<code>Sort v</code>",
 "590": "<code>Sort u</code>",
 "59":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode code points.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "589": "<code>getBinderType : Term → Option Term</code>",
 "588": "<code>Term.lambda (name : String) (type body : Term) : Term</code>",
 "587": "<code>getBinderName : Term → Option String</code>",
 "586": "<code>Term</code>",
 "585": "<code>Term.app (fn arg : Term) : Term</code>",
 "584": "<code>Term.num (val : Nat) : Term</code>",
 "583": "<code>Term.var (name : String) : Term</code>",
 "582": "<code>Term : Type</code>",
 "581":
 "<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List α` is the list of elements of type `α`, and is defined as follows:\n```\ninductive List (α : Type u) where\n| nil\n| cons (head : α) (tail : List α)\n```\nA list of elements of type `α` is either the empty list, `nil`,\nor an element `head : α` followed by a list `tail : List α`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "580": "<code>Type ?u.1873</code>",
 "58": "<code>f (n : Nat) : String</code>",
 "579":
 "<code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Some value of type `α`. </code>",
 "578":
 "<code>Option.none.{u} {α : Type u} : Option α</code><span class=\"sep\"></span><code class=\"docstring\">No value. </code>",
 "577":
 "<code>Option.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Optional values, which are either `some` around a value from the underlying type or `none`.\n\n`Option` can represent nullable types or computations that might fail. In the codomain of a function\ntype, it can also represent partiality.\n</code>",
 "576": "<code>optParam (Option α) none</code>",
 "575":
 "<code>Add.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. </code>",
 "574":
 "<code>g.{u_1} {α : Type u_1} [Add α] (a : α) (b? : Option α := none) (c : α) : α</code>",
 "573": "<code>optParam Nat 2</code>",
 "572": "<code>optParam Nat 1</code>",
 "571":
 "<code>f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) : Nat</code>",
 "570": "<code>b = a</code>",
 "57":
 "<code>Bool.not : Bool → Bool</code><span class=\"sep\"></span><code class=\"docstring\">Boolean negation, also known as Boolean complement. `not x` can be written `!x`.\n\nThis is a function that maps the value `true` to `false` and the value `false` to `true`. The\npropositional connective is `Not : Prop → Prop`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `!` in identifiers is `not`.</code>",
 "569": "<code>p a b b</code>",
 "568": "<code>Nat → Nat → Nat → Prop</code>",
 "567": "<code>sum (xs : List Nat) : Nat</code>",
 "566":
 "<code>List.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].map f = [f a, f b, f c]`\n* `[].map Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "565": "<code>Ex3.f (x y z : Nat) : Nat</code>",
 "564":
 "<code>List.foldl.{u, v} {α : Type u} {β : Type v} (f : α → β → α) (init : α) : List β → α</code><span class=\"sep\"></span><code class=\"docstring\">Folds a function over a list from the left, accumulating a value starting with `init`. The\naccumulated value is combined with the each element of the list in order, using `f`.\n\nExamples:\n * `[a, b, c].foldl f z  = f (f (f z a) b) c`\n * `[1, 2, 3].foldl (· ++ toString ·) \"\" = \"123\"`\n * `[1, 2, 3].foldl (s!\"({·} {·})\") \"\" = \"((( 1) 2) 3)\"`\n</code>",
 "563": "<code>Ex2.id5 {α : Type} : α → α</code>",
 "562": "<code>Ex2.id4 {α : Type} : α → α</code>",
 "561": "<code>Ex2.id3 {α : Type} : α → α</code>",
 "560": "<code>Ex2.id2 {α : Type} : α → α</code>",
 "56":
 "<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "559": "<code>Ex2.listId : List ({α : Type} → α → α)</code>",
 "558": "<code>α✝</code>",
 "557": "<code>Ex2.id1 {α : Type} : α → α</code>",
 "556":
 "<code>ReaderT.bind.{u, v} {ρ : Type u} {m : Type u → Type v} [Monad m] {α β : Type u} (x : ReaderT ρ m α)\n  (f : α → ReaderT ρ m β) : ReaderT ρ m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two reader monad computations. Both are provided with the local value, and the second is\npassed the value of the first. Typically used via the `&gt;&gt;=` operator.\n</code>",
 "555":
 "<code>{α β : Type} → ReaderT ρ m α → (α → ReaderT ρ m β) → ReaderT ρ m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "554":
 "<code>ReaderT.{u, v} (ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds the ability to access a read-only value of type `ρ` to a monad. The value can be locally\noverridden by `withReader`, but it cannot be mutated.\n\nActions in the resulting monad are functions that take the local value as a parameter, returning\nordinary actions in `m`.\n</code>",
 "553":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "552": "<code>Type → Type</code>",
 "551":
 "<code>ReaderT.pure.{u, v} {ρ : Type u} {m : Type u → Type v} [Monad m] {α : Type u} (a : α) : ReaderT ρ m α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the provided value `a`, ignoring the reader monad's local value. Typically used via\n`Pure.pure`.\n</code>",
 "550":
 "<code>{α : Type} → α → ReaderT ρ m α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "55": "<code>Bool</code>",
 "549": "<code>sorry</code>",
 "548": "<code>sorry → sorry</code>",
 "547":
 "<code>compose.{u_1, u_2, u_3} (g : sorry → sorry) (f : sorry → sorry) (x : sorry) : sorry</code>",
 "546":
 "<code>autoImplicit</code><span class=\"sep\"></span><code class=\"docstring\">Unbound local variables in declaration headers become implicit arguments. In \"relaxed\" mode (default), any atomic identifier is eligible, otherwise only single character followed by numeric digits are eligible. For example, `def f (x : Vector α n) : Vector α n :=` automatically introduces the implicit variables {α n}.</code>",
 "545":
 "<code>compose.{u_1, u_2, u_3} {β : Sort u_1} {γ : Sort u_2} {α : Sort u_3} (g : β → γ) (f : α → β) (x : α) : γ</code>",
 "544": "<code class=\"docstring\">The universe parameter w</code>",
 "543": "<code>Type w</code>",
 "542":
 "<code>compose.{u, v, w} {α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) (x : α) : γ</code>",
 "541":
 "<code>And.casesOn.{u} {a b : Prop} {motive : a ∧ b → Sort u} (t : a ∧ b) (intro : (left : a) → (right : b) → motive ⋯) :\n  motive t</code>",
 "540":
 "<code>Prod.snd.{u, v} {α : Type u} {β : Type v} (self : α × β) : β</code><span class=\"sep\"></span><code class=\"docstring\">The second element of a pair. </code>",
 "54": "<code>Sort ?u.153</code>",
 "539":
 "<code>Prod.fst.{u, v} {α : Type u} {β : Type v} (self : α × β) : α</code><span class=\"sep\"></span><code class=\"docstring\">The first element of a pair. </code>",
 "538":
 "<code>Nat.le_of_succ_le_succ {n m : Nat} : n.succ ≤ m.succ → n ≤ m</code>",
 "537": "<code>Nat.succ_ne_zero (n : Nat) : n.succ ≠ 0</code>",
 "536":
 "<code>pp.all</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing</code>",
 "535":
 "<code class=\"docstring\">`#reduce &lt;expression&gt;` reduces the expression `&lt;expression&gt;` to its normal form. This\ninvolves applying reduction rules until no further reduction is possible.\n\nBy default, proofs and types within the expression are not reduced. Use modifiers\n`(proofs := true)`  and `(types := true)` to reduce them.\nRecall that propositions are types in Lean.\n\n**Warning:** This can be a computationally expensive operation,\nespecially for complex expressions.\n\nConsider using `#eval &lt;expression&gt;` for simple evaluation/execution\nof expressions.\n</code>",
 "534":
 "<code>pp.notation</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) disable/enable notation (infix, mixfix, postfix operators and unicode characters)</code>",
 "533":
 "<code>pp.universes</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display universe</code>",
 "532": "<code>foo.{u} {α : Type u} (x : α) : α</code>",
 "531":
 "<code>Int.ofNat : Nat → Int</code><span class=\"sep\"></span><code class=\"docstring\">A natural number is an integer.\n\nThis constructor covers the non-negative integers (from `0` to `∞`).\n</code>",
 "530": "<code><span class=\"literal string\">\" : \"</span> : String</code>",
 "53": "<code>Sort ?u.137</code>",
 "529": "<code><span class=\"literal string\">\" ⊢ \"</span> : String</code>",
 "528": "<code><span class=\"literal string\">\")\"</span> : String</code>",
 "527": "<code><span class=\"literal string\">\"(\"</span> : String</code>",
 "526":
 "<code>quotPrecheck</code><span class=\"sep\"></span><code class=\"docstring\">Enable eager name analysis on notations in order to find unbound identifiers early.\nNote that type-sensitive syntax (\"elaborators\") needs special support for this kind of check, so it might need to be turned off when using such syntax.</code>",
 "525": "<code>γ</code>",
 "524": "<code><span class=\"literal string\">\" ~ \"</span> : String</code>",
 "523": "<code>Sort u_3</code>",
 "522": "<code>Sort u_2</code>",
 "521":
 "<code>wobble.{u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} : α → β → γ</code>",
 "520":
 "<code>Inv.inv.{u} {α : Type u} [self : Inv α] : α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a⁻¹` computes the inverse of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⁻¹` in identifiers is `inv`.</code>",
 "52": "<code>Sort ?u.121</code>",
 "519": "<code><span class=\"literal string\">\"⁻¹\"</span> : String</code>",
 "518":
 "<code class=\"docstring\">Maximum precedence used in term parsers, in particular for terms in\nfunction position (`ident`, `paren`, ...)\n</code>",
 "517":
 "<code>Neg.neg.{u} {α : Type u} [self : Neg α] : α → α</code><span class=\"sep\"></span><code class=\"docstring\">`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `neg` (when used as a unary operator).</code>",
 "516": "<code><span class=\"literal string\">\"-\"</span> : String</code>",
 "515":
 "<code>HPow.hPow.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HPow α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "514": "<code><span class=\"literal string\">\" ^ \"</span> : String</code>",
 "513": "<code><span class=\"literal string\">\" = \"</span> : String</code>",
 "512": "<code><span class=\"literal string\">\" + \"</span> : String</code>",
 "511": "<code>Sort ?u.348</code>",
 "510": "<code>Sort ?u.413</code>",
 "51": "<code>Sort ?u.119</code>",
 "509":
 "<code>th3.{u} {α : Type u} {r : α → α → Prop} (reflr : reflexive r) (euclr : Euclidean r) : transitive r</code>",
 "508": "<code>symmetric r</code>",
 "507":
 "<code>th2.{u} {α : Type u} {r : α → α → Prop} (symmr : symmetric r) (euclr : Euclidean r) : transitive r</code>",
 "506": "<code>Euclidean r</code>",
 "505": "<code>reflexive r</code>",
 "504":
 "<code>th1.{u} {α : Type u} {r : α → α → Prop} (reflr : reflexive r) (euclr : Euclidean r) : symmetric r</code>",
 "503": "<code>Euclidean.{u} {α : Type u} (r : α → α → Prop) : Prop</code>",
 "502": "<code>transitive.{u} {α : Type u} (r : α → α → Prop) : Prop</code>",
 "501": "<code>symmetric.{u} {α : Type u} (r : α → α → Prop) : Prop</code>",
 "500": "<code>reflexive.{u} {α : Type u} (r : α → α → Prop) : Prop</code>",
 "50": "<code>Sort ?u.101</code>",
 "5":
 "<code>And.left {a b : Prop} (self : a ∧ b) : a</code><span class=\"sep\"></span><code class=\"docstring\">Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. </code>",
 "499": "<code>f (x : Nat) ⦃y : Nat⦄ (z : Nat) : Nat</code>",
 "498": "<code>f (x : Nat) {y : Nat} (z : Nat) : Nat</code>",
 "497": "<code>instLe.{u_1} {α : Type u_1} : LE (List α)</code>",
 "496":
 "<code>List.isPrefix_self.{u_1} {α : Type u_1} (as : List α) : as ≤ as</code>",
 "495":
 "<code>List α → List α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "494":
 "<code>LE.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.</code>",
 "493":
 "<code>List.isPrefix_self.{u_1} {α : Type u_1} (as : List α) : isPrefix as as</code>",
 "492": "<code>isPrefix.{u_1} {α : Type u_1} (l₁ l₂ : List α) : Prop</code>",
 "491":
 "<code>Nat.sub : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Subtraction of natural numbers, truncated at `0`. Usually used via the `-` operator.\n\nIf a result would be less than zero, then the result is zero.\n\nThis definition is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n\nExamples:\n* `5 - 3 = 2`\n* `8 - 2 = 6`\n* `8 - 8 = 0`\n* `8 - 20 = 0`\n</code>",
 "490":
 "<code class=\"docstring\">Adds names from other namespaces to the current namespace.\n\nThe command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:\n\n- visible in the current namespace without prefix `Some.Namespace`, like `open`, and\n- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.\n\n## Examples\n\n```lean\nnamespace Morning.Sky\n  def star := \"venus\"\nend Morning.Sky\n\nnamespace Evening.Sky\n  export Morning.Sky (star)\n  -- `star` is now in scope\n  #check star\nend Evening.Sky\n\n-- `star` is visible in `Evening.Sky`\n#check Evening.Sky.star\n```\n</code>",
 "49": "<code>Sort ?u.83</code>",
 "489":
 "<code>Nat.mul : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Multiplication of natural numbers, usually accessed via the `*` operator.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n</code>",
 "488":
 "<code>Nat.gcd (m n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Computes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n</code>",
 "487":
 "<code>Nat.zero : Nat</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "486":
 "<code>Nat.recOn.{u} {motive : Nat → Sort u} (t : Nat) (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive n.succ) :\n  motive t</code>",
 "485":
 "<code>Nat.rec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive n.succ) (t : Nat) :\n  motive t</code>",
 "484": "<code><span class=\"literal string\">\"world\"</span> : String</code>",
 "483": "<code>add (α β : Type) : Type</code>",
 "482": "<code>Bool.add (a b : Bool) : Bool</code>",
 "481": "<code>String.add (a b : String) : String</code>",
 "480": "<code>Foo.bar : Nat</code>",
 "48": "<code>Sort ?u.71</code>",
 "479": "<code>t2 (x y : Nat) : double (x * y) = double x * y</code>",
 "478": "<code>t1 (x y : Nat) : double (x + y) = double x + double y</code>",
 "477":
 "<code><span class=\"literal string\">\"Not a number\"</span> : String</code>",
 "476": "<code>x : Nat</code>",
 "475":
 "<code class=\"docstring\">`/-- ... -/ #guard_msgs in cmd` captures the messages generated by the command `cmd`\nand checks that they match the contents of the docstring.\n\nBasic example:\n```lean\n/--\nerror: unknown identifier 'x'\n-/\n#guard_msgs in\nexample : α := x\n```\nThis checks that there is such an error and then consumes the message.\n\nBy default, the command captures all messages, but the filter condition can be adjusted.\nFor example, we can select only warnings:\n```lean\n/--\nwarning: declaration uses 'sorry'\n-/\n#guard_msgs(warning) in\nexample : α := sorry\n```\nor only errors\n```lean\n#guard_msgs(error) in\nexample : α := sorry\n```\nIn the previous example, since warnings are not captured there is a warning on `sorry`.\nWe can drop the warning completely with\n```lean\n#guard_msgs(error, drop warning) in\nexample : α := sorry\n```\n\nIn general, `#guard_msgs` accepts a comma-separated list of configuration clauses in parentheses:\n```\n#guard_msgs (configElt,*) in cmd\n```\nBy default, the configuration list is `(check all, whitespace := normalized, ordering := exact)`.\n\nMessage filters select messages by severity:\n- `info`, `warning`, `error`: (non-trace) messages with the given severity level.\n- `trace`: trace messages\n- `all`: all messages.\n\nThe filters can be prefixed with the action to take:\n- `check` (the default): capture and check the message\n- `drop`: drop the message\n- `pass`: let the message pass through\n\nIf no filter is specified, `check all` is assumed.  Otherwise, these filters are processed in\nleft-to-right order, with an implicit `pass all` at the end.\n\nWhitespace handling (after trimming leading and trailing whitespace):\n- `whitespace := exact` requires an exact whitespace match.\n- `whitespace := normalized` converts all newline characters to a space before matching\n  (the default). This allows breaking long lines.\n- `whitespace := lax` collapses whitespace to a single space before matching.\n\nMessage ordering:\n- `ordering := exact` uses the exact ordering of the messages (the default).\n- `ordering := sorted` sorts the messages in lexicographic order.\n  This helps with testing commands that are non-deterministic in their ordering.\n\nFor example, `#guard_msgs (error, drop all) in cmd` means to check warnings and drop\neverything else.\n\nThe command elaborator has special support for `#guard_msgs` for linting.\nThe `#guard_msgs` itself wants to capture linter warnings,\nso it elaborates the command it is attached to as if it were a top-level command.\nHowever, the command elaborator runs linters for *all* top-level commands,\nwhich would include `#guard_msgs` itself, and would cause duplicate and/or uncaptured linter warnings.\nThe top-level command elaborator only runs the linters if `#guard_msgs` is not present.\n</code>",
 "474": "<code>Sort ?u.598</code>",
 "473":
 "<code>Lean.Parser.Category.tactic : Lean.Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "472": "<code><span class=\"literal string\">\"triv\"</span> : String</code>",
 "471": "<code>1 = 0</code>",
 "470": "<code>∀ (b c : Nat), ys = [b, c] → False</code>",
 "47": "<code>β</code>",
 "469": "<code>b✝ + 1 = 0</code>",
 "468": "<code>∀ (a b : Nat), xs = [a, b] → False</code>",
 "467": "<code>a✝ + b✝ + 1 = 0</code>",
 "466":
 "<code>(match xs, ys with\n  | [a, b], x =&gt; a + b + 1\n  | x, [b, c] =&gt; b + 1\n  | x, x_1 =&gt; 1) =\n  0</code>",
 "465": "<code>g xs ys = 0</code>",
 "464": "<code>g (xs ys : List Nat) : Nat</code>",
 "463": "<code>w = 5 → False</code>",
 "462": "<code>z = 5</code>",
 "461": "<code>y = 5 → False</code>",
 "460": "<code>x = 5 → False</code>",
 "46": "<code>Sort ?u.40</code>",
 "459": "<code>5 ≠ 5</code>",
 "458": "<code>z ≠ 5</code>",
 "457": "<code>y ≠ 5</code>",
 "456": "<code>x ≠ 5</code>",
 "455": "<code>f (x y z : Nat) : Nat</code>",
 "454":
 "<code class=\"docstring\">The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n</code>",
 "453":
 "<code>GE.ge.{u} {α : Type u} [LE α] (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≥ b` is an abbreviation for `b ≤ a`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≥` in identifiers is `ge`.\n\n * The recommended spelling of `&gt;=` in identifiers is `ge` (prefer `≥` over `&gt;=`).</code>",
 "452":
 "<code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-than relation: `x &lt; y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;` in identifiers is `lt`.</code>",
 "451":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `true` (default: `false`), simplifies simple arithmetic expressions. </code>",
 "450": "<code>x = 0</code>",
 "45": "<code>F.{u} (α : Type u) : Type u</code>",
 "449":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">When `contextual` is true (default: `false`) and simplification encounters an implication `p → q`\nit includes `p` as an additional simp lemma when simplifying `q`.\n</code>",
 "448":
 "<code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.</code>",
 "447":
 "<code>ite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "446":
 "<code>List.reverse_append.{u_1} {α : Type u_1} {as bs : List α} : (as ++ bs).reverse = bs.reverse ++ as.reverse</code>",
 "445": "<code>p ((mk_symm ys).reverse ++ xs.reverse)</code>",
 "444": "<code>p (mk_symm ys ++ xs.reverse)</code>",
 "443": "<code>p (xs ++ mk_symm ys).reverse</code>",
 "442": "<code>List Nat → Prop</code>",
 "441":
 "<code>reverse_mk_symm.{u_1} {α : Type u_1} (xs : List α) : (mk_symm xs).reverse = mk_symm xs</code>",
 "440": "<code>mk_symm.{u_1} {α : Type u_1} (xs : List α) : List α</code>",
 "44":
 "<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id₁.{u} (α : Type u) (a : α) := a\n\n/- Implicit type-universe parameter, equivalent to `id₁`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id₂ (α : Type u) (a : α) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id₁` and `id₂`. -/\nuniverse u\ndef id₃ (α : Type u) (a : α) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L₁.{u} := List (Type u)\n\n-- def L₂ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L₃ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (α : Type u) (β : Type v) : Type (max u v) where\n  a : α\n  b : β\n\n#check Pair.{v, w}\n-- Pair : Type v → Type w → Type (max v w)\n```\n</code>",
 "439": "<code>y = y'</code>",
 "438": "<code>x = x'</code>",
 "437": "<code>y + 0 = y'</code>",
 "436": "<code>x + 0 = x'</code>",
 "435":
 "<code>Nat.add_left_comm (n m k : Nat) : n + (m + k) = m + (n + k)</code>",
 "434": "<code>w = u + x</code>",
 "433": "<code>x = y + z</code>",
 "432": "<code>0 = m</code>",
 "431": "<code>n = 1</code>",
 "430": "<code>f (m n : Nat) : Nat</code>",
 "43": "<code class=\"docstring\">The universe parameter u</code>",
 "429": "<code>p (x * z)</code>",
 "428": "<code>p (x + y)</code>",
 "427": "<code>p (x * z * 1)</code>",
 "426": "<code>p (1 * x + y)</code>",
 "425": "<code>p (x * y + w * (x * z))</code>",
 "424": "<code>p (x * y + z * w * x)</code>",
 "423":
 "<code>Nat.mul_left_comm (n m k : Nat) : n * (m * k) = m * (n * k)</code>",
 "422":
 "<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>",
 "421": "<code>p ((x + 0) * (0 + y * 1 + z * 0))</code>",
 "420":
 "<code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `++` in identifiers is `append`.</code>",
 "42": "<code>Type u</code>",
 "419":
 "<code>List.reverse.{u} {α : Type u} (as : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Reverses a list.\n\n`O(|as|)`.\n\nBecause of the “functional but in place” optimization implemented by Lean's compiler, this function\ndoes not allocate a new list when its reference to the input list is unshared: it simply walks the\nlinked list and reverses all the node pointers.\n\nExamples:\n* `[1, 2, 3, 4].reverse = [4, 3, 2, 1]`\n* `[].reverse = []`\n</code>",
 "418": "<code>p (x * y)</code>",
 "417": "<code>Tuple α 0</code>",
 "416": "<code>n = 0</code>",
 "415": "<code>Tuple (α : Type) (n : Nat) : Type</code>",
 "414": "<code>Tuple α n</code>",
 "413": "<code>a = 0</code>",
 "412":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "411": "<code>a + 0 = 0</code>",
 "410": "<code>f a = 0</code>",
 "41":
 "<code>Fin (n : Nat) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>",
 "409": "<code>p y</code>",
 "408": "<code>q → x = y</code>",
 "407": "<code>k = 0</code>",
 "406": "<code>f 0 = 0</code>",
 "405": "<code>add_comm (x y : Nat) : x + y = y + x</code>",
 "404":
 "<code class=\"docstring\">`any_goals tac` applies the tactic `tac` to every goal,\nconcatenating the resulting goals for successful tactic applications.\nIf the tactic fails on all of the goals, the entire `any_goals` tactic fails.\n\nThis tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.\n</code>",
 "403":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n</code>",
 "402":
 "<code class=\"docstring\">`try tac` runs `tac` and succeeds even if `tac` failed. </code>",
 "401":
 "<code class=\"docstring\">`first | tac | ...` runs each `tac` until one succeeds, or else fails. </code>",
 "400":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n</code>",
 "40":
 "<code>True.intro : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "4": "<code>p</code>",
 "399":
 "<code class=\"docstring\">The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n</code>",
 "398":
 "<code class=\"docstring\">`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n</code>",
 "397":
 "<code class=\"docstring\">`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 =&gt; rfl\n  | i+1 =&gt; simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n</code>",
 "396": "<code>p ∧ ¬p</code>",
 "395":
 "<code class=\"docstring\">`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n</code>",
 "394": "<code>∀ (n : Nat), P n.succ</code>",
 "393": "<code>P 0</code>",
 "392":
 "<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>",
 "391":
 "<code>Sum.inr.{u, v} {α : Type u} {β : Type v} (val : β) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Right injection into the sum type `α ⊕ β`. </code>",
 "390": "<code>α ⊕ β</code>",
 "39":
 "<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "389": "<code>Type ?u.115</code>",
 "388": "<code>Type ?u.116</code>",
 "387":
 "<code>Sum.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The disjoint union of types `α` and `β`, ordinarily written `α ⊕ β`.\n\nAn element of `α ⊕ β` is either an `a : α` wrapped in `Sum.inl` or a `b : β` wrapped in `Sum.inr`.\n`α ⊕ β` is not equivalent to the set-theoretic union of `α` and `β` because its values include an\nindication of which of the two types was chosen. The union of a singleton set with itself contains\none element, while `Unit ⊕ Unit` contains distinct values `inl ()` and `inr ()`.\n</code>",
 "386":
 "<code>swap_sum.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α ⊕ β → β ⊕ α</code>",
 "385": "<code>α × β</code>",
 "384": "<code>Type ?u.17</code>",
 "383": "<code>Type ?u.18</code>",
 "382": "<code>Type u_2</code>",
 "381": "<code>Type u_1</code>",
 "380":
 "<code>swap_pair.{u_1, u_2} {α : Type u_1} {β : Type u_2} : α × β → β × α</code>",
 "38":
 "<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>",
 "379": "<code>q x</code>",
 "378": "<code>p x ∧ q x</code>",
 "377":
 "<code class=\"docstring\">`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n</code>",
 "376": "<code>Nat → Prop</code>",
 "375": "<code>q ∨ r</code>",
 "374":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "373": "<code>p ∨ p</code>",
 "372":
 "<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>",
 "371":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>",
 "370": "<code>3 = x</code>",
 "37": "<code class=\"docstring\">The universe parameter n</code>",
 "369":
 "<code class=\"docstring\">* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n</code>",
 "368": "<code>x✝ = y✝</code>",
 "367": "<code>x✝ = y</code>",
 "366":
 "<code class=\"docstring\">`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n</code>",
 "365":
 "<code class=\"docstring\">`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n</code>",
 "364":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "363": "<code>a✝¹ = d✝</code>",
 "362": "<code>a✝³ = c✝</code>",
 "361": "<code>a✝³ = d✝</code>",
 "360": "<code>a✝³ = b✝</code>",
 "36": "<code class=\"docstring\">The universe level 0</code>",
 "359": "<code>a✝¹ = c✝</code>",
 "358": "<code>a✝¹ = b✝</code>",
 "357":
 "<code class=\"docstring\">`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. </code>",
 "356":
 "<code class=\"docstring\">`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n</code>",
 "355": "<code>a✝² = c✝</code>",
 "354": "<code>a✝² = b✝</code>",
 "353": "<code>z = w</code>",
 "352":
 "<code class=\"docstring\">Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k =&gt; g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n</code>",
 "351": "<code>∃ x, p x ∨ q x</code>",
 "350":
 "<code class=\"docstring\">The tactic\n```\nintro\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 =&gt; tac1\n| pat2 =&gt; tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n</code>",
 "35": "<code class=\"docstring\">The universe level 4</code>",
 "349": "<code>Sort u_1</code>",
 "348": "<code>a = c</code>",
 "347":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "346":
 "<code class=\"docstring\">* `case tag =&gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ =&gt; tac` is equivalent to `(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)`.\n</code>",
 "345":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "344":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "343":
 "<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>",
 "342": "<code>test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p</code>",
 "341": "<code>Fermat's_last_theorem : Prop</code>",
 "340": "<code>Goldbach's_weak_conjecture : Prop</code>",
 "34": "<code class=\"docstring\">The universe level 3</code>",
 "339": "<code>goldbach_conjecture : Prop</code>",
 "338": "<code>infinitely_many_Fermat_primes : Prop</code>",
 "337": "<code>infinitely_many_primes : Prop</code>",
 "336": "<code>even (n : Nat) : Prop</code>",
 "335": "<code>Fermat_prime (n : Nat) : Prop</code>",
 "334": "<code>prime (n : Nat) : Prop</code>",
 "333": "<code>∀ (x : men), shaves barber x ↔ ¬shaves x x</code>",
 "332": "<code>men → men → Prop</code>",
 "331": "<code>men</code>",
 "330":
 "<code>Nat.le_antisymm {n m : Nat} (h₁ : n ≤ m) (h₂ : m ≤ n) : n = m</code>",
 "33": "<code class=\"docstring\">The universe level 2</code>",
 "329": "<code><span class=\"literal string\">\"›\"</span> : String</code>",
 "328": "<code>Lean.TSyntax `term</code>",
 "327": "<code><span class=\"literal string\">\"‹\"</span> : String</code>",
 "326":
 "<code class=\"docstring\">`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n</code>",
 "325":
 "<code>LE.le.{u} {α : Type u} [self : LE α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "324": "<code>f 0 ≤ f 2</code>",
 "323": "<code>f 0 ≤ f 1</code>",
 "322": "<code>Nat.le_trans {n m k : Nat} : n ≤ m → m ≤ k → n ≤ k</code>",
 "321": "<code>∀ (x : Nat), f x ≤ f (x + 1)</code>",
 "320": "<code>∃ x, p x → r</code>",
 "32": "<code class=\"docstring\">The universe level 1</code>",
 "319": "<code>¬p x</code>",
 "318": "<code>¬∃ x, p x → r</code>",
 "317": "<code>¬∀ (x : α), p x</code>",
 "316": "<code>(∀ (x : α), p x) → r</code>",
 "315": "<code>∀ (x : α), p x</code>",
 "314": "<code>p b → r</code>",
 "313": "<code>(∃ x, p x) ∨ ∃ x, q x</code>",
 "312": "<code>q a</code>",
 "311": "<code>p a ∨ q a</code>",
 "310": "<code>∃ x, p x</code>",
 "31": "<code>G : Type → Type → Type</code>",
 "309": "<code>∀ (x : α), ¬p x</code>",
 "308": "<code>¬∃ x, p x</code>",
 "307": "<code>¬∀ (x : α), ¬p x</code>",
 "306": "<code>Sort ?u.7</code>",
 "305": "<code>b = 2 * w2</code>",
 "304": "<code>a = 2 * w1</code>",
 "303": "<code>IsEven b</code>",
 "302": "<code>IsEven a</code>",
 "301":
 "<code>even_plus_even {a b : Nat} (h1 : IsEven a) (h2 : IsEven b) : IsEven (a + b)</code>",
 "300": "<code>IsEven (a : Nat) : Prop</code>",
 "30":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "3": "<code>p ∧ q</code>",
 "299": "<code>q w</code>",
 "298": "<code>p w</code>",
 "297":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "296": "<code>p w ∧ q w</code>",
 "295": "<code>∃ x, p x ∧ q x</code>",
 "294":
 "<code>Exists.elim.{u} {α : Sort u} {p : α → Prop} {b : Prop} (h₁ : ∃ x, p x) (h₂ : ∀ (a : α), p a → b) : b</code>",
 "293":
 "<code>gex3 (g : Nat → Nat → Nat)\n  (hg :\n    @Eq Nat\n      (g (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))\n        (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0))))\n      (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))) :\n  @Exists Nat fun x =&gt;\n    @Eq Nat\n      (g (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))\n        (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0))))\n      x</code>",
 "292":
 "<code>gex2 (g : Nat → Nat → Nat)\n  (hg :\n    @Eq Nat\n      (g (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))\n        (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0))))\n      (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))) :\n  @Exists Nat fun x =&gt; @Eq Nat (g x (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))) x</code>",
 "291":
 "<code>gex1 (g : Nat → Nat → Nat)\n  (hg :\n    @Eq Nat\n      (g (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))\n        (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0))))\n      (@OfNat.ofNat Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))) :\n  @Exists Nat fun x =&gt; @Eq Nat (g x x) x</code>",
 "290":
 "<code>pp.explicit</code><span class=\"sep\"></span><code class=\"docstring\">(pretty printer) display implicit arguments</code>",
 "29": "<code>F : Type → Type</code>",
 "289":
 "<code>gex4 (g : Nat → Nat → Nat) (hg : g 0 0 = 0) : ∃ x, g x x = 0</code>",
 "288":
 "<code>gex3 (g : Nat → Nat → Nat) (hg : g 0 0 = 0) : ∃ x, g 0 0 = x</code>",
 "287":
 "<code>gex2 (g : Nat → Nat → Nat) (hg : g 0 0 = 0) : ∃ x, g x 0 = x</code>",
 "286":
 "<code>gex1 (g : Nat → Nat → Nat) (hg : g 0 0 = 0) : ∃ x, g x x = x</code>",
 "285": "<code>Nat → Nat → Nat</code>",
 "284": "<code>g 0 0 = 0</code>",
 "283": "<code>Sort ?u.163</code>",
 "282": "<code>p t</code>",
 "281": "<code>y &lt; z</code>",
 "280": "<code>x &lt; y</code>",
 "28": "<code>β : Type</code>",
 "279": "<code>x &gt; 0</code>",
 "278": "<code>Nat.zero_lt_succ (n : Nat) : 0 &lt; n.succ</code>",
 "277": "<code>1 &gt; 0</code>",
 "276":
 "<code>Exists.{u} {α : Sort u} (p : α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Existential quantification. If `p : α → Prop` is a predicate, then `∃ x : α, p x`\nasserts that there is some `x` of type `α` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `⟨x, h⟩`.\nTo unpack an existential, use `cases h` where `h` is a proof of `∃ x : α, p x`,\nor `let ⟨x, hx⟩ := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n</code>",
 "275": "<code>divides_mul (x k : Nat) : x | k * x</code>",
 "274": "<code>x | y</code>",
 "273": "<code><span class=\"literal string\">\" | \"</span> : String</code>",
 "272": "<code>y = z</code>",
 "271":
 "<code>∀ {a b c : Nat}, divides a b → divides b c → divides a c</code><span class=\"sep\"></span><code class=\"docstring\">Compose two proofs by transitivity, generalized over the relations involved. </code>",
 "270": "<code>divides_mul (x k : Nat) : divides x (k * x)</code>",
 "27": "<code>α : Type</code>",
 "269":
 "<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "268":
 "<code>Exists.intro.{u} {α : Sort u} {p : α → Prop} (w : α) (h : p w) : Exists p</code><span class=\"sep\"></span><code class=\"docstring\">Existential introduction. If `a : α` and `h : p a`,\nthen `⟨a, h⟩` is a proof that `∃ x : α, p x`. </code>",
 "267": "<code>k₂ * y = z</code>",
 "266": "<code>k₁ * x = y</code>",
 "265": "<code>divides y z</code>",
 "264": "<code>divides x y</code>",
 "263":
 "<code>divides_trans {x y z : Nat} (h₁ : divides x y) (h₂ : divides y z) : divides x z</code>",
 "262": "<code>divides (x y : Nat) : Prop</code>",
 "261":
 "<code>Trans.{u, v, w, u_1, u_2, u_3} {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (r : α → β → Sort u) (s : β → γ → Sort v)\n  (t : outParam (α → γ → Sort w)) : Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</code><span class=\"sep\"></span><code class=\"docstring\">Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b &lt; c`\nit knows that this should be a proof of `a &lt; c` because there is an instance\n`Trans (·≤·) (·&lt;·) (·&lt;·)`.\n</code>",
 "260": "<code>Nat.succ_le_succ {n m : Nat} : n ≤ m → n.succ ≤ m.succ</code>",
 "26":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "259": "<code>Nat.lt_succ_self (n : Nat) : n &lt; n.succ</code>",
 "258": "<code>c + 1 &lt; d</code>",
 "257": "<code>b ≤ c</code>",
 "256":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "255":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "254":
 "<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "253":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "252":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "251":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "250": "<code>e = 1 + d</code>",
 "25": "<code>Nat × Nat</code>",
 "249": "<code>b = c + 1</code>",
 "248":
 "<code>T (a b c d e : Nat) (h1 : a = b) (h2 : b = c + 1) (h3 : c = d) (h4 : e = 1 + d) : a = e</code>",
 "247": "<code>p x</code>",
 "246": "<code>x = y</code>",
 "245": "<code>(x + y) * (x + y) = x * x + y * x + (x * y + y * y)</code>",
 "244": "<code>(x + y) * (x + y) = (x + y) * x + (x + y) * y</code>",
 "243":
 "<code>Nat.right_distrib (n m k : Nat) : (n + m) * k = n * k + m * k</code>",
 "242": "<code>Nat.add_mul (n m k : Nat) : (n + m) * k = n * k + m * k</code>",
 "241":
 "<code>Nat.left_distrib (n m k : Nat) : n * (m + k) = n * m + n * k</code>",
 "240": "<code>Nat.mul_add (n m k : Nat) : n * (m + k) = n * m + n * k</code>",
 "24": "<code>α</code>",
 "239": "<code>Nat.mul_assoc (n m k : Nat) : n * m * k = n * (m * k)</code>",
 "238": "<code>Nat.mul_comm (n m : Nat) : n * m = m * n</code>",
 "237": "<code>Nat.add_assoc (n m k : Nat) : n + m + k = n + (m + k)</code>",
 "236": "<code>Nat.add_comm (n m : Nat) : n + m = m + n</code>",
 "235": "<code>Nat.one_mul (n : Nat) : 1 * n = n</code>",
 "234": "<code>Nat.mul_one (n : Nat) : n * 1 = n</code>",
 "233": "<code>Nat.zero_add (n : Nat) : 0 + n = n</code>",
 "232": "<code>Nat.add_zero (n : Nat) : n + 0 = n</code>",
 "231": "<code>f = g</code>",
 "230": "<code>α → Nat</code>",
 "23": "<code>α → β</code>",
 "229":
 "<code>congr.{u, v} {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α} (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in both function and argument. If `f₁ = f₂` and `a₁ = a₂` then\n`f₁ a₁ = f₂ a₂`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "228":
 "<code>congrFun.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : f = g) (a : α) : f a = g a</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function part of an application: If `f = g` then `f a = g a`. </code>",
 "227":
 "<code>congrArg.{u, v} {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`&lt;something containing a₁&gt; = &lt;something containing a₂&gt;`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "226":
 "<code>Eq.subst.{u} {α : Sort u} {motive : α → Prop} {a b : α} (h₁ : a = b) (h₂ : motive a) : motive b</code><span class=\"sep\"></span><code class=\"docstring\">The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x =&gt; x &lt; 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "225": "<code>p a</code>",
 "224":
 "<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "223": "<code>c = d</code>",
 "222": "<code>c = b</code>",
 "221": "<code>a = b</code>",
 "220":
 "<code>Eq.trans.{u} {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c</code><span class=\"sep\"></span><code class=\"docstring\">Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "22":
 "<code>Nat.add : Nat → Nat → Nat</code><span class=\"sep\"></span><code class=\"docstring\">Addition of natural numbers, typically used via the `+` operator.\n\nThis function is overridden in both the kernel and the compiler to efficiently evaluate using the\narbitrary-precision arithmetic library. The definition provided here is the logical model.\n</code>",
 "219":
 "<code>Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a</code><span class=\"sep\"></span><code class=\"docstring\">Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "218":
 "<code>Eq.refl.{u_1} {α : Sort u_1} (a : α) : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. </code>",
 "217": "<code class=\"docstring\">The maximum of two universes.</code>",
 "216":
 "<code class=\"docstring\">The impredicative maximum of two universes:\n\n * `imax u 0 = 0`\n * `imax u (v+1) = max u (v+1)`</code>",
 "215": "<code class=\"docstring\">The universe parameter j</code>",
 "214": "<code>{x : α} → Sort j</code>",
 "213": "<code class=\"docstring\">The universe parameter i</code>",
 "212": "<code>Sort i</code>",
 "211": "<code>r c d</code>",
 "210": "<code>r c b</code>",
 "21":
 "<code>Nat.succ (n : Nat) : Nat</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "209": "<code>∀ {x y : α}, r x y → r y x</code>",
 "208": "<code>∀ (x : α), r x x</code>",
 "207": "<code>∀ {x y z : α}, r x y → r y z → r x z</code>",
 "206": "<code>r b c</code>",
 "205": "<code>r a b</code>",
 "204": "<code>∀ (x y z : α), r x y → r y z → r x z</code>",
 "203": "<code>∀ (x : α), p x ∧ q x</code>",
 "202": "<code>{x : α} → Prop</code>",
 "201": "<code>(x : α) → β x</code>",
 "200": "<code>{x : α} → β x</code>",
 "20":
 "<code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">The product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.</code>",
 "2":
 "<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "199": "<code>α → α → Prop</code>",
 "198": "<code>α → Prop</code>",
 "197": "<code>¬(p ∧ ¬q)</code>",
 "196": "<code>p ∧ r</code>",
 "195": "<code>p ∧ q ∨ p ∧ r</code>",
 "194": "<code>r</code>",
 "193": "<code>p ∧ (q ∨ r)</code>",
 "192":
 "<code class=\"docstring\">The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n</code>",
 "191": "<code>¬(p ∧ q)</code>",
 "190":
 "<code>Classical.byContradiction {p : Prop} (h : ¬p → False) : p</code>",
 "19": "<code>Type</code>",
 "189":
 "<code>Classical.byCases {p q : Prop} (hpq : p → q) (hnpq : ¬p → q) : q</code>",
 "188": "<code>¬¬p</code>",
 "187": "<code>dne {p : Prop} (h : ¬¬p) : p</code>",
 "186":
 "<code>Classical.em (p : Prop) : p ∨ ¬p</code><span class=\"sep\"></span><code class=\"docstring\">**Diaconescu's theorem**: excluded middle from choice, Function extensionality and propositional extensionality. </code>",
 "185": "<code>q ∧ p</code>",
 "184": "<code>and_swap (p q : Prop) : p ∧ q ↔ q ∧ p</code>",
 "183":
 "<code>Iff.mpr {a b : Prop} (self : a ↔ b) : b → a</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. </code>",
 "182": "<code>p ↔ q</code>",
 "181":
 "<code>Iff.mp {a b : Prop} (self : a ↔ b) : a → b</code><span class=\"sep\"></span><code class=\"docstring\">Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. </code>",
 "180":
 "<code>Iff.intro {a b : Prop} (mp : a → b) (mpr : b → a) : a ↔ b</code><span class=\"sep\"></span><code class=\"docstring\">If `a → b` and `b → a` then `a` and `b` are equivalent. </code>",
 "18":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "179": "<code>q → p</code>",
 "178":
 "<code>absurd.{v} {a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b</code><span class=\"sep\"></span><code class=\"docstring\">Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "177": "<code>¬q</code>",
 "176": "<code>¬p</code>",
 "175":
 "<code>Or.inl {a b : Prop} (h : a) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ∨ b`. </code>",
 "174":
 "<code>Or.inr {a b : Prop} (h : b) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ∨ b`. </code>",
 "173": "<code>p → r</code>",
 "172": "<code>p ∨ q</code>",
 "171":
 "<code>Or.elim {a b c : Prop} (h : a ∨ b) (left : a → c) (right : b → c) : c</code><span class=\"sep\"></span><code class=\"docstring\">Proof by cases on an `Or`. If `a ∨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n</code>",
 "170":
 "<code>Or.intro_right {b : Prop} (a : Prop) (h : b) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">Alias for `Or.inr`. </code>",
 "17":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "169":
 "<code>Or.intro_left {a : Prop} (b : Prop) (h : a) : a ∨ b</code><span class=\"sep\"></span><code class=\"docstring\">Alias for `Or.inl`. </code>",
 "168": "<code>List Nat</code>",
 "167": "<code>Foo.bar (x : Foo) : Bar</code>",
 "166": "<code>Foo : Type</code>",
 "165": "<code>Foo</code>",
 "164":
 "<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n</code>",
 "163":
 "<code>Iff (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.\n\n * The recommended spelling of `&lt;-&gt;` in identifiers is `iff` (prefer `↔` over `&lt;-&gt;`).</code>",
 "162": "<code>p → q</code>",
 "161": "<code>q → r</code>",
 "160": "<code>t2 (p q r : Prop) (h₁ : q → r) (h₂ : p → q) : p → r</code>",
 "16": "<code>b2 : Bool</code>",
 "159": "<code>r → s</code>",
 "158": "<code>t1 (p q : Prop) (hp : p) (hq : q) : p</code>",
 "157": "<code>p → q → p</code>",
 "156":
 "<code>False.elim.{u} {C : Sort u} (h : False) : C</code><span class=\"sep\"></span><code class=\"docstring\">`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n</code>",
 "155": "<code>ex : 1 = 0</code>",
 "154": "<code>unsound : False</code>",
 "153":
 "<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "152": "<code>t2 {p q : Prop} : q → p</code>",
 "151": "<code>hp {p : Prop} : p</code>",
 "150": "<code>t1 {p q : Prop} (hp : p) (hq : q) : p</code>",
 "15":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "149": "<code>Type v</code>",
 "148": "<code>t1 {p q : Prop} : p → q → p</code>",
 "147":
 "<code>linter.unusedVariables</code><span class=\"sep\"></span><code class=\"docstring\">enable the 'unused variables' linter</code>",
 "146":
 "<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>",
 "145":
 "<code>implies_intro (p q : Prop) : (Proof p → Proof q) → Proof (Implies p q)</code>",
 "1445": "<code>f ⋯ = f a</code>",
 "1444": "<code>∃ a₁, f a₁ = f a</code>",
 "1443": "<code>∀ {a b : α}, f a = f b → a = b</code>",
 "1442":
 "<code>linv_comp_self.{u_1} {α : Prop} {β : Sort u_1} {f : α → β} [Inhabited α] (inj : ∀ {a b : α}, f a = f b → a = b) : ⋯ = ⋯</code>",
 "1441": "<code>∃ a, f a = b</code>",
 "1440":
 "<code>linv.{u_1} {α : Prop} {β : Sort u_1} [Inhabited α] (f : α → β) : ∀ (a : β), α</code>",
 "144":
 "<code>modus_ponens (p q : Prop) : Proof (Implies p q) → Proof p → Proof q</code>",
 "1439": "<code>Sort ?u.234</code>",
 "1438": "<code>Sort ?u.202</code>",
 "1437": "<code>Sort ?u.201</code>",
 "1436": "<code>False</code>",
 "1435": "<code>propComplete (a : Prop) : a = True ∨ a = False</code>",
 "1434": "<code>mt {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a</code>",
 "1433": "<code>u ≠ v</code>",
 "1432":
 "<code>∀ (exU : ∃ x, U x) (exV : ∃ x, V x), choose exU = choose exV</code>",
 "1431": "<code>x = False ∨ p → x = True ∨ p</code>",
 "1430": "<code>x = True ∨ p → x = False ∨ p</code>",
 "143":
 "<code>and_commut (p q : Prop) : Proof (Implies (p ∧ q) (q ∧ p))</code>",
 "1429": "<code>U = V</code>",
 "1428": "<code>p → u = v</code>",
 "1427": "<code>true_ne_false : ¬True = False</code>",
 "1426": "<code>v = False</code>",
 "1425": "<code>u = True</code>",
 "1424": "<code>u ≠ v ∨ p</code>",
 "1423": "<code>V v</code>",
 "1422": "<code>U u</code>",
 "1421": "<code>∃ x, V x</code>",
 "1420": "<code>∃ x, U x</code>",
 "142": "<code>Proof.proof {p : Prop} (self : Proof p) : p</code>",
 "1419": "<code>em (p : Prop) : p ∨ ¬p</code>",
 "1418":
 "<code>nonempty_of_exists.{u} {α : Sort u} {p : α → Prop} : (∃ x, p x) → Nonempty α</code>",
 "1417": "<code>∃ y, p y</code>",
 "1416":
 "<code>Classical.epsilon_spec.{u} {α : Sort u} {p : α → Prop} (hex : ∃ y, p y) : p (epsilon p)</code>",
 "1415":
 "<code>Classical.epsilon.{u} {α : Sort u} [h : Nonempty α] (p : α → Prop) : α</code><span class=\"sep\"></span><code class=\"docstring\">the Hilbert epsilon Function </code>",
 "1414":
 "<code>Classical.strongIndefiniteDescription.{u} {α : Sort u} (p : α → Prop) (h : Nonempty α) : { x // (∃ y, p y) → p x }</code>",
 "1413":
 "<code>inhabited_of_nonempty.{u_1} {α : Sort u_1} (h : Nonempty α) : Inhabited α</code>",
 "1412":
 "<code>choose_spec.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : p (choose h)</code>",
 "1411":
 "<code>Subtype.val.{u} {α : Sort u} {p : α → Prop} (self : Subtype p) : α</code><span class=\"sep\"></span><code class=\"docstring\">The value in the underlying type that satisfies the predicate.\n</code>",
 "1410":
 "<code>choose.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α</code>",
 "141": "<code>Proof (p : Prop) : Type</code>",
 "1409":
 "<code>Classical.choose_spec.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : p (choose h)</code>",
 "1408":
 "<code>Classical.choose.{u} {α : Sort u} {p : α → Prop} (h : ∃ x, p x) : α</code><span class=\"sep\"></span><code class=\"docstring\">Given that there exists an element satisfying `p`, returns one such element.\n\nThis is a straightforward consequence of, and equivalent to, `Classical.choice`.\n\nSee also `choose_spec`, which asserts that the returned value has property `p`.\n</code>",
 "1407":
 "<code>Classical.indefiniteDescription.{u} {α : Sort u} (p : α → Prop) (h : ∃ x, p x) : { x // p x }</code>",
 "1406":
 "<code>indefiniteDescription.{u} {α : Sort u} (p : α → Prop) (h : ∃ x, p x) : { x // p x }</code>",
 "1405": "<code>Nonempty α</code>",
 "1404": "<code>choice.{u} {α : Sort u} : Nonempty α → α</code>",
 "1403":
 "<code>Nonempty.intro.{u} {α : Sort u} (val : α) : Nonempty α</code><span class=\"sep\"></span><code class=\"docstring\">If `val : α`, then `α` is nonempty. </code>",
 "1402":
 "<code>trivial : True</code><span class=\"sep\"></span><code class=\"docstring\">`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. </code>",
 "1401":
 "<code>Nonempty.{u} (α : Sort u) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n</code>",
 "1400": "<code>Nonempty.intro.{u} {α : Sort u} (val : α) : Nonempty α</code>",
 "140":
 "<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.</code>",
 "14":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\nimportant for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "1399": "<code>Nonempty.{u} (α : Sort u) : Prop</code>",
 "1398":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "1397": "<code>∀ (x : α), f₁ x = f₂ x</code>",
 "1396": "<code>∀ (x : α), a✝¹ x = b✝ x</code>",
 "1395": "<code>α → Sort ?u.74</code>",
 "1394": "<code>Sort ?u.75</code>",
 "1393": "<code>α✝ → Sort v</code>",
 "1392": "<code>extfun α β</code>",
 "1391": "<code>α → Sort u_2</code>",
 "1390":
 "<code>extfun_app.{u_1, u_2} {α : Sort u_1} {β : α → Sort u_2} (f : extfun α β) (x : α) : β x</code>",
 "139":
 "<code>Or (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.\n\n * The recommended spelling of `\\/` in identifiers is `or` (prefer `∨` over `\\/`).</code>",
 "1389":
 "<code>extfun_app.{u_1, u_2} {α : Sort u_1} {β : α → Sort u_2} : extfun α β → (x : α) → β x</code>",
 "1388":
 "<code>extfun.{u, v} (α : Sort u) (β : α → Sort v) : Sort (imax u v)</code>",
 "1387":
 "<code>Quotient.lift₂.{uA, uB, uC} {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₁ : Quotient s₁)\n  (q₂ : Quotient s₂) : φ</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a binary function from the underlying types to a binary function on quotients. The function\nmust respect both quotients' equivalence relations.\n\n`Quotient.lift` is a version of this operation for unary functions. `Quotient.liftOn₂` is a version\nthat take the quotient parameters first.\n</code>",
 "1386": "<code>c ∈ { a, b }</code>",
 "1385":
 "<code>UProd.mem_or_mem_of_mem_mk {α : Type} {a b c : α} : c ∈ { a, b } → c = a ∨ c = b</code>",
 "1384": "<code>UProd.mem_mk_right {α : Type} (a b : α) : b ∈ { a, b }</code>",
 "1383": "<code>UProd.mem_mk_left {α : Type} (a b : α) : a ∈ { a, b }</code>",
 "1382": "<code><span class=\"literal string\">\" ∈ \"</span> : String</code>",
 "1381": "<code>Setoid.r p₁ p₂</code>",
 "1380":
 "<code>Quot.liftOn.{u, v} {α : Sort u} {β : Sort v} {r : α → α → Prop} (q : Quot r) (f : α → β)\n  (c : ∀ (a b : α), r a b → f a = f b) : β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient's value `q : Quot r`, applying a `f : α → β`\nrequires a proof `c` that `f` respects `r`. In this case, `Quot.liftOn q f h : β` evaluates\nto the result of applying `f` to the underlying value in `α` from `q`.\n\n`Quot.liftOn` is a version of the built-in primitive `Quot.lift` with its parameters re-ordered.\n\n[Quotient types](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "138":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>",
 "1379":
 "<code>UProd.mem.{u_1} {α : Type u_1} (a : α) (u : UProd α) : Prop</code>",
 "1378": "<code>a₂ = b₁</code>",
 "1377": "<code>a₁ = b₂</code>",
 "1376": "<code>a = (a₁, a₂).fst</code>",
 "1375": "<code>UProd.mem_fn a ((a₁, a₂).snd, (a₁, a₂).fst)</code>",
 "1374": "<code>a = (a₁, a₂).snd</code>",
 "1373": "<code>a = a₂</code>",
 "1372": "<code>UProd.mem_fn a (a₁, a₂)</code>",
 "1371": "<code>a = a₁</code>",
 "1370":
 "<code>UProd.mem_swap.{u_1} {α : Type u_1} {a : α} {p : α × α} : UProd.mem_fn a p = UProd.mem_fn a (p.snd, p.fst)</code>",
 "137": "<code>Implies (p q : Prop) : Prop</code>",
 "1369":
 "<code>UProd.mem_respects.{u_1} {α : Type u_1} {p₁ p₂ : α × α} (a : α) : p₁ ~ p₂ → UProd.mem_fn a p₁ = UProd.mem_fn a p₂</code>",
 "1368":
 "<code>UProd.mem_fn.{u_1} {α : Type u_1} (a : α) : α × α → Prop</code>",
 "1367": "<code>UProd α</code>",
 "1366":
 "<code>UProd.mk_eq_mk {α : Type} (a₁ a₂ : α) : { a₁, a₂ } = { a₂, a₁ }</code>",
 "1365": "<code><span class=\"literal string\">\", \"</span> : String</code>",
 "1364":
 "<code>Quotient.mk'.{u} {α : Sort u} [s : Setoid α] (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe equivalence relation is found by synthesizing a `Setoid` instance. `Quotient.mk` instead expects\nthe instance to be provided explicitly.\n\nGiven `v : α`, `Quotient.mk' v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n\n</code>",
 "1363": "<code>UProd.mk {α : Type} (a₁ a₂ : α) : UProd α</code>",
 "1362":
 "<code>Quotient.{u} {α : Sort u} (s : Setoid α) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Quotient types coarsen the propositional equality for a type so that terms related by some\nequivalence relation are considered equal. The equivalence relation is given by an instance of\n`Setoid`.\n\nSet-theoretically, `Quotient s` can seen as the set of equivalence classes of `α` modulo the\n`Setoid` instance's relation `s.r`. Functions from `Quotient s` must prove that they respect `s.r`:\nto define a function `f : Quotient s → β`, it is necessary to provide `f' : α → β` and prove that\nfor all `x : α` and `y : α`, `s.r x y → f' x = f' y`. `Quotient.lift` implements this operation.\n\nThe key quotient operators are:\n * `Quotient.mk` places elements of the underlying type `α` into the quotient.\n * `Quotient.lift` allows the definition of functions from the quotient to some other type.\n * `Quotient.sound` asserts the equality of elements related by `r`\n * `Quotient.ind` is used to write proofs about quotients by assuming that all elements are\n   constructed with `Quotient.mk`.\n\n`Quotient` is built on top of the primitive quotient type `Quot`, which does not require a proof\nthat the relation is an equivalence relation. `Quotient` should be used instead of `Quot` for\nrelations that actually are equivalence relations.\n</code>",
 "1361":
 "<code>Equivalence eqv</code><span class=\"sep\"></span><code class=\"docstring\">The relation `x ≈ y` is an equivalence relation. </code>",
 "1360":
 "<code>α × α → α × α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "136": "<code>{α : Type} → α → β</code>",
 "1359": "<code>uprodSetoid.{u} (α : Type u) : Setoid (α × α)</code>",
 "1358": "<code>UProd.{u} (α : Type u) : Type u</code>",
 "1357":
 "<code>∀ {x y z : α × α}, x ~ y → y ~ z → x ~ z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "1356":
 "<code>∀ {x y : α × α}, x ~ y → y ~ x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "1355":
 "<code>∀ (p : α × α), p ~ p</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "1354": "<code>is_equivalence.{u_1} {α : Type u_1} : Equivalence eqv</code>",
 "1353": "<code>(b₁, b₂).snd = (c₁, c₂).fst</code>",
 "1352": "<code>(b₁, b₂).fst = (c₁, c₂).snd</code>",
 "1351": "<code>(b₁, b₂).snd = (c₁, c₂).snd</code>",
 "1350": "<code>(b₁, b₂).fst = (c₁, c₂).fst</code>",
 "135":
 "<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>",
 "1349":
 "<code>eqv.trans.{u_1} {α : Type u_1} {p₁ p₂ p₃ : α × α} : p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃</code>",
 "1348": "<code>(a₁, a₂).snd = (b₁, b₂).fst</code>",
 "1347": "<code>(a₁, a₂).fst = (b₁, b₂).snd</code>",
 "1346": "<code>(a₁, a₂).snd = (b₁, b₂).snd</code>",
 "1345": "<code>(a₁, a₂).fst = (b₁, b₂).fst</code>",
 "1344":
 "<code>eqv.symm.{u_1} {α : Type u_1} {p₁ p₂ : α × α} : p₁ ~ p₂ → p₂ ~ p₁</code>",
 "1343": "<code>eqv.refl.{u_1} {α : Type u_1} (p : α × α) : p ~ p</code>",
 "1342": "<code>α × α</code>",
 "1341": "<code>eqv.{u_1} {α : Type u_1} (p₁ p₂ : α × α) : Prop</code>",
 "1340":
 "<code>Quotient.exact.{u} {α : Sort u} {s : Setoid α} {a b : α} : Quotient.mk s a = Quotient.mk s b → a ≈ b</code><span class=\"sep\"></span><code class=\"docstring\">If two values are equal in a quotient, then they are related by its equivalence relation.\n</code>",
 "134": "<code>Int</code>",
 "1339":
 "<code>Setoid.trans.{u} {α : Sort u} [Setoid α] {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c</code><span class=\"sep\"></span><code class=\"docstring\">A setoid's equivalence relation is transitive. </code>",
 "1338":
 "<code>Setoid.symm.{u} {α : Sort u} [Setoid α] {a b : α} (hab : a ≈ b) : b ≈ a</code><span class=\"sep\"></span><code class=\"docstring\">A setoid's equivalence relation is symmetric. </code>",
 "1337":
 "<code>Setoid.refl.{u} {α : Sort u} [Setoid α] (a : α) : a ≈ a</code><span class=\"sep\"></span><code class=\"docstring\">A setoid's equivalence relation is reflexive. </code>",
 "1336":
 "<code>Setoid.r.{u} {α : Sort u} [self : Setoid α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">`x ≈ y` is the distinguished equivalence relation of a setoid. </code>",
 "1335":
 "<code>Quotient.sound.{u} {α : Sort u} {s : Setoid α} {a b : α} : a ≈ b → Quotient.mk s a = Quotient.mk s b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related in the setoid.\n\nBecause `Quotient` is built on a lower-level type `Quot`, `Quotient.sound` is implemented as a\ntheorem. It is derived from `Quot.sound`, the soundness axiom for the lower-level quotient type\n`Quot`.\n</code>",
 "1334":
 "<code>Quotient.lift.{u, v} {α : Sort u} {β : Sort v} {s : Setoid α} (f : α → β) :\n  (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's equivalence relation.\n\nGiven `s : Setoid α` and a quotient `Quotient s`, applying a function `f : α → β` requires a proof\n`h` that `f` respects the equivalence relation `s.r`. In this case, the function\n`Quotient.lift f h : Quotient s → β` computes the same values as `f`.\n\n`Quotient.liftOn` is a version of this operation that takes the quotient value as its first explicit\nparameter.\n</code>",
 "1333":
 "<code>Quotient.ind.{u} {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} :\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quotient s), motive q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quotient.mk`.\n</code>",
 "1332":
 "<code>Quotient.mk.{u} {α : Sort u} (s : Setoid α) (a : α) : Quotient s</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to an equivalence\nrelation.\n\nThe setoid instance is provided explicitly. `Quotient.mk'` uses instance synthesis instead.\n\nGiven `v : α`, `Quotient.mk s v : Quotient s` is like `v`, except all observations of `v`'s value\nmust respect `s.r`. `Quotient.lift` allows values in a quotient to be mapped to other types, so long\nas the mapping respects `s.r`.\n</code>",
 "1331":
 "<code>Setoid.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A setoid is a type with a distinguished equivalence relation, denoted `≈`.\n\nThe `Quotient` type constructor requires a `Setoid` instance.\n</code>",
 "1330": "<code>Setoid α</code>",
 "133": "<code>T</code>",
 "1329": "<code>Quotient.{u} {α : Sort u} (s : Setoid α) : Sort u</code>",
 "1328":
 "<code>Equivalence.trans.{u} {α : Sort u} {r : α → α → Prop} (self : Equivalence r) {x y z : α} : r x y → r y z → r x z</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is transitive: `r x y` and `r y z` implies `r x z` </code>",
 "1327": "<code>b ≈ c</code>",
 "1326":
 "<code>Setoid.trans.{u} {α : Sort u} [Setoid α] {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c</code>",
 "1325":
 "<code>Equivalence.symm.{u} {α : Sort u} {r : α → α → Prop} (self : Equivalence r) {x y : α} : r x y → r y x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is symmetric: `r x y` implies `r y x` </code>",
 "1324": "<code>a ≈ b</code>",
 "1323":
 "<code>Setoid.symm.{u} {α : Sort u} [Setoid α] {a b : α} (hab : a ≈ b) : b ≈ a</code>",
 "1322":
 "<code>Equivalence.refl.{u} {α : Sort u} {r : α → α → Prop} (self : Equivalence r) (x : α) : r x x</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation is reflexive: `r x x` </code>",
 "1321":
 "<code>Setoid.iseqv.{u} {α : Sort u} [self : Setoid α] : Equivalence r</code>",
 "1320": "<code>Setoid.refl.{u} {α : Sort u} [Setoid α] (a : α) : a ≈ a</code>",
 "132":
 "<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "1319":
 "<code>HasEquiv.mk.{u, v} {α : Sort u} (Equiv : α → α → Sort v) : HasEquiv α</code>",
 "1318":
 "<code>HasEquiv.{u, v} (α : Sort u) : Sort (max u (v + 1))</code><span class=\"sep\"></span><code class=\"docstring\">`HasEquiv α` is the typeclass which supports the notation `x ≈ y` where `x y : α`.</code>",
 "1317":
 "<code>Equivalence.{u} {α : Sort u} (r : α → α → Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation `r : α → α → Prop` is a relation that is\n\n* reflexive: `r x x`,\n* symmetric: `r x y` implies `r y x`, and\n* transitive: `r x y` and `r y z` implies `r x z`.\n\nEquality is an equivalence relation, and equivalence relations share many of the properties of\nequality.\n</code>",
 "1316":
 "<code>Setoid.iseqv.{u} {α : Sort u} [self : Setoid α] : Equivalence self.r</code>",
 "1315":
 "<code>Setoid.r.{u} {α : Sort u} [self : Setoid α] : α → α → Prop</code>",
 "1314": "<code>Setoid.{u} (α : Sort u) : Sort (max 1 u)</code>",
 "1313":
 "<code>Quot.sound.{u} {α : Sort u} {r : α → α → Prop} {a b : α} : r a b → Quot.mk r a = Quot.mk r b</code><span class=\"sep\"></span><code class=\"docstring\">The **quotient axiom**, which asserts the equality of elements related by the quotient's relation.\n\nThe relation `r` does not need to be an equivalence relation to use this axiom. When `r` is not an\nequivalence relation, the quotient is with respect to the equivalence relation generated by `r`.\n\n`Quot.sound` is part of the built-in primitive quotient type:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n\n[Quotient types](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=quotients) are described in more detail in the Lean Language\nReference.\n</code>",
 "1312":
 "<code>Quot.sound.{u} {α : Type u} {r : α → α → Prop} {a b : α} : r a b → Quot.mk r a = Quot.mk r b</code>",
 "1311": "<code>a % 7 = b % 7</code>",
 "1310": "<code>mod7Rel a b</code>",
 "131": "<code><span class=\"literal string\">\"hello\"</span> : String</code>",
 "1309": "<code>f_respects (a b : Nat) (h : mod7Rel a b) : f a = f b</code>",
 "1308": "<code>f (x : Nat) : Bool</code>",
 "1307": "<code>mod7Rel (x y : Nat) : Prop</code>",
 "1306": "<code>∀ (a b : α), r a b → f a = f b</code>",
 "1305": "<code>Sort ?u.706</code>",
 "1304":
 "<code>Quot.lift.{u, v} {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) (a : ∀ (a b : α), r a b → f a = f b) :\n  Quot r → β</code><span class=\"sep\"></span><code class=\"docstring\">Lifts a function from an underlying type to a function on a quotient, requiring that it respects the\nquotient's relation.\n\nGiven a relation `r : α → α → Prop` and a quotient `Quot r`, applying a function `f : α → β`\nrequires a proof `a` that `f` respects `r`. In this case, `Quot.lift f a : Quot r → β` computes the\nsame values as `f`.\n\nLean's type theory includes a [definitional reduction](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=type-theory) from\n`Quot.lift f h (Quot.mk r v)` to `f v`.\n\n`Quot.lift` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.sound` asserts the equality of elements related by `r`\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`; it is analogous to the [recursor](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=recursors) for a\n   structure.\n</code>",
 "1303":
 "<code>Quot.ind.{u} {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (mk : ∀ (a : α), β (Quot.mk r a)) (q : Quot r) : β q</code><span class=\"sep\"></span><code class=\"docstring\">A reasoning principle for quotients that allows proofs about quotients to assume that all values are\nconstructed with `Quot.mk`.\n\n`Quot.rec` is analogous to the [recursor](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=recursors) for a structure, and can\nbe used when the resulting type is not necessarily a proposition.\n\n`Quot.ind` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n</code>",
 "1302":
 "<code>Quot.mk.{u} {α : Sort u} (r : α → α → Prop) (a : α) : Quot r</code><span class=\"sep\"></span><code class=\"docstring\">Places an element of a type into the quotient that equates terms according to the provided relation.\n\nGiven `v : α` and relation `r : α → α → Prop`, `Quot.mk r v : Quot r` is like `v`, except all\nobservations of `v`'s value must respect `r`.\n\n`Quot.mk` is a built-in primitive:\n * `Quot` is the built-in quotient type.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n</code>",
 "1301":
 "<code>Quot.{u} {α : Sort u} (r : α → α → Prop) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Low-level quotient types. Quotient types coarsen the propositional equality for a type `α`, so that\nterms related by some relation `r` are considered equal in `Quot r`.\n\nSet-theoretically, `Quot r` can seen as the set of equivalence classes of `α` modulo `r`. Functions\nfrom `Quot r` must prove that they respect `r`: to define a function `f : Quot r → β`, it is\nnecessary to provide `f' : α → β` and prove that for all `x : α` and `y : α`, `r x y → f' x = f' y`.\n\n`Quot` is a built-in primitive:\n * `Quot.mk` places elements of the underlying type `α` into the quotient.\n * `Quot.lift` allows the definition of functions from the quotient to some other type.\n * `Quot.sound` asserts the equality of elements related by `r`.\n * `Quot.ind` is used to write proofs about quotients by assuming that all elements are constructed\n   with `Quot.mk`.\n\nThe relation `r` is not required to be an equivalence relation; the resulting quotient type's\nequality extends `r` to an equivalence as a consequence of the rules for equality and quotients.\nWhen `r` is an equivalence relation, it can be more convenient to use the higher-level type\n`Quotient`.\n</code>",
 "1300":
 "<code>Quot.lift.{u} {α : Sort u} {r : α → α → Prop} {β : Sort u} (f : α → β) : (∀ (a b : α), r a b → f a = f b) → Quot r → β</code>",
 "130": "<code>ident.{u} {α : Type u} (x : α) : α</code>",
 "13": "<code>b1 : Bool</code>",
 "1299": "<code>Quot r</code>",
 "1298": "<code>Quot r → Prop</code>",
 "1297":
 "<code>Quot.ind.{u} {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} : (∀ (a : α), β (mk r a)) → ∀ (q : Quot r), β q</code>",
 "1296":
 "<code>Quot.mk.{u} {α : Sort u} (r : α → α → Prop) : α → Quot r</code>",
 "1295": "<code>Quot.{u} {α : Sort u} : (α → α → Prop) → Sort u</code>",
 "1294": "<code>Sort ?u.3934</code>",
 "1293": "<code>Quot r → β</code>",
 "1292": "<code>Sort ?u.3631</code>",
 "1291": "<code>(fun x x =&gt; Nat) (True ∧ True) ⋯</code>",
 "1290": "<code>True</code>",
 "129": "<code>Lst.append.{u} {α : Type u} (as bs : Lst α) : Lst α</code>",
 "1289": "<code>tteq : (True ∧ True) = True</code>",
 "1288": "<code>(fun x x =&gt; Nat) f ⋯</code>",
 "1287":
 "<code>Eq.recOn.{u, u_1} {α : Sort u_1} {a✝ : α} {motive : (a : α) → a✝ = a → Sort u} {a✝¹ : α} (t : a✝ = a✝¹)\n  (refl : motive a✝ ⋯) : motive a✝¹ t</code>",
 "1286": "<code>val : Nat</code>",
 "1285": "<code>f_eq_g : f = g</code>",
 "1284": "<code>g (x : Nat) : Nat</code>",
 "1283": "<code>x✝¹∈b</code>",
 "1282": "<code>x✝¹∈a</code>",
 "1281":
 "<code>Set.inter.comm.{u_1} {α : Type u_1} (a b : Set α) : a ∩ b = b ∩ a</code>",
 "1280":
 "<code>Set.empty_inter.{u_1} {α : Type u_1} (a : Set α) : ∅ ∩ a = ∅</code>",
 "128": "<code>Lst.nil.{u} {α : Type u} : Lst α</code>",
 "1279": "<code>x✝∈∅</code>",
 "1278": "<code>x✝¹∈∅</code>",
 "1277":
 "<code>Set.inter_empty.{u_1} {α : Type u_1} (a : Set α) : a ∩ ∅ = ∅</code>",
 "1276": "<code>x∈a</code>",
 "1275":
 "<code>Set.inter_self.{u_1} {α : Type u_1} (a : Set α) : a ∩ a = a</code>",
 "1274": "<code><span class=\"literal string\">\" ∩ \"</span> : String</code>",
 "1273": "<code>Set.inter.{u_1} {α : Type u_1} (a b : Set α) : Set α</code>",
 "1272": "<code><span class=\"literal string\">\"∅\"</span> : String</code>",
 "1271": "<code>Set.empty.{u_1} {α : Type u_1} : Set α</code>",
 "1270": "<code>∀ (x : α), x∈a ↔ x∈b</code>",
 "127": "<code>Lst.cons.{u} {α : Type u} (a : α) (as : Lst α) : Lst α</code>",
 "1269":
 "<code>Set.setext.{u_1} {α : Type u_1} {a b : Set α} (h : ∀ (x : α), x∈a ↔ x∈b) : a = b</code>",
 "1268": "<code><span class=\"literal string\">\"∈\"</span> : String</code>",
 "1267":
 "<code class=\"docstring\">The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. </code>",
 "1266": "<code>Set.mem.{u_1} {α : Type u_1} (x : α) (a : Set α) : Prop</code>",
 "1265": "<code>∀ (x : α), f x = g x</code>",
 "1264":
 "<code>funext.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code><span class=\"sep\"></span><code class=\"docstring\">**Function extensionality.** If two functions return equal results for all possible arguments, then\nthey are equal.\n\nIt is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be [proved using quotient\ntypes](https://lean-lang.org/doc/reference/4.21.0/find/?domain=Verso.Genre.Manual.section&name=quotient-funext).\n</code>",
 "1263": "<code>Prop → Prop</code>",
 "1262":
 "<code>thm₂ (a b : Prop) (p : Prop → Prop) (h : a ↔ b) (h₁ : p a) : p b</code>",
 "1261": "<code>Iff.refl (a : Prop) : a ↔ a</code>",
 "1260":
 "<code>propext {a b : Prop} : (a ↔ b) → a = b</code><span class=\"sep\"></span><code class=\"docstring\">The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a ∧ c ∨ d → e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop → Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True → True) ↔ True := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩\n  have := propext this ▸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x =&gt; True.intro, mpr := fun x =&gt; True.intro } ▸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n</code>",
 "126": "<code>bs : Lst Nat</code>",
 "1259": "<code>a ↔ b</code>",
 "1258":
 "<code>thm₁ (a b c d e : Prop) (h : a ↔ b) : c ∧ a ∧ d → e ↔ c ∧ b ∧ d → e</code>",
 "1257": "<code>propext {a b : Prop} : (a ↔ b) → a = b</code>",
 "1256": "<code>Sort ?u.887</code>",
 "1255":
 "<code class=\"docstring\">The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. </code>",
 "1254": "<code class=\"docstring\">`skip` does nothing. </code>",
 "1253": "<code>x ≠ 0</code>",
 "1252": "<code>∀ (x : Nat), x ≠ 0 → g x x = 1</code>",
 "1251":
 "<code class=\"docstring\">`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. </code>",
 "1250":
 "<code class=\"docstring\">Traverses into the right subterm of a binary operator.\n\nIn general, for an `n`-ary operator, it traverses into the last argument.\nIt is a synonym for `arg -1`.\n</code>",
 "125": "<code>as : Lst Nat</code>",
 "1249": "<code>g x = x + 1</code>",
 "1248": "<code>f (x : Nat) : Nat</code>",
 "1247":
 "<code class=\"docstring\">* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n  The index may be negative; `arg -1` traverses into the last argument,\n  `arg -2` into the second-to-last argument, and so on.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments.\n* `arg 0` traverses into the function. If the target is `f a b c d`, `arg 0` traverses into `f`. </code>",
 "1246":
 "<code class=\"docstring\">* `pattern pat` traverses to the first subterm of the target that matches `pat`.\n* `pattern (occs := *) pat` traverses to every subterm of the target that matches `pat`\n  which is not contained in another match of `pat`. It generates one subgoal for each matching\n  subterm.\n* `pattern (occs := 1 2 4) pat` matches occurrences `1, 2, 4` of `pat` and produces three subgoals.\n  Occurrences are numbered left to right from the outside in.\n\nNote that skipping an occurrence of `pat` will traverse inside that subexpression, which means\nit may find more matches and this can affect the numbering of subsequent pattern matches.\nFor example, if we are searching for `f _` in `f (f a) = f b`:\n* `occs := 1 2` (and `occs := *`) returns `| f (f a)` and `| f b`\n* `occs := 2` returns `| f a`\n* `occs := 2 3` returns `| f a` and `| f b`\n* `occs := 1 3` is an error, because after skipping `f b` there is no third match.\n</code>",
 "1245":
 "<code class=\"docstring\">`intro` traverses into binders. Synonym for `ext`. </code>",
 "1244":
 "<code class=\"docstring\">`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. </code>",
 "1243":
 "<code class=\"docstring\">`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). </code>",
 "1242":
 "<code class=\"docstring\">Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. </code>",
 "1241":
 "<code>resp_mul.{u_1, u_2} {S1 : Semigroup} {S2 : Semigroup} (f : Morphism S1 S2) (a b : S1.carrier) :\n  f.mor (a * b) = f.mor a * f.mor b</code>",
 "1240": "<code>Morphism S1 S2</code>",
 "124":
 "<code>List.append.{u} {α : Type u} (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Appends two lists. Normally used via the `++` operator.\n\nAppending lists takes time proportional to the length of the first list: `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\n* `[] ++ [4, 5] = [4, 5]`.\n* `[1, 2, 3] ++ [] = [1, 2, 3]`.\n</code>",
 "1239":
 "<code>Morphism S1 S2 → S1.carrier → S2.carrier</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value `f : α` to type `γ f`, which should be either be a\nfunction type or another `CoeFun` type, in order to resolve a mistyped\napplication `f x`. </code>",
 "1238":
 "<code>CoeFun.{u, v} (α : Sort u) (γ : outParam (α → Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeFun α (γ : α → Sort v)` is a coercion to a function. `γ a` should be a\n(coercion-to-)function type, and this is triggered whenever an element\n`f : α` appears in an application like `f x`, which would not make sense since\n`f` does not have a function type.\n`CoeFun` instances apply to `CoeOut` as well.\n</code>",
 "1237": "<code>S1.carrier → S2.carrier</code>",
 "1236": "<code>S1.carrier</code>",
 "1235":
 "<code>Morphism.resp_mul.{u_1, u_2} {S1 : Semigroup} {S2 : Semigroup} (self : Morphism S1 S2) (a b : S1.carrier) :\n  self.mor (a * b) = self.mor a * self.mor b</code>",
 "1234":
 "<code>Morphism.mor.{u_1, u_2} {S1 : Semigroup} {S2 : Semigroup} (self : Morphism S1 S2) : S1.carrier → S2.carrier</code>",
 "1233":
 "<code>Morphism.{u_1, u_2} (S1 : Semigroup) (S2 : Semigroup) : Type (max u_1 u_2)</code>",
 "1232": "<code>B</code>",
 "1231":
 "<code>Semigroup → Type u</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to `β`, which must be a universe. </code>",
 "1230":
 "<code>CoeSort.{u, v} (α : Sort u) (β : outParam (Sort v)) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeSort α β` is a coercion to a sort. `β` must be a universe, and this is\ntriggered when `a : α` appears in a place where a type is expected, like\n`(x : a)` or `a → a`.\n`CoeSort` instances apply to `CoeOut` as well.\n</code>",
 "123": "<code>Lst.append.{u} (α : Type u) (as bs : Lst α) : Lst α</code>",
 "1229": "<code>S.carrier</code>",
 "1228":
 "<code>S.carrier → S.carrier → S.carrier</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`. See `HMul`. </code>",
 "1227":
 "<code>Mul.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The homogeneous version of `HMul`: `a * b : α` where `a b : α`. </code>",
 "1226": "<code>Semigroup</code>",
 "1225":
 "<code>CoeT.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeT` is the core typeclass which is invoked by Lean to resolve a type error.\nIt can also be triggered explicitly with the notation `↑x` or by double type\nascription `((x : α) : β)`.\n\nA `CoeT` chain has the grammar `CoeHead? CoeOut* Coe* CoeTail? | CoeDep`.\n</code>",
 "1224":
 "<code>Bool</code><span class=\"sep\"></span><code class=\"docstring\">The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. </code>",
 "1223":
 "<code>CoeDep.{u, v} (α : Sort u) : α → (β : Sort v) → Sort (max 1 v)</code><span class=\"sep\"></span><code class=\"docstring\">`CoeDep α (x : α) β` is a typeclass for dependent coercions, that is, the type `β`\ncan depend on `x` (or rather, the value of `x` is available to typeclass search\nso an instance that relates `β` to `x` is allowed).\n\nDependent coercions do not participate in the transitive chaining process of\nregular coercions: they must exactly match the type mismatch on both sides.\n</code>",
 "1222": "<code>Set Nat</code>",
 "1221": "<code>s : Set Nat</code>",
 "1220":
 "<code>List α → Set α</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "122": "<code>Lst.nil.{u} (α : Type u) : Lst α</code>",
 "1219": "<code>List.toSet.{u_1} {α : Type u_1} : List α → Set α</code>",
 "1218": "<code><span class=\"literal string\">\" ∪ \"</span> : String</code>",
 "1217": "<code><span class=\"literal string\">\" }\"</span> : String</code>",
 "1216": "<code><span class=\"literal string\">\"{ \"</span> : String</code>",
 "1215": "<code>Set.union.{u_1} {α : Type u_1} (a b : Set α) : Set α</code>",
 "1214": "<code>Set.singleton.{u_1} {α : Type u_1} (a : α) : Set α</code>",
 "1213": "<code>Set α</code>",
 "1212": "<code>Set.mem.{u_1} {α : Type u_1} (a : α) (s : Set α) : Prop</code>",
 "1211": "<code>Set.empty.{u} {α : Type u} : Set α</code>",
 "1210":
 "<code>Bool → Prop</code><span class=\"sep\"></span><code class=\"docstring\">Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,\nor by double type ascription `((x : α) : β)`. </code>",
 "121": "<code>Lst α</code>",
 "1209":
 "<code>Coe.{u, v} (α : semiOutParam (Sort u)) (β : Sort v) : Sort (max (max 1 u) v)</code><span class=\"sep\"></span><code class=\"docstring\">`Coe α β` is the typeclass for coercions from `α` to `β`. It can be transitively\nchained with other `Coe` instances, and coercion is automatically used when\n`x` has type `α` but it is used in a context where `β` is expected.\nYou can use the `↑x` operator to explicitly trigger coercion.\n</code>",
 "1208": "<code>i3 : Foo</code>",
 "1207": "<code>i2 : Foo</code>",
 "1206": "<code>i1 : Foo</code>",
 "1205":
 "<code class=\"docstring\">The default priority `default = 1000`, which is used when no priority is set. </code>",
 "1204": "<code>Foo.b [self : Foo] : Nat</code>",
 "1203": "<code>Foo.a [self : Foo] : Nat</code>",
 "1202":
 "<code>synthInstance.maxHeartbeats</code><span class=\"sep\"></span><code class=\"docstring\">maximum amount of heartbeats per typeclass resolution problem. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit</code>",
 "1201":
 "<code>trace.Meta.synthInstance</code><span class=\"sep\"></span><code class=\"docstring\">enable/disable tracing for the given module and submodules</code>",
 "1200": "<code>Set.{u} (α : Type u) : Type u</code>",
 "120": "<code>Lst.cons.{u} (α : Type u) (a : α) (as : Lst α) : Lst α</code>",
 "12": "<code>n : Nat</code>",
 "1199":
 "<code>inferInstanceAs.{u} (α : Sort u) [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n</code>",
 "1198": "<code>Sort ?u.11</code>",
 "1197": "<code>bar : Inhabited (Nat → Nat)</code>",
 "1196": "<code>foo : Add Nat</code>",
 "1195":
 "<code>of_decide_eq_true {p : Prop} [inst : Decidable p] : decide p = true → p</code>",
 "1194": "<code>ex : True ∧ 2 = 1 + 1</code>",
 "1193":
 "<code>Decidable.decide (p : Prop) [h : Decidable p] : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Converts a decidable proposition into a `Bool`.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the Boolean value\nthat is `true` if `p` is true and `false` if `p` is false.\n</code>",
 "1192":
 "<code>Decidable.isFalse {p : Prop} (h : ¬p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `¬p` </code>",
 "1191": "<code>¬a</code>",
 "1190":
 "<code>Decidable.isTrue {p : Prop} (h : p) : Decidable p</code><span class=\"sep\"></span><code class=\"docstring\">Proves that `p` is decidable by supplying a proof of `p` </code>",
 "119": "<code>Lst.{u} (α : Type u) : Type u</code>",
 "1189":
 "<code>Classical.choice.{u} {α : Sort u} : Nonempty α → α</code><span class=\"sep\"></span><code class=\"docstring\">**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i =&gt; Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn Lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so Lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n</code>",
 "1188": "<code>Hidden.propDecidable (a : Prop) : Decidable a</code>",
 "1187":
 "<code>Classical.propDecidable (a : Prop) : Decidable a</code><span class=\"sep\"></span><code class=\"docstring\">All propositions are `Decidable`. </code>",
 "1186": "<code>step (a b x : Nat) : Nat</code>",
 "1185":
 "<code>instDecidableOr {p q : Prop} [dp : Decidable p] [dq : Decidable q] : Decidable (p ∨ q)</code>",
 "1184":
 "<code>instDecidableAnd {p q : Prop} [dp : Decidable p] [dq : Decidable q] : Decidable (p ∧ q)</code>",
 "1183": "<code>¬c</code>",
 "1182": "<code>c</code>",
 "1181":
 "<code>dite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : ¬c → α) : α</code><span class=\"sep\"></span><code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "1180": "<code>¬c → α</code>",
 "118": "<code>h2 (x : Nat) : Nat</code>",
 "1179": "<code>c → α</code>",
 "1178":
 "<code>Hidden.dite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : ¬c → α) : α</code>",
 "1177":
 "<code>Decidable.casesOn.{u} {p : Prop} {motive : Decidable p → Sort u} (t : Decidable p)\n  (isFalse : (h : ¬p) → motive (isFalse h)) (isTrue : (h : p) → motive (isTrue h)) : motive t</code>",
 "1176": "<code>Decidable c</code>",
 "1175":
 "<code>Hidden.ite.{u} {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α</code>",
 "1174": "<code>p ∨ ¬p</code>",
 "1173": "<code>Decidable p</code>",
 "1172":
 "<code>Hidden.Decidable.isFalse {p : Prop} (h : ¬p) : Decidable p</code>",
 "1171": "<code>Hidden.Decidable (p : Prop) : Type</code>",
 "1170":
 "<code>Decidable (p : Prop) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Either a proof that `p` is true or a proof that `p` is false. This is equivalent to a `Bool` paired\nwith a proof that the `Bool` is `true` if and only if `p` is true.\n\n`Decidable` instances are primarily used via `if`-expressions and the tactic `decide`. In\nconditional expressions, the `Decidable` instance for the proposition is used to select a branch. At\nrun time, this case distinction code is identical to that which would be generated for a\n`Bool`-based conditional. In proofs, the tactic `decide` synthesizes an instance of `Decidable p`,\nattempts to reduce it to `isTrue h`, and then succeeds with the proof `h` if it can.\n\nBecause `Decidable` carries data, when writing `@[simp]` lemmas which include a `Decidable` instance\non the LHS, it is best to use `{_ : Decidable p}` rather than `[Decidable p]` so that non-canonical\ninstances can be found via unification rather than instance synthesis.\n</code>",
 "117": "<code>h1 (x : Nat) : Nat</code>",
 "1169": "<code>Point.double (p : Point) : Point</code>",
 "1168": "<code>addPoint : Add Point</code>",
 "1167": "<code>(p : Point) → ?m.552 p</code>",
 "1166": "<code>double (p : Point) : Point</code>",
 "1165": "<code>Point</code>",
 "1164":
 "<code>Point → Point → Point</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1163": "<code>Point.y (self : Point) : Nat</code>",
 "1162": "<code>Point.x (self : Point) : Nat</code>",
 "1161": "<code>Point : Type</code>",
 "1160": "<code><span class=\"literal string\">\" * \"</span> : String</code>",
 "116":
 "<code>g.{u, v} (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a</code>",
 "1159": "<code>α → α → α</code>",
 "1158": "<code>Ex.Mul.mul.{u} {α : Type u} [self : Mul α] : α → α → α</code>",
 "1157": "<code>Ex.Mul.{u} (α : Type u) : Type u</code>",
 "1156":
 "<code>Ex.OfNat.ofNat.{u} {α : Type u} (n : Nat) [self : OfNat α n] : α</code>",
 "1155": "<code>Ex.OfNat.{u} (α : Type u) (n : Nat) : Type u</code>",
 "1154":
 "<code>HMul.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n</code>",
 "1153": "<code>?m.225</code>",
 "1152": "<code>Ex.xs : List Int</code>",
 "1151": "<code>Array β</code>",
 "1150": "<code>α → Array β → Array γ</code>",
 "115": "<code class=\"docstring\">The universe parameter v</code>",
 "1149":
 "<code>Int.mul (m n : Int) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Multiplication of integers, usually accessed via the `*` operator.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `(63 : Int) * (6 : Int) = 378`\n * `(6 : Int) * (-6 : Int) = -36`\n * `(7 : Int) * (0 : Int) = 0`\n</code>",
 "1148":
 "<code>Array.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (as : Array α) : Array β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the array, returning the resulting array of values.\n\nExamples:\n* `#[a, b, c].map f = #[f a, f b, f c]`\n* `#[].map Nat.succ = #[]`\n* `#[\"one\", \"two\", \"three\"].map (·.length) = #[3, 3, 5]`\n* `#[\"one\", \"two\", \"three\"].map (·.reverse) = #[\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "1147": "<code>Array Nat</code>",
 "1146": "<code>Nat → Array Nat → Array Nat</code>",
 "1145":
 "<code>Ex.HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code>",
 "1144":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "1143": "<code>outParam (Type w)</code>",
 "1142":
 "<code>Ex.HMul.{u, v, w} (α : Type u) (β : Type v) (γ : outParam (Type w)) : Type (max (max u v) w)</code>",
 "1141": "<code>getUnit.{u_1} {α : Type u_1} [Monoid α] : α</code>",
 "1140":
 "<code>α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "114": "<code>α → Type v</code>",
 "1139": "<code>Monoid α</code>",
 "1138":
 "<code>Monoid.op.{u} {α : Type u} [self : Monoid α] : α → α → α</code>",
 "1137": "<code>Monoid.unit.{u} {α : Type u} [self : Monoid α] : α</code>",
 "1136": "<code>Monoid.{u} (α : Type u) : Type u</code>",
 "1135":
 "<code class=\"docstring\">The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n</code>",
 "1134": "<code>instOfNatRational {n : Nat} : OfNat Rational n</code>",
 "1133": "<code>instOfNatNat (n : Nat) : OfNat Nat n</code>",
 "1132":
 "<code>OfNat.ofNat.{u} {α : Type u} (x✝ : Nat) [self : OfNat α x✝] : α</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1131": "<code>Rational</code>",
 "1130":
 "<code>Rational → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "113":
 "<code>f.{u, v} (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a</code>",
 "1129":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "1128": "<code>1 ≠ 0</code>",
 "1127": "<code>Int</code>",
 "1126":
 "<code>Rational</code><span class=\"sep\"></span><code class=\"docstring\">The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. </code>",
 "1125": "<code>Rational.inv (self : Rational) : self.den ≠ 0</code>",
 "1124": "<code>Rational.den (self : Rational) : Nat</code>",
 "1123": "<code>Rational.num (self : Rational) : Int</code>",
 "1122": "<code>Rational : Type</code>",
 "1121":
 "<code>OfNat.{u} (α : Type u) : Nat → Type u</code><span class=\"sep\"></span><code class=\"docstring\">The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, Lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that Lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n</code>",
 "1120":
 "<code><span class=\"literal string\">\"Daniel\"</span> : String</code>",
 "112": "<code>β a</code>",
 "1119": "<code><span class=\"literal string\">\"Leo\"</span> : String</code>",
 "1118": "<code>String</code>",
 "1117": "<code><span class=\"literal string\">\"@\"</span> : String</code>",
 "1116": "<code>Person</code>",
 "1115": "<code>Person.age (self : Person) : Nat</code>",
 "1114": "<code>Person.name (self : Person) : String</code>",
 "1113": "<code>Person : Type</code>",
 "1112":
 "<code>ToString.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Types that can be converted into a string for display.\n\nThere is no expectation that the resulting string can be parsed back to the original data (see\n`Repr` for a similar class with this expectation).\n</code>",
 "1111":
 "<code>Person → String</code><span class=\"sep\"></span><code class=\"docstring\">Converts a value into a string. </code>",
 "1110": "<code>ex : default = (default, default)</code>",
 "111":
 "<code>Sigma.mk.{u, v} {α : Type u} {β : α → Type v} (fst : α) (snd : β fst) : Sigma β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a dependent pair.\n\nUsing this constructor in a context in which the type is not known usually requires a type\nascription to determine `β`. This is because the desired relationship between the two values can't\ngenerally be determined automatically.\n</code>",
 "1109": "<code>foo : Inhabited (Nat × Nat)</code>",
 "1108":
 "<code>inferInstance.{u} {α : Sort u} [i : α] : α</code><span class=\"sep\"></span><code class=\"docstring\">`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n</code>",
 "1107":
 "<code>α → β</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1106": "<code>α × β</code>",
 "1105": "<code>Ex.default.{u_1} {α : Type u_1} [Inhabited α] : α</code>",
 "1104":
 "<code>α × β</code><span class=\"sep\"></span><code class=\"docstring\">`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. </code>",
 "1103": "<code>Prop</code>",
 "1102": "<code>Unit</code>",
 "1101":
 "<code>Ex.Inhabited.default.{u_1} {a : Type u_1} [self : Inhabited a] : a</code>",
 "1100": "<code class=\"docstring\">The universe parameter [anonymous]</code>",
 "110":
 "<code>List.length.{u_1} {α : Type u_1} : List α → Nat</code><span class=\"sep\"></span><code class=\"docstring\">The length of a list.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant stack space.\n\nExamples:\n* `([] : List String).length = 0`\n* `[\"green\", \"brown\"].length = 2`\n</code>",
 "11": "<code>Nat</code>",
 "1099": "<code>Ex.Inhabited.{u_1} (a : Type u_1) : Type u_1</code>",
 "1098":
 "<code>Inhabited.mk.{u} {α : Sort u} (default : α) : Inhabited α</code>",
 "1097":
 "<code>Ex.Inhabited.default.{u} {α : Type u} [self : Inhabited α] : α</code>",
 "1096": "<code>Ex.Inhabited.{u} (α : Type u) : Type u</code>",
 "1095":
 "<code>head.{u_1} {α : Type u_1} [Inhabited α] (xs : List α) : α</code>",
 "1094": "<code>?m.22 x</code>",
 "1093": "<code>?m.14</code>",
 "1092":
 "<code>Add.add.{u} {α : Type u} [self : Add α] : α → α → α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "1091":
 "<code>Array.zipWith.{u, u_1, u_2} {α : Type u} {β : Type u_1} {γ : Type u_2} (f : α → β → γ) (as : Array α) (bs : Array β) :\n  Array γ</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to the corresponding elements of two arrays, stopping at the end of the shorter\narray.\n\nExamples:\n* `#[1, 2].zipWith (· + ·) #[5, 6] = #[6, 8]`\n* `#[1, 2, 3].zipWith (· + ·) #[5, 6, 10] = #[6, 8, 13]`\n* `#[].zipWith (· + ·) #[5, 6] = #[]`\n* `#[x₁, x₂, x₃].zipWith f #[y₁, y₂, y₃, y₄] = #[f x₁ y₁, f x₂ y₂, f x₃ y₃]`\n</code>",
 "1090":
 "<code>Array α → Array α → Array α</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`. See `HAdd`. </code>",
 "109": "<code>(a : α) → β a</code>",
 "1089": "<code>Float</code>",
 "1088": "<code>Ex.double {α : Type} [Add α] (x : α) : α</code>",
 "1087":
 "<code>Float.add : Float → Float → Float</code><span class=\"sep\"></span><code class=\"docstring\">Adds two 64-bit floating-point numbers according to IEEE 754. Typically used via the `+` operator.\n\nThis function does not reduce in the kernel. It is compiled to the C addition operator.\n</code>",
 "1086": "<code>Float → Float → Float</code>",
 "1085":
 "<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">64-bit floating-point numbers.\n\n`Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra “sentinel” values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of “not a number” values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n</code>",
 "1084": "<code>Ex.Add.add {α : Type} [self : Add α] : α → α → α</code>",
 "1083":
 "<code>Int.add (m n : Int) : Int</code><span class=\"sep\"></span><code class=\"docstring\">Addition of integers, usually accessed via the `+` operator.\n\nThis function is overridden by the compiler with an efficient implementation. This definition is\nthe logical model.\n\nExamples:\n * `(7 : Int) + (6 : Int) = 13`\n * `(6 : Int) + (-6 : Int) = 0`\n</code>",
 "1082": "<code>Int → Int → Int</code>",
 "1081": "<code>Nat → Nat → Nat</code>",
 "1080": "<code>Add α</code>",
 "108": "<code>α → Type</code>",
 "1079": "<code>Ex.double {α : Type} (s : Add α) (x : α) : α</code>",
 "1078": "<code>Ex.Add.add {α : Type} (self : Add α) : α → α → α</code>",
 "1077": "<code>Ex.Add (α : Type) : Type</code>",
 "1076": "<code>0 = 0</code>",
 "1075": "<code>rgp : RedGreenPoint Nat</code>",
 "1074":
 "<code>RedGreenPoint.no_blue.{u} {α : Type u} (self : RedGreenPoint α) : self.blue = 0</code>",
 "1073": "<code>RedGreenPoint.{u} (α : Type u) : Type u</code>",
 "1072": "<code>RGBValue.blue (self : RGBValue) : Nat</code>",
 "1071": "<code>RGBValue.green (self : RGBValue) : Nat</code>",
 "1070": "<code>RGBValue.red (self : RGBValue) : Nat</code>",
 "107": "<code>List α</code>",
 "1069": "<code>RGBValue : Type</code>",
 "1068": "<code>Point.z.{u} {α : Type u} (self : Point α) : α</code>",
 "1067":
 "<code>ColorPoint.c.{u} {α : Type u} (self : ColorPoint α) : Color</code>",
 "1066": "<code>ColorPoint.{u} (α : Type u) : Type u</code>",
 "1065": "<code>Color.green : Color</code>",
 "1064": "<code>Color.red : Color</code>",
 "1063": "<code>r : Point3 Nat</code>",
 "1062": "<code>q : Point3 Nat</code>",
 "1061": "<code>Point3.z.{u} {α : Type u} (self : Point3 α) : α</code>",
 "1060": "<code>Point3.y.{u} {α : Type u} (self : Point3 α) : α</code>",
 "106": "<code>cons (α : Type) (a : α) (as : List α) : List α</code>",
 "1059": "<code>Point3.x.{u} {α : Type u} (self : Point3 α) : α</code>",
 "1058": "<code>Point3.{u} (α : Type u) : Type u</code>",
 "1057": "<code>Bool</code>",
 "1056": "<code>MyStruct.b.{u, v} (self : MyStruct) : self.β</code>",
 "1055": "<code>MyStruct.a.{u, v} (self : MyStruct) : self.α</code>",
 "1054": "<code>MyStruct.β.{u, v} (self : MyStruct) : Type v</code>",
 "1053": "<code>MyStruct.α.{u, v} (self : MyStruct) : Type u</code>",
 "1052": "<code>MyStruct.{u, v} : Type (max (u + 1) (v + 1))</code>",
 "1051": "<code>Nat</code>",
 "1050": "<code>f : Nat → Nat</code>",
 "105":
 "<code>Vector.{u} (α : Type u) (n : Nat) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">`Vector α n` is an `Array α` with size `n`. </code>",
 "1049": "<code>xs : List Nat</code>",
 "1048": "<code>Point.smul (n : Nat) (p : Point Nat) : Point Nat</code>",
 "1047": "<code>q : Point Nat</code>",
 "1046": "<code>Point.add (p q : Point Nat) : Point Nat</code>",
 "1045": "<code>p : Point Nat</code>",
 "1044": "<code>Point Nat</code>",
 "1043":
 "<code>Point.rec.{u_1, u} {α : Type u} {motive : Point α → Sort u_1} (mk : (x y : α) → motive { x := x, y := y })\n  (t : Point α) : motive t</code>",
 "1042": "<code>Point α</code>",
 "1041": "<code>Point.y.{u} {α : Type u} (self : Point α) : α</code>",
 "1040": "<code>Point.x.{u} {α : Type u} (self : Point α) : α</code>",
 "104": "<code>Foo.Bar.ffa : Nat</code>",
 "1039": "<code>Point.mk.{u} {α : Type u} (x y : α) : Point α</code>",
 "1038": "<code>Point.{u} (α : Type u) : Type u</code>",
 "1037":
 "<code>fuse_eq (v : Nat → Nat) (e : Expr) : eval v (fuse e) = eval v e</code>",
 "1036":
 "<code>simpConst_eq (v : Nat → Nat) (e : Expr) : eval v (simpConst e) = eval v e</code>",
 "1035": "<code>fuse : Expr → Expr</code>",
 "1034": "<code>simpConst : Expr → Expr</code>",
 "1033": "<code>sampleVal : Nat → Nat</code>",
 "1032": "<code>Expr</code>",
 "1031": "<code>eval (v : Nat → Nat) : Expr → Nat</code>",
 "1030": "<code>sampleExpr : Expr</code>",
 "103":
 "<code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">The list whose first element is `head`, where `tail` is the rest of the list.\nUsually written `head :: tail`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `::` in identifiers is `cons`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.</code>",
 "1029": "<code>Expr.times : Expr → Expr → Expr</code>",
 "1028": "<code>Expr.plus : Expr → Expr → Expr</code>",
 "1027": "<code>Expr : Type</code>",
 "1026": "<code>Expr.const : Nat → Expr</code>",
 "1025": "<code>Expr.var : Nat → Expr</code>",
 "1024": "<code>∃ y, q y</code>",
 "1023": "<code>q y</code>",
 "1022": "<code>bar₄ (p : Nat × Nat) : Nat</code>",
 "1021": "<code>bar₃ : Nat × Nat → Nat</code>",
 "1020": "<code>bar₂ (p : Nat × Nat) : Nat</code>",
 "102":
 "<code>List.nil.{u} {α : Type u} : List α</code><span class=\"sep\"></span><code class=\"docstring\">The empty list, usually written `[]`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.</code>",
 "1019": "<code>bar₁ : Nat × Nat → Nat</code>",
 "1018": "<code>foo (n : Nat) (b c : Bool) : Nat</code>",
 "1017":
 "<code>filter.{u_1} {α : Type u_1} (p : α → Bool) : List α → List α</code>",
 "1016": "<code>isNotZero (m : Nat) : Bool</code>",
 "1015":
 "<code>Vect.zip.{u_1, u_2} {α : Type u_1} {n : Nat} {β : Type u_2} : Vect α n → Vect β n → Vect (α × β) n</code>",
 "1014": "<code>Vect β n✝</code>",
 "1013":
 "<code>Vect.map.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} {n : Nat} (f : α → β → γ) :\n  Vect α n → Vect β n → Vect γ n</code>",
 "1012":
 "<code>Vect.add.{u_1} {α : Type u_1} {n : Nat} [Add α] : Vect α n → Vect α n → Vect α n</code>",
 "1011": "<code>Vect α n✝</code>",
 "1010":
 "<code>Vect.add.{u_1} {α : Type u_1} [Add α] {n : Nat} : Vect α n → Vect α n → Vect α n</code>",
 "101":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "1009":
 "<code>inverse'.{u_1} {α β : Type u_1} {f : α → β} (b : β) : ImageOf f b → α</code>",
 "1008":
 "<code>inverse.{u_1} {α β : Type u_1} {f : α → β} (b : β) : ImageOf f b → α</code>",
 "1007":
 "<code>ImageOf.imf.{u} {α β : Type u} {f : α → β} (a : α) : ImageOf f (f a)</code>",
 "1006": "<code>ImageOf.{u} {α β : Type u} (f : α → β) : β → Type u</code>",
 "1005":
 "<code>Vect.noConfusion.{u_1, u} {α : Type u} {a✝ : Nat} {P : Sort u_1} {x1 x2 : Vect α a✝} (h12 : x1 = x2) :\n  Vect.noConfusionType P x1 x2</code>",
 "1004":
 "<code>Vect.casesOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vect α a → Sort u_1} {a✝ : Nat} (t : Vect α a✝)\n  (nil : motive 0 Vect.nil) (cons : (a : α) → {n : Nat} → (a_1 : Vect α n) → motive (n + 1) (Vect.cons a a_1)) :\n  motive a✝ t</code>",
 "1003":
 "<code>Vect.recOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vect α a → Sort u_1} {a✝ : Nat} (t : Vect α a✝)\n  (nil : motive 0 Vect.nil)\n  (cons : (a : α) → {n : Nat} → (a_1 : Vect α n) → motive n a_1 → motive (n + 1) (Vect.cons a a_1)) : motive a✝ t</code>",
 "1002":
 "<code>Vect.zipWith.{u_1, u_2, u_3} {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) {n : Nat} :\n  Vect α n → Vect β n → Vect γ n</code>",
 "1001":
 "<code>Vect.zip.{u_1, u_2} {α : Type u_1} {β : Type u_2} {n : Nat} : Vect α n → Vect β n → Vect (α × β) n</code>",
 "1000": "<code>Vect β n</code>",
 "100": "<code>Foo.ffa : Nat</code>",
 "10":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "1": "<code>Prop</code>",
 "0": "<code>and_commutative (p q : Prop) : p ∧ q → q ∧ p</code>"}